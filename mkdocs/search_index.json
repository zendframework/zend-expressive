{
    "docs": [
        {
            "location": "/", 
            "text": "Expressive: PSR-7 Middleware in Minutes\n\n\nExpressive builds on \nStratigility\n\nto provide a minimalist \nPSR-7\n middleware\nframework for PHP, with the following features:\n\n\n\n\nRouting. Choose your own router; we support:\n\n\nAura.Router\n\n\nFastRoute\n\n\nzend-router\n\n\n\n\n\n\nDI Containers, via \ncontainer-interop\n.\n  All middleware composed in Expressive may be retrieved from the composed\n  container.\n\n\nOptionally, templating. We support:\n\n\nPlates\n\n\nTwig\n\n\nZF2's PhpRenderer\n\n\n\n\n\n\nError handling. Create templated error pages, or use tools like\n  \nwhoops\n for debugging purposes.\n\n\nNested middleware applications. Write an application, and compose it later\n  in another, optionally under a separate subpath.\n\n\nSimplfied installation\n. Our custom\n  \nComposer\n-based installer prompts you for your\n  initial stack choices, giving you exactly the base you want to start from.\n\n\n\n\nEssentially, Expressive allows \nyou\n to develop using the tools \nyou\n prefer,\nand provides minimal structure and facilities to ease your development.\n\n\nKeep reading\n, and get started writing your first\nmiddleware application today!", 
            "title": "Home"
        }, 
        {
            "location": "/#expressive-psr-7-middleware-in-minutes", 
            "text": "Expressive builds on  Stratigility \nto provide a minimalist  PSR-7  middleware\nframework for PHP, with the following features:   Routing. Choose your own router; we support:  Aura.Router  FastRoute  zend-router    DI Containers, via  container-interop .\n  All middleware composed in Expressive may be retrieved from the composed\n  container.  Optionally, templating. We support:  Plates  Twig  ZF2's PhpRenderer    Error handling. Create templated error pages, or use tools like\n   whoops  for debugging purposes.  Nested middleware applications. Write an application, and compose it later\n  in another, optionally under a separate subpath.  Simplfied installation . Our custom\n   Composer -based installer prompts you for your\n  initial stack choices, giving you exactly the base you want to start from.   Essentially, Expressive allows  you  to develop using the tools  you  prefer,\nand provides minimal structure and facilities to ease your development.  Keep reading , and get started writing your first\nmiddleware application today!", 
            "title": "Expressive: PSR-7 Middleware in Minutes"
        }, 
        {
            "location": "/getting-started/features/", 
            "text": "Overview\n\n\nExpressive allows you to write \nPSR-7\n\n\nmiddleware\n\napplications for the web.\n\n\nPSR-7 is a standard defining HTTP message interfaces; these are the incoming\nrequest and outgoing response for your application. By using PSR-7, we ensure\nthat your applications will work in other PSR-7 contexts.\n\n\nMiddleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.\n\n\nMiddleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.\n\n\nWith Expressive, you can build PSR-7-based middleware applications:\n\n\n\n\nAPIs\n\n\nWebsites\n\n\nSingle Page Applications\n\n\nand more.\n\n\n\n\nFeatures\n\n\nExpressive builds on \nzend-stratigility\n\nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:\n\n\n\n\nRouting\n\n\n\n\nStratigility provides limited, literal matching only. Expressive allows you\n  to utilize dynamic routing capabilities from a variety of routers, providing\n  much more fine-grained matching capabilities. The routing layer also allows\n  restricting matched routes to specific HTTP methods, and will return \"405 Not\n  Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP\n  methods for invalid requests.\n\n\nRouting is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-mvc router.\n\n\n\n\ncontainer-interop\n\n\n\n\nExpressive encourages the use of Dependency Injection, and defines its\n  \nApplication\n class to compose a container-interop \nContainerInterface\n\n  instance. The container is used to lazy-load middleware, whether it is\n  piped (Stratigility interface) or routed (Expressive).\n\n\n\n\nTemplating\n\n\n\n\nWhile Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.\n\n\n\n\nError Handling\n\n\n\n\nApplications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own \nFinalHandler\n implementation, as well as\n  more advanced error handling via two specialized error handlers: a templated\n  error handler for production, and a Whoops-based error handler for development.\n\n\nFlow Overview\n\n\nBelow is a diagram detailing the workflow used by Expressive.\n\n\n\n\nThe \nApplication\n acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.\n\n\nThe \nApplication\n dispatches each middleware. Each middleware accepts a\n\nrequest\n, a \nresponse\n, and the \nnext\n middleware to dispatch. Internally,\nit's actually receiving the middleware stack itself, which knows which\nmiddleware to invoke next.\n\n\nAny given middleware can return a \nresponse\n, at which point execution winds\nits way back out the onion. Additionally, any given middleware can indicate an\nerror occurred, at which point it can call on the next \nerror handling\nmiddleware\n. These act like regular middleware, but accept an additional error\nargument to act on.\n\n\n\n\nPipelines\n\n\nThe terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a \nqueue\n, which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:\n\n\n\n\nIn most cases, the entire queue \nwill not\n be traversed.\n\n\nThe inner-most layer of the onion represents the last item in the queue.\n\n\nResponses are returned back \nthrough\n the pipeline, in reverse order of\n  traversal.\n\n\n\n\n\n\nThe \nApplication\n allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.\n\n\nYou can attach middleware manually, in which case the pipeline is executed in\nthe order of attachment, or use configuration. When you use configuration, you\nwill specify a priority integer to dictate the order in which middleware should\nbe attached.  Middleware specifying high integer prioritiess are attached (and\nthus executed) earlier, while those specifying lower and/or negative integers\nare attached later. The default priority is 1.\n\n\nExpressive provides a default implementation of \"routing\" and \"dispatch\"\nmiddleware, which you either attach to the middleware pipeline manually, or via\nconfiguration.\n\n\nRouting within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:\n\n\n\n\nmap a GET request to the path \n/api/ping\n to the \nPingMiddleware\n\n\nmap a POST request to the path \n/contact/process\n to the \nHandleContactMiddleware\n\n\netc.\n\n\n\n\nDispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation.\n\n\nThe majority of your application will consist of routing rules that map to\nrouted middleware.\n\n\nMiddleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:\n\n\n\n\nbootstrapping\n\n\nparsing of request body parameters\n\n\naddition of debugging tools\n\n\nembedded Expressive applications that you want to match at a given literal\n  path\n\n\netc.\n\n\n\n\nSuch middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.\n\n\nMiddleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:\n\n\n\n\nrouting failed\n\n\nrouted middleware called on the next middleware instead of returning a response.\n\n\n\n\nAs such, the largest use case for such middleware is for error handling.\nOne possibility is for \nproviding custom 404 handling\n,\nor handling application-specific error conditions (such as authentication or\nauthorization failures).\n\n\nAnother possibility is to provide post-processing on the response before\nreturning it. However, this is typically better handled via middleware piped\nearly, by capturing the response before returning it:\n\n\nfunction ($request, $response, $next)\n{\n    $response = $next($request, $response);\n    return $response-\nwithHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n}\n\n\n\n\nThe main points to remember are:\n\n\n\n\nThe application is a queue, and operates in FIFO order.\n\n\nEach middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.\n\n\nMost of the time, you will be defining \nrouted middleware\n, and the routing\n  rules that map to them.\n\n\nYou\n get to control the workflow of your application by deciding the order in\n  which middleware is queued.", 
            "title": "Overview and Features"
        }, 
        {
            "location": "/getting-started/features/#overview", 
            "text": "Expressive allows you to write  PSR-7  middleware \napplications for the web.  PSR-7 is a standard defining HTTP message interfaces; these are the incoming\nrequest and outgoing response for your application. By using PSR-7, we ensure\nthat your applications will work in other PSR-7 contexts.  Middleware is any code sitting between a request and a response; it typically\nanalyzes the request to aggregate incoming data, delegates it to another layer\nto process, and then creates and returns a response. Middleware can and should\nbe relegated only to those tasks, and should be relatively easy to write and\nmaintain.  Middleware is also designed for composability; you should be able to nest\nmiddleware and re-use middleware.  With Expressive, you can build PSR-7-based middleware applications:   APIs  Websites  Single Page Applications  and more.", 
            "title": "Overview"
        }, 
        {
            "location": "/getting-started/features/#features", 
            "text": "Expressive builds on  zend-stratigility \nto provide a robust convenience layer on which to build applications. The\nfeatures it provides include:   Routing   Stratigility provides limited, literal matching only. Expressive allows you\n  to utilize dynamic routing capabilities from a variety of routers, providing\n  much more fine-grained matching capabilities. The routing layer also allows\n  restricting matched routes to specific HTTP methods, and will return \"405 Not\n  Allowed\" responses with an \"Allow\" HTTP header containing allowed HTTP\n  methods for invalid requests.  Routing is abstracted in Expressive, allowing the developer to choose the\n  routing library that best fits the project needs. By default, we provide\n  wrappers for Aura.Router, FastRoute, and the zend-mvc router.   container-interop   Expressive encourages the use of Dependency Injection, and defines its\n   Application  class to compose a container-interop  ContainerInterface \n  instance. The container is used to lazy-load middleware, whether it is\n  piped (Stratigility interface) or routed (Expressive).   Templating   While Expressive does not assume templating is being used, it provides a\n  templating abstraction. Developers can write middleware that typehints on\n  this abstraction, and assume that the underlying adapter will provide\n  layout support and namespaced template support.   Error Handling   Applications should handle errors gracefully, but also handle them differently\n  in development versus production. Expressive provides both basic error\n  handling via Stratigility's own  FinalHandler  implementation, as well as\n  more advanced error handling via two specialized error handlers: a templated\n  error handler for production, and a Whoops-based error handler for development.", 
            "title": "Features"
        }, 
        {
            "location": "/getting-started/features/#flow-overview", 
            "text": "Below is a diagram detailing the workflow used by Expressive.   The  Application  acts as an \"onion\"; in the diagram above, the top is the\nouter-most layer of the onion, while the bottom is the inner-most.  The  Application  dispatches each middleware. Each middleware accepts a request , a  response , and the  next  middleware to dispatch. Internally,\nit's actually receiving the middleware stack itself, which knows which\nmiddleware to invoke next.  Any given middleware can return a  response , at which point execution winds\nits way back out the onion. Additionally, any given middleware can indicate an\nerror occurred, at which point it can call on the next  error handling\nmiddleware . These act like regular middleware, but accept an additional error\nargument to act on.", 
            "title": "Flow Overview"
        }, 
        {
            "location": "/getting-started/features/#pipelines", 
            "text": "The terminology \"pipeline\" is often used to describe the onion. One way of\nlooking at the \"onion\" is as a  queue , which is first-in-first-out (FIFO) in\noperation. This means that the first middleware on the queue is executed first,\nand this invokes the next, and so on (and hence the \"next\" terminology). When\nlooked at from this perspective:   In most cases, the entire queue  will not  be traversed.  The inner-most layer of the onion represents the last item in the queue.  Responses are returned back  through  the pipeline, in reverse order of\n  traversal.    The  Application  allows arbitrary middleware to be injected, with each being\nexecuted in the order in which they are attached; returning a response from\nmiddleware prevents any middleware attached later from executing.  You can attach middleware manually, in which case the pipeline is executed in\nthe order of attachment, or use configuration. When you use configuration, you\nwill specify a priority integer to dictate the order in which middleware should\nbe attached.  Middleware specifying high integer prioritiess are attached (and\nthus executed) earlier, while those specifying lower and/or negative integers\nare attached later. The default priority is 1.  Expressive provides a default implementation of \"routing\" and \"dispatch\"\nmiddleware, which you either attach to the middleware pipeline manually, or via\nconfiguration.  Routing within Expressive consists of decomposing the request to match it to\nmiddleware that can handle that given request. This typically consists of a\ncombination of matching the requested URI path along with allowed HTTP methods:   map a GET request to the path  /api/ping  to the  PingMiddleware  map a POST request to the path  /contact/process  to the  HandleContactMiddleware  etc.   Dispatching is simply the act of calling the middleware mapped by routing. The\ntwo events are modeled as separate middleware to allow you to act on the results\nof routing before attempting to dispatch the mapped middleware; this can be\nuseful for implementing route-based authentication or validation.  The majority of your application will consist of routing rules that map to\nrouted middleware.  Middleware piped to the application earlier than routing should be middleware\nthat you wish to execute for every request. These might include:   bootstrapping  parsing of request body parameters  addition of debugging tools  embedded Expressive applications that you want to match at a given literal\n  path  etc.   Such middleware may decide that a request is invalid, and return a response;\ndoing so means no further middleware will be executed! This is an important\nfeature of middleware architectures, as it allows you to define\napplication-specific workflows optimized for performance, security, etc.  Middleware piped to the application after the routing and dispatch middleware\nwill execute in one of two conditions:   routing failed  routed middleware called on the next middleware instead of returning a response.   As such, the largest use case for such middleware is for error handling.\nOne possibility is for  providing custom 404 handling ,\nor handling application-specific error conditions (such as authentication or\nauthorization failures).  Another possibility is to provide post-processing on the response before\nreturning it. However, this is typically better handled via middleware piped\nearly, by capturing the response before returning it:  function ($request, $response, $next)\n{\n    $response = $next($request, $response);\n    return $response- withHeader('X-Clacks-Overhead', 'GNU Terry Pratchett');\n}  The main points to remember are:   The application is a queue, and operates in FIFO order.  Each middleware can choose whether to return a response, which will cause\n  the queue to unwind, or to traverse to the next middleware.  Most of the time, you will be defining  routed middleware , and the routing\n  rules that map to them.  You  get to control the workflow of your application by deciding the order in\n  which middleware is queued.", 
            "title": "Pipelines"
        }, 
        {
            "location": "/getting-started/standalone/", 
            "text": "Quick Start: Standalone Usage\n\n\nExpressive allows you to get started at your own pace. You can start with\nthe simplest example, detailed below, or move on to a more structured,\nconfiguration-driven approach as detailed in the \nuse case examples\n.\n\n\n1. Create a new project directory\n\n\nFirst, let's create a new project directory and enter it:\n\n\n$ mkdir expressive\n$ cd expressive\n\n\n\n\n2. Install Expressive\n\n\nIf you haven't already, \ninstall Composer\n. Once you\nhave, we can install Expressive, along with a router and a container:\n\n\n$ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager\n\n\n\n\n\n\nRouters\n\n\nExpressive needs a routing implementation in order to create routed\nmiddleware. We suggest FastRoute in the quick start, but you can also\ncurrently choose from Aura.Router and zend-router.\n\n\nContainers\n\n\nWe highly recommend using dependency injection containers with Expressive;\nthey allow you to define dependencies for your middleware, as well as to lazy\nload your middleware only when it needs to be executed. We suggest\nzend-servicemanager in the quick start, but you can also use any container\nsupporting \ncontainer-interop\n.\n\n\n\n\n3. Create a web root directory\n\n\nYou'll need a directory from which to serve your application, and for security\nreasons, it's a good idea to keep it separate from your source code. We'll\ncreate a \npublic/\n directory for this:\n\n\n$ mkdir public\n\n\n\n\n4. Create your bootstrap script\n\n\nNext, we'll create a bootstrap script. Such scripts typically setup the\nenvironment, setup the application, and invoke it. This needs to be in our web\nroot, and we want it to intercept any incoming request; as such, we'll use\n\npublic/index.php\n:\n\n\n?php\nuse Zend\\Expressive\\AppFactory;\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$app = AppFactory::create();\n\n$app-\nget('/', function ($request, $response, $next) {\n    $response-\ngetBody()-\nwrite('Hello, world!');\n    return $response;\n});\n\n$app-\npipeRoutingMiddleware();\n$app-\npipeDispatchMiddleware();\n$app-\nrun();\n\n\n\n\n\n\nRewriting URLs\n\n\nMany web servers will not rewrite URLs to the bootstrap script by default. If\nyou use Apache, for instance, you'll need to setup rewrite rules to ensure\nyour bootstrap is invoked for unknown URLs. We'll cover that in a later\nchapter.\n\n\nRouting and dispatching\n\n\nNote the lines from the above:\n\n\n$app-\npipeRoutingMiddleware();\n$app-\npipeDispatchMiddleware();\n\n\n\n\nExpressive's \nApplication\n class provides two separate middlewares, one for\nrouting, and one for dispatching middleware matched by routing. This allows\nyou to slip in validations between the two activities if desired. They are\nnot automatically piped to the application, however, to allow exactly that\nsituation, which means they must be piped manually.\n\n\n\n\n5. Start a web server\n\n\nSince we're just testing out the basic functionality of our application, we'll\nuse PHP's \nbuilt-in web server\n.\n\n\nFrom the project root directory, execute the following:\n\n\n$ php -S 0.0.0.0:8080 -t public/\n\n\n\n\nThis starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!\n\n\n\n\nTip: Serve via Composer\n\n\nTo simplify starting up a local web server, try adding the following to your\n\ncomposer.json\n:\n\n\nscripts\n: {\n    \nserve\n: \nphp -S 0.0.0.0:8080 -t public/\n\n}\n\n\n\n\nOnce you've added that, you can fire up the web server using:\n\n\n$ composer serve\n\n\n\n\n\n\nNext steps\n\n\nAt this point, you have a working zend-expressive application, that responds to\na single route. From here, you may want to read up on:\n\n\n\n\nApplications\n\n\nContainers\n\n\nRouting\n\n\nTemplating\n\n\nError Handling\n\n\n\n\nAdditionally, we have more \nuse case examples\n.", 
            "title": "Quick Start: Standalone"
        }, 
        {
            "location": "/getting-started/standalone/#quick-start-standalone-usage", 
            "text": "Expressive allows you to get started at your own pace. You can start with\nthe simplest example, detailed below, or move on to a more structured,\nconfiguration-driven approach as detailed in the  use case examples .", 
            "title": "Quick Start: Standalone Usage"
        }, 
        {
            "location": "/getting-started/standalone/#1-create-a-new-project-directory", 
            "text": "First, let's create a new project directory and enter it:  $ mkdir expressive\n$ cd expressive", 
            "title": "1. Create a new project directory"
        }, 
        {
            "location": "/getting-started/standalone/#2-install-expressive", 
            "text": "If you haven't already,  install Composer . Once you\nhave, we can install Expressive, along with a router and a container:  $ composer require zendframework/zend-expressive zendframework/zend-expressive-fastroute zendframework/zend-servicemanager", 
            "title": "2. Install Expressive"
        }, 
        {
            "location": "/getting-started/standalone/#routers", 
            "text": "Expressive needs a routing implementation in order to create routed\nmiddleware. We suggest FastRoute in the quick start, but you can also\ncurrently choose from Aura.Router and zend-router.", 
            "title": "Routers"
        }, 
        {
            "location": "/getting-started/standalone/#containers", 
            "text": "We highly recommend using dependency injection containers with Expressive;\nthey allow you to define dependencies for your middleware, as well as to lazy\nload your middleware only when it needs to be executed. We suggest\nzend-servicemanager in the quick start, but you can also use any container\nsupporting  container-interop .", 
            "title": "Containers"
        }, 
        {
            "location": "/getting-started/standalone/#3-create-a-web-root-directory", 
            "text": "You'll need a directory from which to serve your application, and for security\nreasons, it's a good idea to keep it separate from your source code. We'll\ncreate a  public/  directory for this:  $ mkdir public", 
            "title": "3. Create a web root directory"
        }, 
        {
            "location": "/getting-started/standalone/#4-create-your-bootstrap-script", 
            "text": "Next, we'll create a bootstrap script. Such scripts typically setup the\nenvironment, setup the application, and invoke it. This needs to be in our web\nroot, and we want it to intercept any incoming request; as such, we'll use public/index.php :  ?php\nuse Zend\\Expressive\\AppFactory;\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n\n$app = AppFactory::create();\n\n$app- get('/', function ($request, $response, $next) {\n    $response- getBody()- write('Hello, world!');\n    return $response;\n});\n\n$app- pipeRoutingMiddleware();\n$app- pipeDispatchMiddleware();\n$app- run();", 
            "title": "4. Create your bootstrap script"
        }, 
        {
            "location": "/getting-started/standalone/#rewriting-urls", 
            "text": "Many web servers will not rewrite URLs to the bootstrap script by default. If\nyou use Apache, for instance, you'll need to setup rewrite rules to ensure\nyour bootstrap is invoked for unknown URLs. We'll cover that in a later\nchapter.", 
            "title": "Rewriting URLs"
        }, 
        {
            "location": "/getting-started/standalone/#routing-and-dispatching", 
            "text": "Note the lines from the above:  $app- pipeRoutingMiddleware();\n$app- pipeDispatchMiddleware();  Expressive's  Application  class provides two separate middlewares, one for\nrouting, and one for dispatching middleware matched by routing. This allows\nyou to slip in validations between the two activities if desired. They are\nnot automatically piped to the application, however, to allow exactly that\nsituation, which means they must be piped manually.", 
            "title": "Routing and dispatching"
        }, 
        {
            "location": "/getting-started/standalone/#5-start-a-web-server", 
            "text": "Since we're just testing out the basic functionality of our application, we'll\nuse PHP's  built-in web server .  From the project root directory, execute the following:  $ php -S 0.0.0.0:8080 -t public/  This starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!", 
            "title": "5. Start a web server"
        }, 
        {
            "location": "/getting-started/standalone/#tip-serve-via-composer", 
            "text": "To simplify starting up a local web server, try adding the following to your composer.json :  scripts : {\n     serve :  php -S 0.0.0.0:8080 -t public/ \n}  Once you've added that, you can fire up the web server using:  $ composer serve", 
            "title": "Tip: Serve via Composer"
        }, 
        {
            "location": "/getting-started/standalone/#next-steps", 
            "text": "At this point, you have a working zend-expressive application, that responds to\na single route. From here, you may want to read up on:   Applications  Containers  Routing  Templating  Error Handling   Additionally, we have more  use case examples .", 
            "title": "Next steps"
        }, 
        {
            "location": "/getting-started/skeleton/", 
            "text": "Quick Start: Using the Skeleton + Installer\n\n\nThe easiest way to get started with Expressive is to use the \nskeleton\napplication and installer\n.\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.\n\n\n1. Create a new project\n\n\nFirst, we'll create a new project, using Composer's \ncreate-project\n command:\n\n\n$ composer create-project zendframework/zend-expressive-skeleton expressive\n\n\n\n\nThis will prompt you to choose:\n\n\n\n\nA router. We recommend using the default, FastRoute.\n\n\nA dependency injection container. We recommend using the default, Zend\n  ServiceManager.\n\n\nA template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.\n\n\nAn error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.\n\n\n\n\n2. Start a web server\n\n\nThe Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using \nbuilt-in web\nserver\n.\n\n\nFrom the project root directory, execute the following:\n\n\n$ composer serve\n\n\n\n\nThis starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!\n\n\nNext Steps\n\n\nThe skeleton makes the assumption that you will be writing your middleware as\nclasses, and using configuration to map routes to middleware. It also provides a\ndefault structure for templates, if you choose to use them. Let's see how you\ncan create first vanilla middleware, and then templated middleware.\n\n\nCreating middleware\n\n\nThe easiest way to create middleware is to create a class that defines an\n\n__invoke()\n method accepting a request, response, and callable \"next\" argument\n(for invoking the \"next\" middleware in the queue). The skeleton defines an \nApp\n\nnamespace for you, and suggests placing middleware under the namespace\n\nApp\\Action\n.\n\n\nLet's create a \"Hello\" action. Place the following in\n\nsrc/App/Action/HelloAction.php\n:\n\n\n?php\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass HelloAction\n{\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $query  = $request-\ngetQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n        $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\n\n        $response-\ngetBody()-\nwrite(sprintf(\n            '\nh1\nHello, %s!\n/h1\n',\n            $target\n        ));\n        return $response-\nwithHeader('Content-Type', 'text/html');\n    }\n}\n\n\n\n\nThe above looks for a query string parameter \"target\", and uses its value to\nprovide a message, which is then returned in an HTML response.\n\n\nNow we need to inform the application of this middleware, and indicate what\npath will invoke it. Open the file \nconfig/autoload/routes.global.php\n. Inside\nthat file, you should have a structure similar to the following:\n\n\nreturn [\n    'dependencies' =\n [\n        /* ... */\n    ],\n    'routes' =\n [\n        /* ... */\n    ],\n];\n\n\n\n\nWe're going to add an entry under \nroutes\n:\n\n\nreturn [\n    /* ... */\n    'routes' =\n [\n        /* ... */\n        [\n            'name' =\n 'hello',\n            'path' =\n '/hello',\n            'middleware' =\n App\\Action\\HelloAction::class,\n            'allowed_methods' =\n ['GET'],\n        ],\n    ],\n];\n\n\n\n\nOnce you've added the above entry, give it a try by going to each of the\nfollowing URIs:\n\n\n\n\nhttp://localhost:8080/hello\n\n\nhttp://localhost:8080/hello?target=ME\n\n\n\n\nYou should see the message change as you go between the two URIs!\n\n\nUsing templates\n\n\nYou likely don't want to hardcode HTML into your middleware; so, let's use\ntemplates. This particular exercise assumes you chose to use the\n\nPlates\n integration.\n\n\nTemplates are installed under the \ntemplates/\n subdirectory. By default, we also\nregister the template namespace \napp\n to correspond with the \ntemplates/app\n\nsubdirectory. Create the file \ntemplates/app/hello-world.phtml\n with the\nfollowing contents:\n\n\n?php $this-\nlayout('layout::default', ['title' =\n 'Greetings']) ?\n\n\n\nh2\nHello, \n?= $this-\ne($target) ?\n/h2\n\n\n\n\nNow that we have a template, we need to:\n\n\n\n\nInject a renderer into our action class.\n\n\nUse the renderer to render the contents.\n\n\n\n\nReplace your \nsrc/App/Action/HelloAction.php\n file with the following contents:\n\n\n?php\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloAction\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this-\nrenderer = $renderer;\n    }\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $query  = $request-\ngetQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        return new HtmlResponse(\n            $this-\nrenderer-\nrender('app::hello-world', ['target' =\n $target])\n        );\n    }\n}\n\n\n\n\nThe above modifies the class to accept a renderer to the constructor, and then\ncalls on it to render a template. A few things to note:\n\n\n\n\nWe no longer need to escape our target; the template takes care of that for us.\n\n\nWe're using a specific response type here, from\n  \nDiactoros\n, which is the\n  default PSR-7 implementation Expressive uses. This response type simplifies\n  our response creation.\n\n\n\n\nHow does the template renderer get into the action, however? The answer is\ndependency injection.\n\n\nFor the next part of the example, we'll be creating and wiring a factory for\ncreating the \nHelloAction\n instance; the example assumes you used the default\nselection for a dependency injection container, Zend ServiceManager.\n\n\nLet's create a factory. Create the file \nsrc/App/Action/HelloActionFactory.php\n with\nthe following contents:\n\n\n?php\nnamespace App\\Action;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new HelloAction(\n            $container-\nget(TemplateRendererInterface::class)\n        );\n    }\n}\n\n\n\n\nWith that in place, we'll now update our configuration. Open the file\n\nconfig/autoload/routes.global.php\n; it should have a structure similar to\nthe following:\n\n\nreturn [\n    'dependencies' =\n [\n        'invokables' =\n [\n            /* ... */\n        ],\n    ],\n    'routes' =\n [\n        /* ... */\n    ],\n];\n\n\n\n\nWe're going to tell our application that we have a \nfactory\n for our\n\nHelloAction\n class:\n\n\nreturn [\n    'dependencies' =\n [\n        /* ... */\n        'factories' =\n [\n            /* ... */\n            App\\Action\\HelloAction::class =\n App\\Action\\HelloActionFactory::class,\n        ],\n    ],\n    'routes' =\n [\n        /* ... */\n    ],\n];\n\n\n\n\nSave that file, and now re-visit the URIs:\n\n\n\n\nhttp://localhost:8080/hello\n\n\nhttp://localhost:8080/hello?target=ME\n\n\n\n\nYour page should now have the same layout as the landing page of the skeleton\napplication!\n\n\nCongratulations!\n\n\nCongratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:\n\n\n\n\nContainers\n\n\nRouting\n\n\nTemplating\n\n\nError Handling", 
            "title": "Quick Start: Skeleton Installer"
        }, 
        {
            "location": "/getting-started/skeleton/#quick-start-using-the-skeleton-installer", 
            "text": "The easiest way to get started with Expressive is to use the  skeleton\napplication and installer .\nThe skeleton provides a generic structure for creating your applications, and\nprompts you to choose a router, dependency injection container, template\nrenderer, and error handler from the outset.", 
            "title": "Quick Start: Using the Skeleton + Installer"
        }, 
        {
            "location": "/getting-started/skeleton/#1-create-a-new-project", 
            "text": "First, we'll create a new project, using Composer's  create-project  command:  $ composer create-project zendframework/zend-expressive-skeleton expressive  This will prompt you to choose:   A router. We recommend using the default, FastRoute.  A dependency injection container. We recommend using the default, Zend\n  ServiceManager.  A template renderer. You can ignore this when creating an API project, but if\n  you will be creating any HTML pages, we recommend installing one. We prefer\n  Plates.  An error handler. Whoops is a very nice option for development, as it gives\n  you extensive, browseable information for exceptions and errors raised.", 
            "title": "1. Create a new project"
        }, 
        {
            "location": "/getting-started/skeleton/#2-start-a-web-server", 
            "text": "The Skeleton + Installer creates a full application structure that's ready-to-go\nwhen complete. You can test it out using  built-in web\nserver .  From the project root directory, execute the following:  $ composer serve  This starts up a web server on localhost port 8080; browse to\nhttp://localhost:8080/ to see if your application responds correctly!", 
            "title": "2. Start a web server"
        }, 
        {
            "location": "/getting-started/skeleton/#next-steps", 
            "text": "The skeleton makes the assumption that you will be writing your middleware as\nclasses, and using configuration to map routes to middleware. It also provides a\ndefault structure for templates, if you choose to use them. Let's see how you\ncan create first vanilla middleware, and then templated middleware.", 
            "title": "Next Steps"
        }, 
        {
            "location": "/getting-started/skeleton/#creating-middleware", 
            "text": "The easiest way to create middleware is to create a class that defines an __invoke()  method accepting a request, response, and callable \"next\" argument\n(for invoking the \"next\" middleware in the queue). The skeleton defines an  App \nnamespace for you, and suggests placing middleware under the namespace App\\Action .  Let's create a \"Hello\" action. Place the following in src/App/Action/HelloAction.php :  ?php\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass HelloAction\n{\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $query  = $request- getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n        $target = htmlspecialchars($target, ENT_HTML5, 'UTF-8');\n\n        $response- getBody()- write(sprintf(\n            ' h1 Hello, %s! /h1 ',\n            $target\n        ));\n        return $response- withHeader('Content-Type', 'text/html');\n    }\n}  The above looks for a query string parameter \"target\", and uses its value to\nprovide a message, which is then returned in an HTML response.  Now we need to inform the application of this middleware, and indicate what\npath will invoke it. Open the file  config/autoload/routes.global.php . Inside\nthat file, you should have a structure similar to the following:  return [\n    'dependencies' =  [\n        /* ... */\n    ],\n    'routes' =  [\n        /* ... */\n    ],\n];  We're going to add an entry under  routes :  return [\n    /* ... */\n    'routes' =  [\n        /* ... */\n        [\n            'name' =  'hello',\n            'path' =  '/hello',\n            'middleware' =  App\\Action\\HelloAction::class,\n            'allowed_methods' =  ['GET'],\n        ],\n    ],\n];  Once you've added the above entry, give it a try by going to each of the\nfollowing URIs:   http://localhost:8080/hello  http://localhost:8080/hello?target=ME   You should see the message change as you go between the two URIs!", 
            "title": "Creating middleware"
        }, 
        {
            "location": "/getting-started/skeleton/#using-templates", 
            "text": "You likely don't want to hardcode HTML into your middleware; so, let's use\ntemplates. This particular exercise assumes you chose to use the Plates  integration.  Templates are installed under the  templates/  subdirectory. By default, we also\nregister the template namespace  app  to correspond with the  templates/app \nsubdirectory. Create the file  templates/app/hello-world.phtml  with the\nfollowing contents:  ?php $this- layout('layout::default', ['title' =  'Greetings']) ?  h2 Hello,  ?= $this- e($target) ? /h2  Now that we have a template, we need to:   Inject a renderer into our action class.  Use the renderer to render the contents.   Replace your  src/App/Action/HelloAction.php  file with the following contents:  ?php\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloAction\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this- renderer = $renderer;\n    }\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next)\n    {\n        $query  = $request- getQueryParams();\n        $target = isset($query['target']) ? $query['target'] : 'World';\n\n        return new HtmlResponse(\n            $this- renderer- render('app::hello-world', ['target' =  $target])\n        );\n    }\n}  The above modifies the class to accept a renderer to the constructor, and then\ncalls on it to render a template. A few things to note:   We no longer need to escape our target; the template takes care of that for us.  We're using a specific response type here, from\n   Diactoros , which is the\n  default PSR-7 implementation Expressive uses. This response type simplifies\n  our response creation.   How does the template renderer get into the action, however? The answer is\ndependency injection.  For the next part of the example, we'll be creating and wiring a factory for\ncreating the  HelloAction  instance; the example assumes you used the default\nselection for a dependency injection container, Zend ServiceManager.  Let's create a factory. Create the file  src/App/Action/HelloActionFactory.php  with\nthe following contents:  ?php\nnamespace App\\Action;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass HelloActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new HelloAction(\n            $container- get(TemplateRendererInterface::class)\n        );\n    }\n}  With that in place, we'll now update our configuration. Open the file config/autoload/routes.global.php ; it should have a structure similar to\nthe following:  return [\n    'dependencies' =  [\n        'invokables' =  [\n            /* ... */\n        ],\n    ],\n    'routes' =  [\n        /* ... */\n    ],\n];  We're going to tell our application that we have a  factory  for our HelloAction  class:  return [\n    'dependencies' =  [\n        /* ... */\n        'factories' =  [\n            /* ... */\n            App\\Action\\HelloAction::class =  App\\Action\\HelloActionFactory::class,\n        ],\n    ],\n    'routes' =  [\n        /* ... */\n    ],\n];  Save that file, and now re-visit the URIs:   http://localhost:8080/hello  http://localhost:8080/hello?target=ME   Your page should now have the same layout as the landing page of the skeleton\napplication!", 
            "title": "Using templates"
        }, 
        {
            "location": "/getting-started/skeleton/#congratulations", 
            "text": "Congratulations! You've now created your application, and started writing\nmiddleware! It's time to start learning about the rest of the features of\nExpressive:   Containers  Routing  Templating  Error Handling", 
            "title": "Congratulations!"
        }, 
        {
            "location": "/features/application/", 
            "text": "Applications\n\n\nIn zend-expressive, you define a \nZend\\Expressive\\Application\n instance and\nexecute it. The \nApplication\n instance is itself \nmiddleware\n\nthat composes:\n\n\n\n\na \nrouter\n, for dynamically routing requests to middleware.\n\n\na \ndependency injection container\n, for retrieving\n  middleware to dispatch.\n\n\na \nfinal handler\n, for handling error conditions raised by\n  the application.\n\n\nan \nemitter\n,\n  for emitting the response when application execution is complete.\n\n\n\n\nYou can define the \nApplication\n instance in several ways:\n\n\n\n\nDirect instantiation, which requires providing several dependencies.\n\n\nThe \nAppFactory\n, which will use some common defaults, but allows injecting alternate\n  container and/or router implementations.\n\n\nVia a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.\n\n\n\n\nRegardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.\n\n\nInstantiation\n\n\nAs noted at the start of this document, we provide several ways to create an\n\nApplication\n instance.\n\n\nConstructor\n\n\nIf you wish to manually instantiate the \nApplication\n instance, it has the\nfollowing constructor:\n\n\n/**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Interop\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|callable $finalHandler Final handler to use when $out is not\n *     provided on invocation.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Interop\\Container\\ContainerInterface $container = null,\n    callable $finalHandler = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);\n\n\n\n\nIf no container is provided at instantiation, then all routed and piped\nmiddleware \nmust\n be provided as callables.\n\n\nAppFactory\n\n\nZend\\Expressive\\AppFactory\n provides a convenience layer for creating an\n\nApplication\n instance; it makes the assumption that you will use defaults in\nmost situations, and likely only change which container and/or router you wish\nto use. It has the following signature:\n\n\nAppFactory::create(\n    Interop\\Container\\ContainerInterface $container = null,\n    Zend\\Expressive\\Router\\RouterInterface $router = null\n);\n\n\n\n\nWhen no container or router are provided, it defaults to:\n\n\n\n\nzend-servicemanager for the container.\n\n\nFastRoute for the router.\n\n\n\n\nContainer factory\n\n\nWe also provide a factory that can be consumed by a\n\ncontainer-interop\n\ndependency injection container; see the \ncontainer factories documentation\n\nfor details.\n\n\nAdding routable middleware\n\n\nWe \ndiscuss routing vs piping elsewhere\n; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.\n\n\nRegardless of which \nrouter implementation\n you use, you\ncan use the following methods to provide routable middleware:\n\n\nroute()\n\n\nroute()\n has the following signature:\n\n\npublic function route(\n    $pathOrRoute,\n    $middleware = null,\n    array $methods = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\n\nwhere:\n\n\n\n\n$pathOrRoute\n may be either a string path to match, or a\n  \nZend\\Expressive\\Router\\Route\n instance.\n\n\n$middleware\n \nmust\n be present if \n$pathOrRoute\n is a string path, and\n  \nmust\n be:\n\n\na callable;\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class;\n\n\nan array of any of the above; these will be composed in order into a\n    \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n$methods\n must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.\n\n\n$name\n is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on \nroute naming\n\n  for details.\n\n\n\n\nThis method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.\n\n\nget(), post(), put(), patch(), delete(), any()\n\n\nEach of the methods \nget()\n, \npost()\n, \nput()\n, \npatch()\n, \ndelete()\n, and \nany()\n\nproxies to \nroute()\n and has the signature:\n\n\nfunction (\n    $pathOrRoute,\n    $middleware = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route\n\n\n\n\nEssentially, each calls \nroute()\n and specifies an array consisting solely of\nthe corresponding HTTP method for the \n$methods\n argument.\n\n\nPiping\n\n\nBecause zend-expressive builds on \nzend-stratigility\n,\nand, more specifically, its \nMiddlewarePipe\n definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.\n\n\nThe signature of \npipe()\n is:\n\n\npublic function pipe($pathOrMiddleware, $middleware = null)\n\n\n\n\nwhere:\n\n\n\n\n$pathOrMiddleware\n is either a string URI path (for path segregation), a\n  callable middleware, or the service name for a middleware to fetch from the\n  composed container.\n\n\n$middleware\n is required if \n$pathOrMiddleware\n is a string URI path. It can\n  be one of:\n\n\na callable;\n\n\na service name that resolves to valid middleware in the container;\n\n\na fully qualified class name of a constructor-less class;\n\n\nan array of any of the above; these will be composed in order into a\n    \nZend\\Stratigility\\MiddlewarePipe\n instance.\n\n\n\n\nUnlike \nZend\\Stratigility\\MiddlewarePipe\n, \nApplication::pipe()\n \nallows\nfetching middleware by service name\n. This facility allows lazy-loading of\nmiddleware only when it is invoked. Internally, it wraps the call to fetch and\ndispatch the middleware inside a closure.\n\n\nAdditionally, we define a new method, \npipeErrorHandler()\n, with the following\nsignature:\n\n\npublic function pipeErrorHandler($pathOrMiddleware, $middleware = null)\n\n\n\n\nIt acts just like \npipe()\n except when the middleware specified is a service\nname; in that particular case, when it wraps the middleware in a closure, it\nuses the error handler signature:\n\n\nfunction ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next);\n\n\n\n\nRead the section on \npiping vs routing\n for more information.\n\n\nRegistering routing and dispatch middleware\n\n\nRouting is accomplished via a dedicated middleware method,\n\nApplication::routeMiddleware()\n; similarly, dispatching of routed middleware\nhas a corresponding instance middleware method, \nApplication::dispatchMiddleware()\n.\nEach can be piped/registered with other middleware platforms if desired.\n\n\nThese methods \nMUST\n be piped to the application so that the application will\nroute and dispatch routed middleware. This is done using the following methods:\n\n\n$app-\npipeRoutingMiddleware();\n$app-\npipeDispatchMiddleware();\n\n\n\n\nSee the section on \npiping\n to see how you can register\nnon-routed middleware and create layered middleware applications.\n\n\nRetrieving dependencies\n\n\nAs noted in the intro, the \nApplication\n class has several dependencies. Some of\nthese may allow further configuration, or may be useful on their own, and have\nmethods for retrieving them. They include:\n\n\n\n\ngetContainer()\n: returns the composed \ncontainer-interop\n\n  instance (used to retrieve routed middleware).\n\n\ngetEmitter()\n: returns the composed\n  \nemitter\n,\n  typically a \nZend\\Expressive\\Emitter\\EmitterStack\n instance.\n\n\ngetFinalHandler(ResponseInterface $response = null)\n: retrieves the final\n  handler instance. This is middleware with the signature \nfunction ($request,\n  $response, $error = null)\n, and it is invoked when the middleware pipeline\n  queue is depleted and no response has been returned.\n\n\n\n\nExecuting the application: run()\n\n\nWhen the application is completely setup, you can execute it with the \nrun()\n\nmethod. The method may be called with no arguments, but has the following\nsignature:\n\n\npublic function run(\n    ServerRequestInterface $request = null,\n    ResponseInterface $response = null\n);", 
            "title": "Applications"
        }, 
        {
            "location": "/features/application/#applications", 
            "text": "In zend-expressive, you define a  Zend\\Expressive\\Application  instance and\nexecute it. The  Application  instance is itself  middleware \nthat composes:   a  router , for dynamically routing requests to middleware.  a  dependency injection container , for retrieving\n  middleware to dispatch.  a  final handler , for handling error conditions raised by\n  the application.  an  emitter ,\n  for emitting the response when application execution is complete.   You can define the  Application  instance in several ways:   Direct instantiation, which requires providing several dependencies.  The  AppFactory , which will use some common defaults, but allows injecting alternate\n  container and/or router implementations.  Via a dependency injection container; we provide a factory for setting up all\n  aspects of the instance via configuration and other defined services.   Regardless of how you setup the instance, there are several methods you will\nlikely interact with at some point or another.", 
            "title": "Applications"
        }, 
        {
            "location": "/features/application/#instantiation", 
            "text": "As noted at the start of this document, we provide several ways to create an Application  instance.", 
            "title": "Instantiation"
        }, 
        {
            "location": "/features/application/#constructor", 
            "text": "If you wish to manually instantiate the  Application  instance, it has the\nfollowing constructor:  /**\n * @param Zend\\Expressive\\Router\\RouterInterface $router\n * @param null|Interop\\Container\\ContainerInterface $container IoC container from which to pull services, if any.\n * @param null|callable $finalHandler Final handler to use when $out is not\n *     provided on invocation.\n * @param null|Zend\\Diactoros\\Response\\EmitterInterface $emitter Emitter to use when `run()` is\n *     invoked.\n */\npublic function __construct(\n    Zend\\Expressive\\Router\\RouterInterface $router,\n    Interop\\Container\\ContainerInterface $container = null,\n    callable $finalHandler = null,\n    Zend\\Diactoros\\Response\\EmitterInterface $emitter = null\n);  If no container is provided at instantiation, then all routed and piped\nmiddleware  must  be provided as callables.", 
            "title": "Constructor"
        }, 
        {
            "location": "/features/application/#appfactory", 
            "text": "Zend\\Expressive\\AppFactory  provides a convenience layer for creating an Application  instance; it makes the assumption that you will use defaults in\nmost situations, and likely only change which container and/or router you wish\nto use. It has the following signature:  AppFactory::create(\n    Interop\\Container\\ContainerInterface $container = null,\n    Zend\\Expressive\\Router\\RouterInterface $router = null\n);  When no container or router are provided, it defaults to:   zend-servicemanager for the container.  FastRoute for the router.", 
            "title": "AppFactory"
        }, 
        {
            "location": "/features/application/#container-factory", 
            "text": "We also provide a factory that can be consumed by a container-interop \ndependency injection container; see the  container factories documentation \nfor details.", 
            "title": "Container factory"
        }, 
        {
            "location": "/features/application/#adding-routable-middleware", 
            "text": "We  discuss routing vs piping elsewhere ; routing is the act\nof dynamically matching an incoming request against criteria, and it is one of\nthe primary features of zend-expressive.  Regardless of which  router implementation  you use, you\ncan use the following methods to provide routable middleware:", 
            "title": "Adding routable middleware"
        }, 
        {
            "location": "/features/application/#route", 
            "text": "route()  has the following signature:  public function route(\n    $pathOrRoute,\n    $middleware = null,\n    array $methods = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route  where:   $pathOrRoute  may be either a string path to match, or a\n   Zend\\Expressive\\Router\\Route  instance.  $middleware   must  be present if  $pathOrRoute  is a string path, and\n   must  be:  a callable;  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class;  an array of any of the above; these will be composed in order into a\n     Zend\\Stratigility\\MiddlewarePipe  instance.  $methods  must be an array of HTTP methods valid for the given path and\n  middleware. If null, it assumes any method is valid.  $name  is the optional name for the route, and is used when generating a URI\n  from known routes. See the section on  route naming \n  for details.   This method is typically only used if you want a single middleware to handle\nmultiple HTTP request methods.", 
            "title": "route()"
        }, 
        {
            "location": "/features/application/#get-post-put-patch-delete-any", 
            "text": "Each of the methods  get() ,  post() ,  put() ,  patch() ,  delete() , and  any() \nproxies to  route()  and has the signature:  function (\n    $pathOrRoute,\n    $middleware = null,\n    $name = null\n) : Zend\\Expressive\\Router\\Route  Essentially, each calls  route()  and specifies an array consisting solely of\nthe corresponding HTTP method for the  $methods  argument.", 
            "title": "get(), post(), put(), patch(), delete(), any()"
        }, 
        {
            "location": "/features/application/#piping", 
            "text": "Because zend-expressive builds on  zend-stratigility ,\nand, more specifically, its  MiddlewarePipe  definition, you can also pipe\n(queue) middleware to the application. This is useful for adding middleware that\nshould execute on each request, defining error handlers, and/or segregating\napplications by subpath.  The signature of  pipe()  is:  public function pipe($pathOrMiddleware, $middleware = null)  where:   $pathOrMiddleware  is either a string URI path (for path segregation), a\n  callable middleware, or the service name for a middleware to fetch from the\n  composed container.  $middleware  is required if  $pathOrMiddleware  is a string URI path. It can\n  be one of:  a callable;  a service name that resolves to valid middleware in the container;  a fully qualified class name of a constructor-less class;  an array of any of the above; these will be composed in order into a\n     Zend\\Stratigility\\MiddlewarePipe  instance.   Unlike  Zend\\Stratigility\\MiddlewarePipe ,  Application::pipe()   allows\nfetching middleware by service name . This facility allows lazy-loading of\nmiddleware only when it is invoked. Internally, it wraps the call to fetch and\ndispatch the middleware inside a closure.  Additionally, we define a new method,  pipeErrorHandler() , with the following\nsignature:  public function pipeErrorHandler($pathOrMiddleware, $middleware = null)  It acts just like  pipe()  except when the middleware specified is a service\nname; in that particular case, when it wraps the middleware in a closure, it\nuses the error handler signature:  function ($error, ServerRequestInterface $request, ResponseInterface $response, callable $next);  Read the section on  piping vs routing  for more information.", 
            "title": "Piping"
        }, 
        {
            "location": "/features/application/#registering-routing-and-dispatch-middleware", 
            "text": "Routing is accomplished via a dedicated middleware method, Application::routeMiddleware() ; similarly, dispatching of routed middleware\nhas a corresponding instance middleware method,  Application::dispatchMiddleware() .\nEach can be piped/registered with other middleware platforms if desired.  These methods  MUST  be piped to the application so that the application will\nroute and dispatch routed middleware. This is done using the following methods:  $app- pipeRoutingMiddleware();\n$app- pipeDispatchMiddleware();  See the section on  piping  to see how you can register\nnon-routed middleware and create layered middleware applications.", 
            "title": "Registering routing and dispatch middleware"
        }, 
        {
            "location": "/features/application/#retrieving-dependencies", 
            "text": "As noted in the intro, the  Application  class has several dependencies. Some of\nthese may allow further configuration, or may be useful on their own, and have\nmethods for retrieving them. They include:   getContainer() : returns the composed  container-interop \n  instance (used to retrieve routed middleware).  getEmitter() : returns the composed\n   emitter ,\n  typically a  Zend\\Expressive\\Emitter\\EmitterStack  instance.  getFinalHandler(ResponseInterface $response = null) : retrieves the final\n  handler instance. This is middleware with the signature  function ($request,\n  $response, $error = null) , and it is invoked when the middleware pipeline\n  queue is depleted and no response has been returned.", 
            "title": "Retrieving dependencies"
        }, 
        {
            "location": "/features/application/#executing-the-application-run", 
            "text": "When the application is completely setup, you can execute it with the  run() \nmethod. The method may be called with no arguments, but has the following\nsignature:  public function run(\n    ServerRequestInterface $request = null,\n    ResponseInterface $response = null\n);", 
            "title": "Executing the application: run()"
        }, 
        {
            "location": "/features/container/intro/", 
            "text": "Containers\n\n\nExpressive promotes and advocates the usage of\n\nDependency Injection\n/\nInversion of Control\n\n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:\n\n\n\n\n\n\nDefining \napplication\n dependencies: routers, template engines, error\n  handlers, even the \nApplication\n instance itself.\n\n\n\n\n\n\nDefining \nmiddleware\n and related dependencies.\n\n\n\n\n\n\nThe \nApplication\n instance itself stores a container, from which it fetches\nmiddleware when ready to dispatch it; this encourages the idea of defining\nmiddleware-specific dependencies, and factories for ensuring they are injected.\n\n\nTo facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against \ncontainer-interop\n,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.\n\n\nAt this time, we document support for the following specific containers:\n\n\n\n\nzend-servicemanager\n\n\npimple-interop\n\n\naura.di\n\n\n\n\n\n\nService Names\n\n\nWe recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.\n\n\nFollowing these practices encourages the following:\n\n\n\n\nConsumers have a reasonable idea of what the service should return.\n\n\nUsing interface names as service names promotes re-use and substitution.\n\n\n\n\nIn a few cases, we define \"meta\" names. These are cases where there is no\nclear typehint to follow (e.g., most middleware only uses \ncallable\n as a\ntypehint, or where we want to imply specific configuration is necessary (e.g.,\n\nWhoops\n requires specific configuration to\nwork correctly with Expressive, and thus we do not want a generic service name\nfor it). We try to keep these to a minimum, however.", 
            "title": "Introduction"
        }, 
        {
            "location": "/features/container/intro/#containers", 
            "text": "Expressive promotes and advocates the usage of Dependency Injection / Inversion of Control \n(also referred to as DI \u2014 or DIC \u2014 and IoC, respectively)\ncontainers when writing your applications. These should be used for the\nfollowing:    Defining  application  dependencies: routers, template engines, error\n  handlers, even the  Application  instance itself.    Defining  middleware  and related dependencies.    The  Application  instance itself stores a container, from which it fetches\nmiddleware when ready to dispatch it; this encourages the idea of defining\nmiddleware-specific dependencies, and factories for ensuring they are injected.  To facilitate this and allow you as a developer to choose the container you\nprefer, zend-expressive typehints against  container-interop ,\nand throughout this manual, we attempt to show using a variety of containers in\nexamples.  At this time, we document support for the following specific containers:   zend-servicemanager  pimple-interop  aura.di", 
            "title": "Containers"
        }, 
        {
            "location": "/features/container/intro/#service-names", 
            "text": "We recommend using fully-qualified class names whenever possible as service\nnames, with one exception: in cases where a service provides an implementation\nof an interface used for typehints, use the interface name.  Following these practices encourages the following:   Consumers have a reasonable idea of what the service should return.  Using interface names as service names promotes re-use and substitution.   In a few cases, we define \"meta\" names. These are cases where there is no\nclear typehint to follow (e.g., most middleware only uses  callable  as a\ntypehint, or where we want to imply specific configuration is necessary (e.g., Whoops  requires specific configuration to\nwork correctly with Expressive, and thus we do not want a generic service name\nfor it). We try to keep these to a minimum, however.", 
            "title": "Service Names"
        }, 
        {
            "location": "/features/container/factories/", 
            "text": "Provided Factories\n\n\nExpressive provides several factories compatible with container-interop to\nfacilitate setting up common dependencies. The following is a list of provided\ncontainers, what they will create, the suggested service name, and any\nadditional dependencies they may require.\n\n\nAll factories, unless noted otherwise, are in the \nZend\\Expressive\\Container\n\nnamespace, and define an \n__invoke()\n method that accepts an\n\nInterop\\Container\\ContainerInterface\n instance as the sole argument.\n\n\nApplicationFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Application\n\n\nSuggested Name\n: \nZend\\Expressive\\Application\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n. When provided, the service will\n  be used to construct the \nApplication\n instance; otherwise, an FastRoute router\n  implementation will be used.\n\n\nZend\\Expressive\\FinalHandler\n. This is a meta-service, as the only concrete\n  type required is a callable that can be used as a final middleware in the\n  case that the stack is exhausted before execution ends. By default, an\n  instance of \nZend\\Stratigility\\FinalHandler\n will be used.\n\n\nZend\\Diactoros\\Response\\EmitterInterface\n. If none is provided, an instance\n  of \nZend\\Expressive\\Emitter\\EmitterStack\n composing a\n  \nZend\\Diactoros\\Response\\SapiEmitter\n instance will be used.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  application instance with pre/post pipeline middleware and/or routed\n  middleware (see more below).\n\n\n\n\n\n\n\n\nAdditionally, the container instance itself is injected into the \nApplication\n\ninstance.\n\n\nWhen the \nconfig\n service is present, the factory can utilize several keys in\norder to seed the \nApplication\n instance:\n\n\n\n\nmiddleware_pipeline\n can be used to seed the middleware pipeline:\n\n\n\n\n'middleware_pipeline' =\n [\n    // An array of middleware to register.\n    [ /* ... */ ],\n    Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n    [ /* ... */ ],\n],\n\n\n\n\nEach item of the array, other than the entries for routing and dispatch\n  middleware, must be an array itself, with the following structure:\n\n\n[\n    // required:\n    'middleware' =\n 'Name of middleware service, or a callable',\n    // optional:\n    'path'  =\n '/path/to/match',\n    'error' =\n true,\n    'priority' =\n 1, // Integer\n],\n\n\n\n\nThe \nmiddleware\n key itself is the middleware to execute, and must be a\n  callable or the name of another defined service. If the \npath\n key is present,\n  that key will be used to segregate the middleware to a specific matched path\n  (in other words, it will not execute if the path is not matched). If the\n  \nerror\n key is present and boolean \ntrue\n, then the middleware will be\n  registered as error middleware. (This is necessary due to the fact that the\n  factory defines a callable wrapper around middleware to enable lazy-loading of\n  middleware.) The \npriority\n defaults to 1, and follows the semantics of\n  \nSplPriorityQueue\n: higher integer values\n  indicate higher priority (will execute earlier), while lower/negative integer\n  values indicate lower priority (will execute last). Default priority is 1; use\n  granular priority values to specify the order in which middleware should be\n  piped to the application.\n\n\nYou \ncan\n specify keys for each middleware specification. These will be\n  ignored by the factory, but can be useful when merging several configurations\n  into one for the application.\n\n\n\n\nroutes\n is used to define routed middleware. The value must be an array,\n  consisting of arrays defining each middleware:\n\n\n\n\n'routes' =\n [\n    [\n        'path' =\n '/path/to/match',\n        'middleware' =\n 'Middleware Service Name or Callable',\n        'allowed_methods' =\n [ 'GET', 'POST', 'PATCH' ],\n        'options' =\n [\n            'stuff' =\n 'to',\n            'pass'  =\n 'to',\n            'the'   =\n 'underlying router',\n        ],\n    ],\n    // etc.\n],\n\n\n\n\nEach route \nrequires\n:\n\n\n- `path`: the path to match. Format will be based on the router you choose for\n  your project.\n\n- `middleware`: a callable or a service name for the middleware to execute\n  when the route matches.\n\n\n\n\nOptionally, the route definition may provide:\n\n\n- `allowed_methods`: an array of allowed HTTP methods. If not provided, the\n  application assumes any method is allowed.\n\n- `name`: if not provided, the path will be used as the route name (and, if\n  specific HTTP methods are allowed, a list of those).\n\n- `options`: a key/value set of additional options to pass to the underlying\n  router implementation for the given route. (Typical use cases include\n  passing constraints or default values.)\n\n\n\n\nTemplatedErrorHandlerFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\TemplatedErrorHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\FinalHandler\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the error\n  handler will not use templated responses.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  \nTemplatedErrorHandler\n instance with template names to use for errors (see\n  more below).\n\n\n\n\n\n\n\n\nWhen the \nconfig\n service is present, the factory can utilize the\n\nzend-expressive\n top-level key, with the \nerror_handler\n second-level key, to\nseed the \nTemplated\n instance:\n\n\n'zend-expressive' =\n [\n    'error_handler' =\n [\n        'template_404'   =\n 'name of 404 template',\n        'template_error' =\n 'name of error template',\n    ],\n],\n\n\n\n\nWhoopsErrorHandlerFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\TemplatedErrorHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\FinalHandler\n\n\nRequires\n:\n\n\nZend\\Expressive\\Whoops\n, which should provide a \nWhoops\\Run\n instance.\n\n\nZend\\Expressive\\WhoopsPageHandler\n, which should provide a\n  \nWhoops\\Handler\\PrettyPageHandler\n instance.\n\n\n\n\n\n\nOptional\n:\n\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n. If not provided, the error\n  handler will not use templated responses.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed the\n  instance with template names to use for errors (see more below).\n\n\n\n\n\n\n\n\nThis factory uses \nconfig\n in the same way as the\n\nTemplatedErrorHandlerFactory\n.\n\n\nWhoopsFactory\n\n\n\n\nProvides\n: \nWhoops\\Run\n\n\nSuggested Name\n: \nZend\\Expressive\\Whoops\n\n\nRequires\n:\n\n\nZend\\Expressive\\WhoopsPageHandler\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to seed\n  additional page handlers, specifically the \nJsonResponseHandler\n (see\n  more below).\n\n\n\n\n\n\n\n\nThis factory creates and configures a \nWhoops\\Run\n instance so that it will work\nproperly with \nZend\\Expressive\\Application\n; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The \nPrettyPageHandler\n returned\nfor the \nZend\\Expressive\\WhoopsPageHandler\n service will be injected.\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' =\n [\n    'json_exceptions' =\n [\n        'display'    =\n true,\n        'show_trace' =\n true,\n        'ajax_only'  =\n true,\n    ],\n],\n\n\n\n\nIf no \nwhoops\n top-level key is present in the configuration, a default instance\nwith no \nJsonResponseHandler\n composed will be created.\n\n\nWhoopsPageHandlerFactory\n\n\n\n\nProvides\n: \nWhoops\\Handler\\PrettyPageHandler\n\n\nSuggested Name\n: \nZend\\Expressive\\WhoopsPageHandler\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPrettyPageHandler\n instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'whoops' =\n [\n    'editor' =\n 'editor name, editor service name, or callable',\n],\n\n\n\n\nThe \neditor\n value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.\n\n\nPlatesRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\PlatesRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Plates\\PlatesRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nPlates\n instance, specifically with the filename extension\n  to use, and paths to inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' =\n [\n    'extension' =\n 'file extension used by templates; defaults to html',\n    'paths' =\n [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\n\nOne note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.\n\n\nTwigRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\TwigRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\Twig\\TwigRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nOptional\n:\n\n\nZend\\Expressive\\Router\\RouterInterface\n; if found, it will be used to\n  seed a \nZend\\Expressive\\Twig\\TwigExtension\n instance for purposes\n  of rendering application URLs.\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nTwig\n instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'debug' =\n boolean,\n'templates' =\n [\n    'cache_dir' =\n 'path to cached templates',\n    'assets_url' =\n 'base URL for assets',\n    'assets_version' =\n 'base version for assets',\n    'extension' =\n 'file extension used by templates; defaults to html.twig',\n    'paths' =\n [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\n\nWhen \ndebug\n is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The \nassets_*\n values are used to seed\nthe \nTwigExtension\n instance (assuming the router was found).\n\n\nZendViewRendererFactory\n\n\n\n\nProvides\n: \nZend\\Expressive\\Template\\ZendViewRenderer\n\n\nFactoryName\n: \nZend\\Expressive\\ZendView\\ZendViewRendererFactory\n\n\nSuggested Name\n: \nZend\\Expressive\\Template\\TemplateRendererInterface\n\n\nRequires\n: no additional services are required.\n\n\nZend\\Expressive\\Router\\RouterInterface\n, in order to inject the custom\n  url helper implementation.\n\n\n\n\n\n\nOptional\n:\n\n\nconfig\n, an array or \nArrayAccess\n instance. This will be used to further\n  configure the \nZendView\n instance, specifically with the layout template\n  name, entries for a \nTemplateMapResolver\n, and and template paths to\n  inject.\n\n\nZend\\View\\HelperPluginManager\n; if present, will be used to inject the\n  \nPhpRenderer\n instance.\n\n\n\n\n\n\n\n\nIt consumes the following \nconfig\n structure:\n\n\n'templates' =\n [\n    'layout' =\n 'name of layout view to use, if any',\n    'map'    =\n [\n        // template =\n filename pairs\n    ],\n    'paths'  =\n [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]\n\n\n\n\nWhen creating the \nPhpRenderer\n instance, it will inject it with a\n\nZend\\View\\HelperPluginManager\n instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers, \nZend\\Expressive\\ZendView\\UrlHelper\n and\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n, respetively.", 
            "title": "Container Factories"
        }, 
        {
            "location": "/features/container/factories/#provided-factories", 
            "text": "Expressive provides several factories compatible with container-interop to\nfacilitate setting up common dependencies. The following is a list of provided\ncontainers, what they will create, the suggested service name, and any\nadditional dependencies they may require.  All factories, unless noted otherwise, are in the  Zend\\Expressive\\Container \nnamespace, and define an  __invoke()  method that accepts an Interop\\Container\\ContainerInterface  instance as the sole argument.", 
            "title": "Provided Factories"
        }, 
        {
            "location": "/features/container/factories/#applicationfactory", 
            "text": "Provides :  Zend\\Expressive\\Application  Suggested Name :  Zend\\Expressive\\Application  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Router\\RouterInterface . When provided, the service will\n  be used to construct the  Application  instance; otherwise, an FastRoute router\n  implementation will be used.  Zend\\Expressive\\FinalHandler . This is a meta-service, as the only concrete\n  type required is a callable that can be used as a final middleware in the\n  case that the stack is exhausted before execution ends. By default, an\n  instance of  Zend\\Stratigility\\FinalHandler  will be used.  Zend\\Diactoros\\Response\\EmitterInterface . If none is provided, an instance\n  of  Zend\\Expressive\\Emitter\\EmitterStack  composing a\n   Zend\\Diactoros\\Response\\SapiEmitter  instance will be used.  config , an array or  ArrayAccess  instance. This will be used to seed the\n  application instance with pre/post pipeline middleware and/or routed\n  middleware (see more below).     Additionally, the container instance itself is injected into the  Application \ninstance.  When the  config  service is present, the factory can utilize several keys in\norder to seed the  Application  instance:   middleware_pipeline  can be used to seed the middleware pipeline:   'middleware_pipeline' =  [\n    // An array of middleware to register.\n    [ /* ... */ ],\n    Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n    Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n    [ /* ... */ ],\n],  Each item of the array, other than the entries for routing and dispatch\n  middleware, must be an array itself, with the following structure:  [\n    // required:\n    'middleware' =  'Name of middleware service, or a callable',\n    // optional:\n    'path'  =  '/path/to/match',\n    'error' =  true,\n    'priority' =  1, // Integer\n],  The  middleware  key itself is the middleware to execute, and must be a\n  callable or the name of another defined service. If the  path  key is present,\n  that key will be used to segregate the middleware to a specific matched path\n  (in other words, it will not execute if the path is not matched). If the\n   error  key is present and boolean  true , then the middleware will be\n  registered as error middleware. (This is necessary due to the fact that the\n  factory defines a callable wrapper around middleware to enable lazy-loading of\n  middleware.) The  priority  defaults to 1, and follows the semantics of\n   SplPriorityQueue : higher integer values\n  indicate higher priority (will execute earlier), while lower/negative integer\n  values indicate lower priority (will execute last). Default priority is 1; use\n  granular priority values to specify the order in which middleware should be\n  piped to the application.  You  can  specify keys for each middleware specification. These will be\n  ignored by the factory, but can be useful when merging several configurations\n  into one for the application.   routes  is used to define routed middleware. The value must be an array,\n  consisting of arrays defining each middleware:   'routes' =  [\n    [\n        'path' =  '/path/to/match',\n        'middleware' =  'Middleware Service Name or Callable',\n        'allowed_methods' =  [ 'GET', 'POST', 'PATCH' ],\n        'options' =  [\n            'stuff' =  'to',\n            'pass'  =  'to',\n            'the'   =  'underlying router',\n        ],\n    ],\n    // etc.\n],  Each route  requires :  - `path`: the path to match. Format will be based on the router you choose for\n  your project.\n\n- `middleware`: a callable or a service name for the middleware to execute\n  when the route matches.  Optionally, the route definition may provide:  - `allowed_methods`: an array of allowed HTTP methods. If not provided, the\n  application assumes any method is allowed.\n\n- `name`: if not provided, the path will be used as the route name (and, if\n  specific HTTP methods are allowed, a list of those).\n\n- `options`: a key/value set of additional options to pass to the underlying\n  router implementation for the given route. (Typical use cases include\n  passing constraints or default values.)", 
            "title": "ApplicationFactory"
        }, 
        {
            "location": "/features/container/factories/#templatederrorhandlerfactory", 
            "text": "Provides :  Zend\\Expressive\\TemplatedErrorHandler  Suggested Name :  Zend\\Expressive\\FinalHandler  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error\n  handler will not use templated responses.  config , an array or  ArrayAccess  instance. This will be used to seed the\n   TemplatedErrorHandler  instance with template names to use for errors (see\n  more below).     When the  config  service is present, the factory can utilize the zend-expressive  top-level key, with the  error_handler  second-level key, to\nseed the  Templated  instance:  'zend-expressive' =  [\n    'error_handler' =  [\n        'template_404'   =  'name of 404 template',\n        'template_error' =  'name of error template',\n    ],\n],", 
            "title": "TemplatedErrorHandlerFactory"
        }, 
        {
            "location": "/features/container/factories/#whoopserrorhandlerfactory", 
            "text": "Provides :  Zend\\Expressive\\TemplatedErrorHandler  Suggested Name :  Zend\\Expressive\\FinalHandler  Requires :  Zend\\Expressive\\Whoops , which should provide a  Whoops\\Run  instance.  Zend\\Expressive\\WhoopsPageHandler , which should provide a\n   Whoops\\Handler\\PrettyPageHandler  instance.    Optional :  Zend\\Expressive\\Template\\TemplateRendererInterface . If not provided, the error\n  handler will not use templated responses.  config , an array or  ArrayAccess  instance. This will be used to seed the\n  instance with template names to use for errors (see more below).     This factory uses  config  in the same way as the TemplatedErrorHandlerFactory .", 
            "title": "WhoopsErrorHandlerFactory"
        }, 
        {
            "location": "/features/container/factories/#whoopsfactory", 
            "text": "Provides :  Whoops\\Run  Suggested Name :  Zend\\Expressive\\Whoops  Requires :  Zend\\Expressive\\WhoopsPageHandler    Optional :  config , an array or  ArrayAccess  instance. This will be used to seed\n  additional page handlers, specifically the  JsonResponseHandler  (see\n  more below).     This factory creates and configures a  Whoops\\Run  instance so that it will work\nproperly with  Zend\\Expressive\\Application ; this includes disabling immediate\nwrite-to-output, disabling immediate quit, etc. The  PrettyPageHandler  returned\nfor the  Zend\\Expressive\\WhoopsPageHandler  service will be injected.  It consumes the following  config  structure:  'whoops' =  [\n    'json_exceptions' =  [\n        'display'    =  true,\n        'show_trace' =  true,\n        'ajax_only'  =  true,\n    ],\n],  If no  whoops  top-level key is present in the configuration, a default instance\nwith no  JsonResponseHandler  composed will be created.", 
            "title": "WhoopsFactory"
        }, 
        {
            "location": "/features/container/factories/#whoopspagehandlerfactory", 
            "text": "Provides :  Whoops\\Handler\\PrettyPageHandler  Suggested Name :  Zend\\Expressive\\WhoopsPageHandler  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  PrettyPageHandler  instance, specifically with editor\n  configuration (for linking files such that they open in the configured\n  editor).     It consumes the following  config  structure:  'whoops' =  [\n    'editor' =  'editor name, editor service name, or callable',\n],  The  editor  value must be a known editor name (see the Whoops documentation for\npre-configured editor types), a callable, or a service name to use.", 
            "title": "WhoopsPageHandlerFactory"
        }, 
        {
            "location": "/features/container/factories/#platesrendererfactory", 
            "text": "Provides :  Zend\\Expressive\\Template\\PlatesRenderer  FactoryName :  Zend\\Expressive\\Plates\\PlatesRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Plates  instance, specifically with the filename extension\n  to use, and paths to inject.     It consumes the following  config  structure:  'templates' =  [\n    'extension' =  'file extension used by templates; defaults to html',\n    'paths' =  [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  One note: Due to a limitation in the Plates engine, you can only map one path\nper namespace when using Plates.", 
            "title": "PlatesRendererFactory"
        }, 
        {
            "location": "/features/container/factories/#twigrendererfactory", 
            "text": "Provides :  Zend\\Expressive\\Template\\TwigRenderer  FactoryName :  Zend\\Expressive\\Twig\\TwigRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Optional :  Zend\\Expressive\\Router\\RouterInterface ; if found, it will be used to\n  seed a  Zend\\Expressive\\Twig\\TwigExtension  instance for purposes\n  of rendering application URLs.  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  Twig  instance, specifically with the filename extension,\n  paths to assets (and default asset version to use), and template paths to\n  inject.     It consumes the following  config  structure:  'debug' =  boolean,\n'templates' =  [\n    'cache_dir' =  'path to cached templates',\n    'assets_url' =  'base URL for assets',\n    'assets_version' =  'base version for assets',\n    'extension' =  'file extension used by templates; defaults to html.twig',\n    'paths' =  [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When  debug  is true, it disables caching, enables debug mode, enables strict\nvariables, and enables auto reloading. The  assets_*  values are used to seed\nthe  TwigExtension  instance (assuming the router was found).", 
            "title": "TwigRendererFactory"
        }, 
        {
            "location": "/features/container/factories/#zendviewrendererfactory", 
            "text": "Provides :  Zend\\Expressive\\Template\\ZendViewRenderer  FactoryName :  Zend\\Expressive\\ZendView\\ZendViewRendererFactory  Suggested Name :  Zend\\Expressive\\Template\\TemplateRendererInterface  Requires : no additional services are required.  Zend\\Expressive\\Router\\RouterInterface , in order to inject the custom\n  url helper implementation.    Optional :  config , an array or  ArrayAccess  instance. This will be used to further\n  configure the  ZendView  instance, specifically with the layout template\n  name, entries for a  TemplateMapResolver , and and template paths to\n  inject.  Zend\\View\\HelperPluginManager ; if present, will be used to inject the\n   PhpRenderer  instance.     It consumes the following  config  structure:  'templates' =  [\n    'layout' =  'name of layout view to use, if any',\n    'map'    =  [\n        // template =  filename pairs\n    ],\n    'paths'  =  [\n        // namespace / path pairs\n        //\n        // Numeric namespaces imply the default/main namespace. Paths may be\n        // strings or arrays of string paths to associate with the namespace.\n    ],\n]  When creating the  PhpRenderer  instance, it will inject it with a Zend\\View\\HelperPluginManager  instance (either pulled from the container, or\ninstantiated directly). It injects the helper plugin manager with custom url and\nserverurl helpers,  Zend\\Expressive\\ZendView\\UrlHelper  and Zend\\Expressive\\ZendView\\ServerUrlHelper , respetively.", 
            "title": "ZendViewRendererFactory"
        }, 
        {
            "location": "/features/container/zend-servicemanager/", 
            "text": "Using zend-servicemanager\n\n\nzend-servicemanager\n is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:\n\n\n\n\nlazy-loading of invokable (constructor-less) classes.\n\n\nability to define factories for specific classes.\n\n\nability to define generalized factories for classes with identical\n  construction patterns (aka \nabstract factories\n).\n\n\nability to create lazy-loading proxies.\n\n\nability to intercept before or after instantiation to alter the construction\n  workflow (aka \ndelegator factories\n).\n\n\ninterface injection (via \ninitializers\n).\n\n\n\n\nzend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:\n\n\n[\n    'services' =\n [\n        'service name' =\n $serviceInstance,\n    ],\n    'invokables' =\n [\n        'service name' =\n 'class to instantiate',\n    ],\n    'factories' =\n [\n        'service name' =\n 'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' =\n [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' =\n [\n        'service name' =\n [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' =\n [\n        'class_map' =\n [\n            'service name' =\n 'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' =\n [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]\n\n\n\n\nRead more about zend-servicemanager in \nits documentation\n.\n\n\nInstalling zend-servicemanager\n\n\nTo use zend-servicemanager with zend-expressive, you can install it via\ncomposer:\n\n\n$ composer require zendframework/zend-servicemanager\n\n\n\n\nConfiguring zend-servicemanager\n\n\nYou can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.\n\n\nProgrammatically\n\n\nTo use zend-servicemanager programatically, you'll need to create a\n\nZend\\ServiceManager\\ServiceManager\n instance, and then start populating it.\n\n\nFor this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in \nconfig/config.php\n, and that that file\nreturns an array.\n\n\nWe'll create a \nconfig/services.php\n file that creates and returns a\n\nZend\\ServiceManager\\ServiceManager\n instance as follows:\n\n\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container-\nsetService('config', include 'config/config.php');\n$container-\nsetFactory(\n    'Zend\\Expressive\\Application',\n    'Zend\\Expressive\\Container\\ApplicationFactory'\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container-\nsetInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\AuraRouter'\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container-\nsetInvokableClass(\n    'Zend\\Expressive\\Template\\TemplateRendererInterface',\n    'Zend\\Expressive\\Plates\\PlatesRenderer'\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation:\n$container-\nsetFactory(\n    'Zend\\Expressive\\Whoops',\n    'Zend\\Expressive\\Container\\WhoopsFactory'\n);\n$container-\nsetFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory'\n);\n\n// Error Handling\n// If in development:\n$container-\nsetFactory(\n    'Zend\\Expressive\\FinalHandler',\n    'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory'\n);\n\n// If in production:\n$container-\nsetFactory(\n    'Zend\\Expressive\\FinalHandler',\n    'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory'\n);\n\nreturn $container;\n\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/services.php';\n$app = $container-\nget('Zend\\Expressive\\Application');\n$app-\nrun();\n\n\n\n\nConfiguration-Driven Container\n\n\nAlternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in \nconfig/config.php\n, and our\n\nconfig/services.php\n file will still return our service manager instance; we'll\ndefine the service configuration in \nconfig/dependencies.php\n:\n\n\nreturn [\n    'services' =\n [\n        'config' =\n include __DIR__ . '/config.php',\n    ],\n    'invokables' =\n [\n        'Zend\\Expressive\\Router\\RouterInterface'     =\n 'Zend\\Expressive\\Router\\AuraRouter',\n        'Zend\\Expressive\\Template\\TemplateRendererInterface' =\n 'Zend\\Expressive\\Plates\\PlatesRenderer'\n    ],\n    'factories' =\n [\n        'Zend\\Expressive\\Application'       =\n 'Zend\\Expressive\\Container\\ApplicationFactory',\n        'Zend\\Expressive\\Whoops'            =\n 'Zend\\Expressive\\Container\\WhoopsFactory',\n        'Zend\\Expressive\\WhoopsPageHandler' =\n 'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory',\n    ],\n];\n\n\n\n\nconfig/services.php\n becomes:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));\n\n\n\n\nThere is one problem, however: which final handler should you configure? You\nhave two choices on how to approach this:\n\n\n\n\nSelectively inject the factory in the bootstrap.\n\n\nDefine the final handler service in an environment specific file and use file\n  globbing to merge files.\n\n\n\n\nIn the first case, you would change the \nconfig/services.php\n example to look\nlike this:\n\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/services.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        $container-\nsetFactory(\n            'Zend\\Expressive\\FinalHandler',\n            'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory'\n        );\n        break;\n    case 'production':\n    default:\n        $container-\nsetFactory(\n            'Zend\\Expressive\\FinalHandler',\n            'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory'\n        );\n}\nreturn $container;\n\n\n\n\nIn the second case, you will need to install zend-config:\n\n\n$ composer require zendframework/zend-config\n\n\n\n\nThen, create the directory \nconfig/autoload/\n, and create two files,\n\ndependencies.global.php\n and \ndependencies.local.php\n. In your \n.gitignore\n,\nadd an entry for \nconfig/autoload/*local.php\n to ensure \"local\"\n(environment-specific) files are excluded from the repository.\n\n\nconfig/dependencies.php\n will look like this:\n\n\nuse Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);\n\n\n\n\nconfig/autoload/dependencies.global.php\n will look like this:\n\n\nreturn [\n    'services' =\n [\n        'config' =\n include __DIR__ . '/config.php',\n    ],\n    'invokables' =\n [\n        'Zend\\Expressive\\Router\\RouterInterface'     =\n 'Zend\\Expressive\\Router\\AuraRouter',\n        'Zend\\Expressive\\Template\\TemplateRendererInterface' =\n 'Zend\\Expressive\\Plates\\PlatesRenderer'\n    ],\n    'factories' =\n [\n        'Zend\\Expressive\\Application'       =\n 'Zend\\Expressive\\Container\\ApplicationFactory',\n        'Zend\\Expressive\\FinalHandler'      =\n 'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory',\n    ],\n];\n\n\n\n\nconfig/autoload/dependencies.local.php\n on your development machine can look\nlike this:\n\n\nreturn [\n    'factories' =\n [\n        'Zend\\Expressive\\FinalHandler'      =\n 'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory',\n        'Zend\\Expressive\\Whoops'            =\n 'Zend\\Expressive\\Container\\WhoopsFactory',\n        'Zend\\Expressive\\WhoopsPageHandler' =\n 'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory',\n    ],\n];\n\n\n\n\nUsing the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)", 
            "title": "Using zend-servicemanager"
        }, 
        {
            "location": "/features/container/zend-servicemanager/#using-zend-servicemanager", 
            "text": "zend-servicemanager  is a\ncode-driven dependency injection container provided as a standalone component by\nZend Framework. It features:   lazy-loading of invokable (constructor-less) classes.  ability to define factories for specific classes.  ability to define generalized factories for classes with identical\n  construction patterns (aka  abstract factories ).  ability to create lazy-loading proxies.  ability to intercept before or after instantiation to alter the construction\n  workflow (aka  delegator factories ).  interface injection (via  initializers ).   zend-servicemanager may either be created and populated programmatically, or via\nconfiguration. Configuration uses the following structure:  [\n    'services' =  [\n        'service name' =  $serviceInstance,\n    ],\n    'invokables' =  [\n        'service name' =  'class to instantiate',\n    ],\n    'factories' =  [\n        'service name' =  'callable, Zend\\ServiceManager\\FactoryInterface instance, or name of factory class returning the service',\n    ],\n    'abstract_factories' =  [\n        'class name of Zend\\ServiceManager\\AbstractFactoryInterface implementation',\n    ],\n    'delegators' =  [\n        'service name' =  [\n            'class name of Zend\\ServiceManager\\DelegatorFactoryInterface implementation',\n        ],\n    ],\n    'lazy_services' =  [\n        'class_map' =  [\n            'service name' =  'Class\\Name\\Of\\Service',\n        ],\n    ],\n    'initializers' =  [\n        'callable, Zend\\ServiceManager\\InitializerInterface implementation, or name of initializer class',\n    ],\n]  Read more about zend-servicemanager in  its documentation .", 
            "title": "Using zend-servicemanager"
        }, 
        {
            "location": "/features/container/zend-servicemanager/#installing-zend-servicemanager", 
            "text": "To use zend-servicemanager with zend-expressive, you can install it via\ncomposer:  $ composer require zendframework/zend-servicemanager", 
            "title": "Installing zend-servicemanager"
        }, 
        {
            "location": "/features/container/zend-servicemanager/#configuring-zend-servicemanager", 
            "text": "You can configure zend-servicemanager either programmatically or via\nconfiguration. We'll show you both methods.", 
            "title": "Configuring zend-servicemanager"
        }, 
        {
            "location": "/features/container/zend-servicemanager/#programmatically", 
            "text": "To use zend-servicemanager programatically, you'll need to create a Zend\\ServiceManager\\ServiceManager  instance, and then start populating it.  For this example, we'll assume your application configuration (used by several\nfactories to configure instances) is in  config/config.php , and that that file\nreturns an array.  We'll create a  config/services.php  file that creates and returns a Zend\\ServiceManager\\ServiceManager  instance as follows:  use Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n\n// Application and configuration\n$container- setService('config', include 'config/config.php');\n$container- setFactory(\n    'Zend\\Expressive\\Application',\n    'Zend\\Expressive\\Container\\ApplicationFactory'\n);\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container- setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\AuraRouter'\n);\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container- setInvokableClass(\n    'Zend\\Expressive\\Template\\TemplateRendererInterface',\n    'Zend\\Expressive\\Plates\\PlatesRenderer'\n);\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation:\n$container- setFactory(\n    'Zend\\Expressive\\Whoops',\n    'Zend\\Expressive\\Container\\WhoopsFactory'\n);\n$container- setFactory(\n    'Zend\\Expressive\\WhoopsPageHandler',\n    'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory'\n);\n\n// Error Handling\n// If in development:\n$container- setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory'\n);\n\n// If in production:\n$container- setFactory(\n    'Zend\\Expressive\\FinalHandler',\n    'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory'\n);\n\nreturn $container;  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/services.php';\n$app = $container- get('Zend\\Expressive\\Application');\n$app- run();", 
            "title": "Programmatically"
        }, 
        {
            "location": "/features/container/zend-servicemanager/#configuration-driven-container", 
            "text": "Alternately, you can use a configuration file to define the container. As\nbefore, we'll define our configuration in  config/config.php , and our config/services.php  file will still return our service manager instance; we'll\ndefine the service configuration in  config/dependencies.php :  return [\n    'services' =  [\n        'config' =  include __DIR__ . '/config.php',\n    ],\n    'invokables' =  [\n        'Zend\\Expressive\\Router\\RouterInterface'     =  'Zend\\Expressive\\Router\\AuraRouter',\n        'Zend\\Expressive\\Template\\TemplateRendererInterface' =  'Zend\\Expressive\\Plates\\PlatesRenderer'\n    ],\n    'factories' =  [\n        'Zend\\Expressive\\Application'       =  'Zend\\Expressive\\Container\\ApplicationFactory',\n        'Zend\\Expressive\\Whoops'            =  'Zend\\Expressive\\Container\\WhoopsFactory',\n        'Zend\\Expressive\\WhoopsPageHandler' =  'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory',\n    ],\n];  config/services.php  becomes:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\nreturn new ServiceManager(new Config(include 'config/dependencies.php'));  There is one problem, however: which final handler should you configure? You\nhave two choices on how to approach this:   Selectively inject the factory in the bootstrap.  Define the final handler service in an environment specific file and use file\n  globbing to merge files.   In the first case, you would change the  config/services.php  example to look\nlike this:  use Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager(new Config(include 'config/services.php'));\nswitch ($variableOrConstantIndicatingEnvironment) {\n    case 'development':\n        $container- setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory'\n        );\n        break;\n    case 'production':\n    default:\n        $container- setFactory(\n            'Zend\\Expressive\\FinalHandler',\n            'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory'\n        );\n}\nreturn $container;  In the second case, you will need to install zend-config:  $ composer require zendframework/zend-config  Then, create the directory  config/autoload/ , and create two files, dependencies.global.php  and  dependencies.local.php . In your  .gitignore ,\nadd an entry for  config/autoload/*local.php  to ensure \"local\"\n(environment-specific) files are excluded from the repository.  config/dependencies.php  will look like this:  use Zend\\Config\\Factory as ConfigFactory;\n\nreturn ConfigFactory::fromFiles(\n    glob('config/autoload/dependencies.{global,local}.php', GLOB_BRACE)\n);  config/autoload/dependencies.global.php  will look like this:  return [\n    'services' =  [\n        'config' =  include __DIR__ . '/config.php',\n    ],\n    'invokables' =  [\n        'Zend\\Expressive\\Router\\RouterInterface'     =  'Zend\\Expressive\\Router\\AuraRouter',\n        'Zend\\Expressive\\Template\\TemplateRendererInterface' =  'Zend\\Expressive\\Plates\\PlatesRenderer'\n    ],\n    'factories' =  [\n        'Zend\\Expressive\\Application'       =  'Zend\\Expressive\\Container\\ApplicationFactory',\n        'Zend\\Expressive\\FinalHandler'      =  'Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory',\n    ],\n];  config/autoload/dependencies.local.php  on your development machine can look\nlike this:  return [\n    'factories' =  [\n        'Zend\\Expressive\\FinalHandler'      =  'Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory',\n        'Zend\\Expressive\\Whoops'            =  'Zend\\Expressive\\Container\\WhoopsFactory',\n        'Zend\\Expressive\\WhoopsPageHandler' =  'Zend\\Expressive\\Container\\WhoopsPageHandlerFactory',\n    ],\n];  Using the above approach allows you to keep the bootstrap file minimal and\nagnostic of environment. (Note: you can take a similar approach with\nthe application configuration.)", 
            "title": "Configuration-Driven Container"
        }, 
        {
            "location": "/features/container/pimple/", 
            "text": "Using Pimple\n\n\nPimple\n is a widely used code-driven dependency\ninjection container provided as a standalone component by SensioLabs. It\nfeatures:\n\n\n\n\ncombined parameter and service storage.\n\n\nability to define factories for specific classes.\n\n\nlazy-loading via factories.\n\n\n\n\nPimple only supports programmatic creation at this time.\n\n\nInstalling Pimple\n\n\nPimple does not currently (as of v3) implement\n\ncontainer-interop\n; as\nsuch, you need to install the \nxtreamwayz/pimple-container-interop\n project,\nwhich provides a container-interop wrapper around Pimple v3:\n\n\n$ composer require xtreamwayz/pimple-container-interop\n\n\n\n\nConfiguring Pimple\n\n\nTo configure Pimple, instantiate it, and then add the factories desired. We\nrecommend doing this in a dedicated script that returns the Pimple instance; in\nthis example, we'll have that in \nconfig/services.php\n.\n\n\nuse Xtreamwayz\\Pimple\\Container as Pimple;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\n$container = new Pimple();\n\n// Application and configuration\n$container['config'] = include 'config/config.php';\n$container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory;\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) {\n    return new Router\\Aura();\n};\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container[TemplateRendererInterface::class] = function ($container) {\n    return new PlatesRenderer();\n};\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation:\n$container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory();\n$container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory();\n\n// Error Handling\n// If in development:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\WhoopsErrorHandlerFactory();\n\n// If in production:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\TemplatedErrorHandlerFactory();\n\nreturn $container;\n\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\n$container = require 'config/services.php';\n$app = $container-\nget('Zend\\Expressive\\Application');\n$app-\nrun();\n\n\n\n\n\n\nEnvironments\n\n\nIn the example above, we provide two alternate definitions for the service\n\nZend\\Expressive\\FinalHandler\n, one for development and one for production.\nYou will need to add logic to your file to determine which definition to\nprovide; this could be accomplished via an environment variable.", 
            "title": "Using Pimple"
        }, 
        {
            "location": "/features/container/pimple/#using-pimple", 
            "text": "Pimple  is a widely used code-driven dependency\ninjection container provided as a standalone component by SensioLabs. It\nfeatures:   combined parameter and service storage.  ability to define factories for specific classes.  lazy-loading via factories.   Pimple only supports programmatic creation at this time.", 
            "title": "Using Pimple"
        }, 
        {
            "location": "/features/container/pimple/#installing-pimple", 
            "text": "Pimple does not currently (as of v3) implement container-interop ; as\nsuch, you need to install the  xtreamwayz/pimple-container-interop  project,\nwhich provides a container-interop wrapper around Pimple v3:  $ composer require xtreamwayz/pimple-container-interop", 
            "title": "Installing Pimple"
        }, 
        {
            "location": "/features/container/pimple/#configuring-pimple", 
            "text": "To configure Pimple, instantiate it, and then add the factories desired. We\nrecommend doing this in a dedicated script that returns the Pimple instance; in\nthis example, we'll have that in  config/services.php .  use Xtreamwayz\\Pimple\\Container as Pimple;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\n$container = new Pimple();\n\n// Application and configuration\n$container['config'] = include 'config/config.php';\n$container['Zend\\Expressive\\Application'] = new Container\\ApplicationFactory;\n\n// Routing\n// In most cases, you can instantiate the router you want to use without using a\n// factory:\n$container['Zend\\Expressive\\Router\\RouterInterface'] = function ($container) {\n    return new Router\\Aura();\n};\n\n// Templating\n// In most cases, you can instantiate the template renderer you want to use\n// without using a factory:\n$container[TemplateRendererInterface::class] = function ($container) {\n    return new PlatesRenderer();\n};\n\n// These next two can be added in any environment; they won't be used unless\n// you add the WhoopsErrorHandler as the FinalHandler implementation:\n$container['Zend\\Expressive\\Whoops'] = new Container\\WhoopsFactory();\n$container['Zend\\Expressive\\WhoopsPageHandler'] = new Container\\WhoopsPageHandlerFactory();\n\n// Error Handling\n// If in development:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\WhoopsErrorHandlerFactory();\n\n// If in production:\n$container['Zend\\Expressive\\FinalHandler'] = new Container\\TemplatedErrorHandlerFactory();\n\nreturn $container;  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\n$container = require 'config/services.php';\n$app = $container- get('Zend\\Expressive\\Application');\n$app- run();", 
            "title": "Configuring Pimple"
        }, 
        {
            "location": "/features/container/pimple/#environments", 
            "text": "In the example above, we provide two alternate definitions for the service Zend\\Expressive\\FinalHandler , one for development and one for production.\nYou will need to add logic to your file to determine which definition to\nprovide; this could be accomplished via an environment variable.", 
            "title": "Environments"
        }, 
        {
            "location": "/features/container/aura-di/", 
            "text": "Using Aura.Di\n\n\nAura.Di\n provides a serializable dependency\ninjection container with the following features:\n\n\n\n\nconstructor and setter injection.\n\n\ninheritance of constructor parameter and setter method values from parent\n  classes.\n\n\ninheritance of setter method values from interfaces and traits.\n\n\nlazy-loaded instances, services, includes/requires, and values.\n\n\ninstance factories.\n\n\noptional auto-resolution of typehinted constructor parameter values.\n\n\n\n\nInstalling Aura.Di\n\n\nAura.Di only implements \ncontainer-interop\n\nas of version 3 (in beta at the time of writing).\n\n\n$ composer require \naura/di:3.0.*@beta\n\n\n\n\nConfiguration\n\n\nAura.Di can help you to organize your code better with\n\nContainerConfig classes\n and\n\ntwo step configuration\n.\nIn this example, we'll put that in \nconfig/services.php\n:\n\n\n?php\nuse Aura\\Di\\ContainerBuilder;\n\n$containerBuilder = new ContainerBuilder();\n\n// Use the builder to create and configure a container using an array of\n// ContainerConfig classes. Make sure the classes can be autoloaded!\nreturn $containerBuilder-\nnewConfiguredInstance([\n    'Application\\Config\\Common',\n]);\n\n\n\n\nThe bare minimum \nContainerConfig\n code needed to make zend-expressive work is:\n\n\n?php\n// In src/Config/Common.php:\nnamespace Application\\Config;\n\nuse Aura\\Di\\Container;\nuse Aura\\Di\\ContainerConfig;\nuse Aura\\Router\\Generator;\nuse Aura\\Router\\RouteCollection;\nuse Aura\\Router\\RouteFactory;\nuse Aura\\Router\\Router;\nuse Zend\\Escaper\\Escaper;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router\\AuraRouter;\nuse Zend\\Expressive\\Router\\Route;\nuse Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass Common extends ContainerConfig\n{\n    public function define(Container $di)\n    {\n        $di-\nparams[RouteCollection::class] = array(\n            'route_factory' =\n $di-\nlazyNew(RouteFactory::class),\n        );\n        $di-\nparams[Router::class] = array(\n            'routes' =\n $di-\nlazyNew(RouteCollection::class),\n            'generator' =\n $di-\nlazyNew(Generator::class),\n        );\n        $di-\nparams[AuraRouter::class]['router'] = $di-\nlazyNew(Router::class);\n        $di-\nset(RouterInterface::class, $di-\nlazyNew(AuraRouter::class));\n        $di-\nset(Container\\ApplicationFactory::class, $di-\nlazyNew(Container\\ApplicationFactory::class));\n        $di-\nset(Application::class, $di-\nlazyGetCall(Container\\ApplicationFactory::class, '__invoke', $di));\n\n        // Templating\n        // In most cases, you can instantiate the template renderer you want to use\n        // without using a factory:\n        $di-\nset(TemplateRendererInterface::class, $di-\nlazyNew(PlatesRenderer::class));\n\n        // These next two can be added in any environment; they won't be used unless\n        // you add the WhoopsErrorHandler as the FinalHandler implementation:\n        $di-\nset(Container\\WhoopsFactory::class, $di-\nlazyNew(Container\\WhoopsFactory::class));\n        $di-\nset('Zend\\Expressive\\Whoops', $di-\nlazyGetCall(Container\\WhoopsFactory::class, '__invoke', $di));\n        $di-\nset(Container\\WhoopsPageHandlerFactory::class, $di-\nlazyNew(Container\\WhoopsPageHandlerFactory::class));\n        $di-\nset('Zend\\Expressive\\WhoopsPageHandler', $di-\nlazyGetCall(Container\\WhoopsPageHandlerFactory::class, '__invoke', $di));\n\n        // Error Handling\n\n        // If in development:\n        $di-\nset(Container\\WhoopsErrorHandlerFactory::class, $di-\nlazyNew(Container\\WhoopsErrorHandlerFactory::class));\n        $di-\nset('Zend\\Expressive\\FinalHandler', $di-\nlazyGetCall(Container\\WhoopsErrorHandlerFactory::class, '__invoke', $di));\n\n        // If in production:\n        // $di-\nset('Zend\\Expressive\\FinalHandler', $di-\nlazyGetCall(Container\\TemplatedErrorHandlerFactory::class, '__invoke', $di));\n    }\n\n    public function modify(Container $di)\n    {\n        /*\n        $router = $di-\nget(RouterInterface::class);\n        $router-\naddRoute(new Route('/hello/{name}', function ($request, $response, $next) {\n            $escaper = new Escaper();\n            $name = $request-\ngetAttribute('name', 'World');\n            $response-\ngetBody()-\nwrite('Hello ' . $escaper-\nescapeHtml($name));\n            return $response;\n        }, Route::HTTP_METHOD_ANY, 'hello'));\n        */\n    }\n}\n\n\n\n\nYour bootstrap (typically \npublic/index.php\n) will then look like this:\n\n\nchdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/services.php';\n$app = $container-\nget('Zend\\Expressive\\Application');\n$app-\nrun();", 
            "title": "Using Aura.Di"
        }, 
        {
            "location": "/features/container/aura-di/#using-auradi", 
            "text": "Aura.Di  provides a serializable dependency\ninjection container with the following features:   constructor and setter injection.  inheritance of constructor parameter and setter method values from parent\n  classes.  inheritance of setter method values from interfaces and traits.  lazy-loaded instances, services, includes/requires, and values.  instance factories.  optional auto-resolution of typehinted constructor parameter values.", 
            "title": "Using Aura.Di"
        }, 
        {
            "location": "/features/container/aura-di/#installing-auradi", 
            "text": "Aura.Di only implements  container-interop \nas of version 3 (in beta at the time of writing).  $ composer require  aura/di:3.0.*@beta", 
            "title": "Installing Aura.Di"
        }, 
        {
            "location": "/features/container/aura-di/#configuration", 
            "text": "Aura.Di can help you to organize your code better with ContainerConfig classes  and two step configuration .\nIn this example, we'll put that in  config/services.php :  ?php\nuse Aura\\Di\\ContainerBuilder;\n\n$containerBuilder = new ContainerBuilder();\n\n// Use the builder to create and configure a container using an array of\n// ContainerConfig classes. Make sure the classes can be autoloaded!\nreturn $containerBuilder- newConfiguredInstance([\n    'Application\\Config\\Common',\n]);  The bare minimum  ContainerConfig  code needed to make zend-expressive work is:  ?php\n// In src/Config/Common.php:\nnamespace Application\\Config;\n\nuse Aura\\Di\\Container;\nuse Aura\\Di\\ContainerConfig;\nuse Aura\\Router\\Generator;\nuse Aura\\Router\\RouteCollection;\nuse Aura\\Router\\RouteFactory;\nuse Aura\\Router\\Router;\nuse Zend\\Escaper\\Escaper;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Container;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\Router\\AuraRouter;\nuse Zend\\Expressive\\Router\\Route;\nuse Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass Common extends ContainerConfig\n{\n    public function define(Container $di)\n    {\n        $di- params[RouteCollection::class] = array(\n            'route_factory' =  $di- lazyNew(RouteFactory::class),\n        );\n        $di- params[Router::class] = array(\n            'routes' =  $di- lazyNew(RouteCollection::class),\n            'generator' =  $di- lazyNew(Generator::class),\n        );\n        $di- params[AuraRouter::class]['router'] = $di- lazyNew(Router::class);\n        $di- set(RouterInterface::class, $di- lazyNew(AuraRouter::class));\n        $di- set(Container\\ApplicationFactory::class, $di- lazyNew(Container\\ApplicationFactory::class));\n        $di- set(Application::class, $di- lazyGetCall(Container\\ApplicationFactory::class, '__invoke', $di));\n\n        // Templating\n        // In most cases, you can instantiate the template renderer you want to use\n        // without using a factory:\n        $di- set(TemplateRendererInterface::class, $di- lazyNew(PlatesRenderer::class));\n\n        // These next two can be added in any environment; they won't be used unless\n        // you add the WhoopsErrorHandler as the FinalHandler implementation:\n        $di- set(Container\\WhoopsFactory::class, $di- lazyNew(Container\\WhoopsFactory::class));\n        $di- set('Zend\\Expressive\\Whoops', $di- lazyGetCall(Container\\WhoopsFactory::class, '__invoke', $di));\n        $di- set(Container\\WhoopsPageHandlerFactory::class, $di- lazyNew(Container\\WhoopsPageHandlerFactory::class));\n        $di- set('Zend\\Expressive\\WhoopsPageHandler', $di- lazyGetCall(Container\\WhoopsPageHandlerFactory::class, '__invoke', $di));\n\n        // Error Handling\n\n        // If in development:\n        $di- set(Container\\WhoopsErrorHandlerFactory::class, $di- lazyNew(Container\\WhoopsErrorHandlerFactory::class));\n        $di- set('Zend\\Expressive\\FinalHandler', $di- lazyGetCall(Container\\WhoopsErrorHandlerFactory::class, '__invoke', $di));\n\n        // If in production:\n        // $di- set('Zend\\Expressive\\FinalHandler', $di- lazyGetCall(Container\\TemplatedErrorHandlerFactory::class, '__invoke', $di));\n    }\n\n    public function modify(Container $di)\n    {\n        /*\n        $router = $di- get(RouterInterface::class);\n        $router- addRoute(new Route('/hello/{name}', function ($request, $response, $next) {\n            $escaper = new Escaper();\n            $name = $request- getAttribute('name', 'World');\n            $response- getBody()- write('Hello ' . $escaper- escapeHtml($name));\n            return $response;\n        }, Route::HTTP_METHOD_ANY, 'hello'));\n        */\n    }\n}  Your bootstrap (typically  public/index.php ) will then look like this:  chdir(dirname(__DIR__));\nrequire 'vendor/autoload.php';\n$container = require 'config/services.php';\n$app = $container- get('Zend\\Expressive\\Application');\n$app- run();", 
            "title": "Configuration"
        }, 
        {
            "location": "/features/router/intro/", 
            "text": "Routing\n\n\nOne fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:\n\n\n\n\n/books\n might return a collection of books\n\n\n/books/zend-expressive\n might return the individual book identified by\n  \"zend-expressive\".\n\n\n\n\nExpressive does not provide routing on its own; you must choose a routing\nadapter that implements \nZend\\Expressive\\Router\\RouterInterface\n and provide it\nto the \nApplication\n instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.\n\n\nRetrieving matched parameters\n\n\nRouting enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as \nattributes\n.\n\n\nIn the example above, let's assume the route was defined as \n/books/:id\n, where\n\nid\n is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the \nid\n attribute to discover what was\nmatched:\n\n\n$id = $request-\ngetAttribute('id');\n\n\n\n\nURI generation\n\n\nBecause routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the \nRouterInterface\n,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.\n\n\nAt it's most basic level, you call the \ngenerateUri()\n method with a route name\nand any substitutions you want to make:\n\n\n$uri = $router-\ngenerateUri('book', ['id' =\n 'zend-expressive']);\n\n\n\n\nSupported implementations\n\n\nExpressive currently ships with adapters for the following routers:\n\n\n\n\nAura.Router\n\n\nFastRoute\n\n\nzend-mvc Router", 
            "title": "Introduction"
        }, 
        {
            "location": "/features/router/intro/#routing", 
            "text": "One fundamental feature of zend-expressive is that it provides mechanisms for\nimplementing dynamic routing, a feature required in most modern web\napplications. As an example, you may want to allow matching both a resource, as\nwell as individual items of that resource:   /books  might return a collection of books  /books/zend-expressive  might return the individual book identified by\n  \"zend-expressive\".   Expressive does not provide routing on its own; you must choose a routing\nadapter that implements  Zend\\Expressive\\Router\\RouterInterface  and provide it\nto the  Application  instance. This allows you to choose the router with the\ncapabilities that best match your own needs, while still providing a common\nabstraction for defining and aggregating routes and their related middleware.", 
            "title": "Routing"
        }, 
        {
            "location": "/features/router/intro/#retrieving-matched-parameters", 
            "text": "Routing enables the ability to match dynamic path segments (or other\ncriteria). Typically, you will want access to the values matched. The routing\nmiddleware injects any matched parameters as returned by the underlying router\ninto the request as  attributes .  In the example above, let's assume the route was defined as  /books/:id , where id  is the name of the dynamic segment. This means that in the middleware\ninvoked for this route, you can fetch the  id  attribute to discover what was\nmatched:  $id = $request- getAttribute('id');", 
            "title": "Retrieving matched parameters"
        }, 
        {
            "location": "/features/router/intro/#uri-generation", 
            "text": "Because routers have knowledge of the various paths they can match, they are\nalso typically used within applications to generate URIs to other application\nresources. Expressive provides this capability in the  RouterInterface ,\neither delegating to the underlying router implementations or providing a\ncompatible implementation of its own.  At it's most basic level, you call the  generateUri()  method with a route name\nand any substitutions you want to make:  $uri = $router- generateUri('book', ['id' =  'zend-expressive']);", 
            "title": "URI generation"
        }, 
        {
            "location": "/features/router/intro/#supported-implementations", 
            "text": "Expressive currently ships with adapters for the following routers:   Aura.Router  FastRoute  zend-mvc Router", 
            "title": "Supported implementations"
        }, 
        {
            "location": "/features/router/interface/", 
            "text": "Routing Interface\n\n\nExpressive defines \nZend\\Expressive\\Router\\RouterInterface\n, which can be\ninjected into and consumed by \nZend\\Expressive\\Application\n in order to provide\ndynamic routing capabilities to middleware. The interface serves as an\nabstraction to allow routers with varying capabilities to be used with an\napplication.\n\n\nThe interface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @param Route $route\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route);\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     *\n     * @param  Request $request\n     * @return RouteResult\n     */\n    public function match(Request $request);\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it.\n     *\n     * @see https://github.com/auraphp/Aura.Router#generating-a-route-path\n     * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html\n     * @param string $name\n     * @param array $substitutions\n     * @return string\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri($name, array $substitutions = []);\n}\n\n\n\n\nDevelopers may create and use their own implementations. We recommend\nregistering your implementation as the service\n\nZend\\Expressive\\Router\\RouterInterface\n in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.\n\n\nImplementors should also read the following sections detailing the \nRoute\n and\n\nRouteResult\n classes, to ensure that their implementations interoperate\ncorrectly.\n\n\nRoutes\n\n\nRoutes are defined via \nZend\\Expressive\\Router\\Route\n, and aggregate the\nfollowing information:\n\n\n\n\nPath to match.\n\n\nMiddleware to use when the route is matched. This may be a callable or a\n  service name resolving to middleware.\n\n\nHTTP methods allowed for the route; if none are provided, all are assumed.\n\n\nOptionally, a name by which to reference the route.\n\n\n\n\nThe \nRoute\n class has the following signature:\n\n\nnamespace Zend\\Expressive\\Router;\n\nclass Route\n{\n    const HTTP_METHOD_ANY = 0xff;\n    const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param string|callable $middleware Middleware to use when this route is matched.\n     * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param string|null $name the route name\n     * @throws Exception\\InvalidArgumentException for invalid path type.\n     * @throws Exception\\InvalidArgumentException for invalid middleware type.\n     * @throws Exception\\InvalidArgumentException for any invalid HTTP method names.\n     */\n    public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null);\n\n    /**\n     * @return string\n     */\n    public function getPath();\n\n    /**\n     * Set the route name.\n     *\n     * @param string $name\n     */\n    public function setName($name);\n\n    /**\n     * @return string\n     */\n    public function getName();\n\n    /**\n     * @return string|callable\n     */\n    public function getMiddleware();\n\n    /**\n     * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods();\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     * @return bool\n     */\n    public function allowsMethod($method);\n\n    /**\n     * @param array $options\n     */\n    public function setOptions(array $options);\n\n    /**\n     * @return array\n     */\n    public function getOptions();\n}\n\n\n\n\nTypically, developers will use \nZend\\Expressive\\Application::route()\n (or one of\nthe HTTP-specific routing methods) to create routes, and will not need to\ninteract with \nRoute\n instances. However, that method can \nalso\n accept \nRoute\n\ninstances, allowing more flexibility in defining and configuring them.\n\n\nMatching and RouteResults\n\n\nInternally, \nZend\\Expressive\\Application\n calls on \nRouterInterface::match()\n,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the\n\nHTTPS\n server variable, etc.\n\n\nImplementations are expected to return a \nZend\\Expressive\\Router\\RouteResult\n\ninstance, which the routing middleware then uses to determine if routing\nsucceeded. In the event of success, it will pull any matched parameters from the\nresult and inject them as request attributes, and then pull the matched\nmiddleware and execute it. In the case of failure, it will determine if the\nfailure was due to inability to match, or usage of a disallowed HTTP method; in\nthe former case, it proceeds to the next middleware in the stack, and in the\nlatter, returns a 405 response.\n\n\nThe \nRouteResult\n signature is as follows:\n\n\nnamespace Zend\\Expressive\\Router;\n\nclass RouteResult\n{\n    /**\n     * Create an instance representing a route success.\n     *\n     * @param string $name Name of matched route.\n     * @param callable|string $middleware Middleware associated with the\n     *     matched route.\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRouteMatch($name, $middleware, array $params);\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|int|array $methods HTTP methods allowed for the current URI, if any\n     * @return static\n     */\n    public static function fromRouteFailure($methods = null);\n\n    /**\n     * Does the result represent successful routing?\n     *\n     * @return bool\n     */\n    public function isSuccess();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Retrieve the matched middleware, if possible.\n     *\n     * @return false|callable|string Returns false if the result represents a\n     *     failure; otherwise, a callable or a string service name.\n     */\n    public function getMatchedMiddleware();\n\n    /**\n     * Returns the matched params.\n     *\n     * Guaranteed to return an array, even if it is simply empty.\n     *\n     * @return array\n     */\n    public function getMatchedParams();\n\n    /**\n     * Is this a routing failure result?\n     *\n     * @return bool\n     */\n    public function isFailure();\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     *\n     * @return bool\n     */\n    public function isMethodFailure();\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods();\n}\n\n\n\n\nTypically, only those implementing routers will interact with this class.", 
            "title": "Routing Interface"
        }, 
        {
            "location": "/features/router/interface/#routing-interface", 
            "text": "Expressive defines  Zend\\Expressive\\Router\\RouterInterface , which can be\ninjected into and consumed by  Zend\\Expressive\\Application  in order to provide\ndynamic routing capabilities to middleware. The interface serves as an\nabstraction to allow routers with varying capabilities to be used with an\napplication.  The interface is defined as follows:  namespace Zend\\Expressive\\Router;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as Request;\n\ninterface RouterInterface\n{\n    /**\n     * Add a route.\n     *\n     * This method adds a route against which the underlying implementation may\n     * match. Implementations MUST aggregate route instances, but MUST NOT use\n     * the details to inject the underlying router until `match()` and/or\n     * `generateUri()` is called.  This is required to allow consumers to\n     * modify route instances before matching (e.g., to provide route options,\n     * inject a name, etc.).\n     *\n     * The method MUST raise Exception\\RuntimeException if called after either `match()`\n     * or `generateUri()` have already been called, to ensure integrity of the\n     * router between invocations of either of those methods.\n     *\n     * @param Route $route\n     * @throws Exception\\RuntimeException when called after match() or\n     *     generateUri() have been called.\n     */\n    public function addRoute(Route $route);\n\n    /**\n     * Match a request against the known routes.\n     *\n     * Implementations will aggregate required information from the provided\n     * request instance, and pass them to the underlying router implementation;\n     * when done, they will then marshal a `RouteResult` instance indicating\n     * the results of the matching operation and return it to the caller.\n     *\n     * @param  Request $request\n     * @return RouteResult\n     */\n    public function match(Request $request);\n\n    /**\n     * Generate a URI from the named route.\n     *\n     * Takes the named route and any substitutions, and attempts to generate a\n     * URI from it.\n     *\n     * @see https://github.com/auraphp/Aura.Router#generating-a-route-path\n     * @see http://framework.zend.com/manual/current/en/modules/zend.mvc.routing.html\n     * @param string $name\n     * @param array $substitutions\n     * @return string\n     * @throws Exception\\RuntimeException if unable to generate the given URI.\n     */\n    public function generateUri($name, array $substitutions = []);\n}  Developers may create and use their own implementations. We recommend\nregistering your implementation as the service Zend\\Expressive\\Router\\RouterInterface  in your container to ensure other\nfactories provided by zend-expressive will receive your custom service.  Implementors should also read the following sections detailing the  Route  and RouteResult  classes, to ensure that their implementations interoperate\ncorrectly.", 
            "title": "Routing Interface"
        }, 
        {
            "location": "/features/router/interface/#routes", 
            "text": "Routes are defined via  Zend\\Expressive\\Router\\Route , and aggregate the\nfollowing information:   Path to match.  Middleware to use when the route is matched. This may be a callable or a\n  service name resolving to middleware.  HTTP methods allowed for the route; if none are provided, all are assumed.  Optionally, a name by which to reference the route.   The  Route  class has the following signature:  namespace Zend\\Expressive\\Router;\n\nclass Route\n{\n    const HTTP_METHOD_ANY = 0xff;\n    const HTTP_METHOD_SEPARATOR = ':';\n\n    /**\n     * @param string $path Path to match.\n     * @param string|callable $middleware Middleware to use when this route is matched.\n     * @param int|array Allowed HTTP methods; defaults to HTTP_METHOD_ANY.\n     * @param string|null $name the route name\n     * @throws Exception\\InvalidArgumentException for invalid path type.\n     * @throws Exception\\InvalidArgumentException for invalid middleware type.\n     * @throws Exception\\InvalidArgumentException for any invalid HTTP method names.\n     */\n    public function __construct($path, $middleware, $methods = self::HTTP_METHOD_ANY, $name = null);\n\n    /**\n     * @return string\n     */\n    public function getPath();\n\n    /**\n     * Set the route name.\n     *\n     * @param string $name\n     */\n    public function setName($name);\n\n    /**\n     * @return string\n     */\n    public function getName();\n\n    /**\n     * @return string|callable\n     */\n    public function getMiddleware();\n\n    /**\n     * @return int|string[] Returns HTTP_METHOD_ANY or array of allowed methods.\n     */\n    public function getAllowedMethods();\n\n    /**\n     * Indicate whether the specified method is allowed by the route.\n     *\n     * @param string $method HTTP method to test.\n     * @return bool\n     */\n    public function allowsMethod($method);\n\n    /**\n     * @param array $options\n     */\n    public function setOptions(array $options);\n\n    /**\n     * @return array\n     */\n    public function getOptions();\n}  Typically, developers will use  Zend\\Expressive\\Application::route()  (or one of\nthe HTTP-specific routing methods) to create routes, and will not need to\ninteract with  Route  instances. However, that method can  also  accept  Route \ninstances, allowing more flexibility in defining and configuring them.", 
            "title": "Routes"
        }, 
        {
            "location": "/features/router/interface/#matching-and-routeresults", 
            "text": "Internally,  Zend\\Expressive\\Application  calls on  RouterInterface::match() ,\npassing it the current request instance. This allows implementations to pull\nwhat they may need from the request in order to perform their routing logic; for\nexample, they may need the request method, the URI path, the value of the HTTPS  server variable, etc.  Implementations are expected to return a  Zend\\Expressive\\Router\\RouteResult \ninstance, which the routing middleware then uses to determine if routing\nsucceeded. In the event of success, it will pull any matched parameters from the\nresult and inject them as request attributes, and then pull the matched\nmiddleware and execute it. In the case of failure, it will determine if the\nfailure was due to inability to match, or usage of a disallowed HTTP method; in\nthe former case, it proceeds to the next middleware in the stack, and in the\nlatter, returns a 405 response.  The  RouteResult  signature is as follows:  namespace Zend\\Expressive\\Router;\n\nclass RouteResult\n{\n    /**\n     * Create an instance representing a route success.\n     *\n     * @param string $name Name of matched route.\n     * @param callable|string $middleware Middleware associated with the\n     *     matched route.\n     * @param array $params Parameters associated with the matched route.\n     * @return static\n     */\n    public static function fromRouteMatch($name, $middleware, array $params);\n\n    /**\n     * Create an instance representing a route failure.\n     *\n     * @param null|int|array $methods HTTP methods allowed for the current URI, if any\n     * @return static\n     */\n    public static function fromRouteFailure($methods = null);\n\n    /**\n     * Does the result represent successful routing?\n     *\n     * @return bool\n     */\n    public function isSuccess();\n\n    /**\n     * Retrieve the matched route name, if possible.\n     *\n     * If this result represents a failure, return false; otherwise, return the\n     * matched route name.\n     *\n     * @return string\n     */\n    public function getMatchedRouteName();\n\n    /**\n     * Retrieve the matched middleware, if possible.\n     *\n     * @return false|callable|string Returns false if the result represents a\n     *     failure; otherwise, a callable or a string service name.\n     */\n    public function getMatchedMiddleware();\n\n    /**\n     * Returns the matched params.\n     *\n     * Guaranteed to return an array, even if it is simply empty.\n     *\n     * @return array\n     */\n    public function getMatchedParams();\n\n    /**\n     * Is this a routing failure result?\n     *\n     * @return bool\n     */\n    public function isFailure();\n\n    /**\n     * Does the result represent failure to route due to HTTP method?\n     *\n     * @return bool\n     */\n    public function isMethodFailure();\n\n    /**\n     * Retrieve the allowed methods for the route failure.\n     *\n     * @return string[] HTTP methods allowed\n     */\n    public function getAllowedMethods();\n}  Typically, only those implementing routers will interact with this class.", 
            "title": "Matching and RouteResults"
        }, 
        {
            "location": "/features/router/uri-generation/", 
            "text": "URI Generation\n\n\nOne aspect of the \nZend\\Expressive\\Router\\RouterInterface\n is that it provides a\n\ngenerateUri()\n method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders).\n\n\nNaming routes\n\n\nBy default, routes use a combination of the path and HTTP methods supported as\nthe name:\n\n\n\n\nIf you call \nroute()\n with no HTTP methods, the name is the literal path with\n  no changes.\n\n\n\n\n$app-\nroute('/foo', $middleware); // \nfoo\n\n\n\n\n\n\nIf you call \nget()\n, \npost()\n, \nput()\n, \npatch()\n, or \ndelete()\n, the name\n  will be the literal path, followed by a caret (\n^\n), followed by the\n  uppercase HTTP method name:\n\n\n\n\n$app-\nget('/foo', $middleware); // \nfoo^GET\n\n\n\n\nAlternately, these methods return a \nRoute\n instance, and you can set the\n  name on it:\n\n\n$app-\nget('/foo', $middleware)-\nsetName('foo'); // \nfoo\n\n\n\n\n\n\nIf you call \nroute()\n and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret (\n^\n), followed by a colon\n  (\n:\n)-separated list of the uppercase HTTP method names, in the order in which\n  they were added.\n\n\n\n\n$app-\nroute('/foo', $middleware, ['GET', 'POST']); // \nfoo^GET:POST\n\n\n\n\nLike the HTTP-specific methods, \nroute()\n also returns a \nRoute\n instance,\n  and you can set the name on it:\n\n\n$route = $app-\nroute('/foo', $middleware, ['GET', 'POST']); // \nfoo^GET:POST\n\n$route-\nsetName('foo'); // \nfoo\n\n\n\n\nClearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:\n\n\n$app-\nroute('/foo', $middleware, 'foo'); // 'foo'\n$app-\nget('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app-\nroute('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'\n\n\n\n\nAs noted above, these methods also return \nRoute\n instances, allowing you to\nset the name after-the-fact; this is particularly useful with the \nroute()\n\nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:\n\n\n$app-\nroute('/foo', $middleware)-\nsetName('foo'); // 'foo'\n\n\n\n\nWe recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.\n\n\nGenerating URIs\n\n\nOnce you know the name of a URI you wish to generate, you can do so from the\nrouter instance:\n\n\n$uri = $router-\ngenerateUri('foo-item', ['id' =\n 'bar']); // \n/foo/bar\n\n\n\n\nYou can omit the second argument if no substitutions are necessary.\n\n\n\n\nCompose the router\n\n\nFor this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the\n\nZend\\Expressive\\Router\\RouterInterface\n service in these situations.", 
            "title": "URI Generation"
        }, 
        {
            "location": "/features/router/uri-generation/#uri-generation", 
            "text": "One aspect of the  Zend\\Expressive\\Router\\RouterInterface  is that it provides a generateUri()  method. This method accepts a route name, and optionally an\nassociative array of substitutions to use in the generated URI (e.g., if the URI\nhas any named placeholders).", 
            "title": "URI Generation"
        }, 
        {
            "location": "/features/router/uri-generation/#naming-routes", 
            "text": "By default, routes use a combination of the path and HTTP methods supported as\nthe name:   If you call  route()  with no HTTP methods, the name is the literal path with\n  no changes.   $app- route('/foo', $middleware); //  foo   If you call  get() ,  post() ,  put() ,  patch() , or  delete() , the name\n  will be the literal path, followed by a caret ( ^ ), followed by the\n  uppercase HTTP method name:   $app- get('/foo', $middleware); //  foo^GET  Alternately, these methods return a  Route  instance, and you can set the\n  name on it:  $app- get('/foo', $middleware)- setName('foo'); //  foo   If you call  route()  and specify a list of HTTP methods accepted, the name\n  will be the literal path, followed by a caret ( ^ ), followed by a colon\n  ( : )-separated list of the uppercase HTTP method names, in the order in which\n  they were added.   $app- route('/foo', $middleware, ['GET', 'POST']); //  foo^GET:POST  Like the HTTP-specific methods,  route()  also returns a  Route  instance,\n  and you can set the name on it:  $route = $app- route('/foo', $middleware, ['GET', 'POST']); //  foo^GET:POST \n$route- setName('foo'); //  foo  Clearly, this can become difficult to remember. As such, Expressive offers the\nability to specify a custom string for the route name as an additional, optional\nargument to any of the above:  $app- route('/foo', $middleware, 'foo'); // 'foo'\n$app- get('/foo/:id', $middleware, 'foo-item'); // 'foo-item'\n$app- route('/foo', $middleware, ['GET', 'POST'], 'foo-collection'); // 'foo-collection'  As noted above, these methods also return  Route  instances, allowing you to\nset the name after-the-fact; this is particularly useful with the  route() \nmethod, where you may want to omit the HTTP methods if any HTTP method is\nallowed:  $app- route('/foo', $middleware)- setName('foo'); // 'foo'  We recommend that if you plan on generating URIs for given routes, you provide a\ncustom name.", 
            "title": "Naming routes"
        }, 
        {
            "location": "/features/router/uri-generation/#generating-uris", 
            "text": "Once you know the name of a URI you wish to generate, you can do so from the\nrouter instance:  $uri = $router- generateUri('foo-item', ['id' =  'bar']); //  /foo/bar  You can omit the second argument if no substitutions are necessary.", 
            "title": "Generating URIs"
        }, 
        {
            "location": "/features/router/uri-generation/#compose-the-router", 
            "text": "For this to work, you'll need to compose the router instance in any class that\nrequires the URI generation facility. Inject the Zend\\Expressive\\Router\\RouterInterface  service in these situations.", 
            "title": "Compose the router"
        }, 
        {
            "location": "/features/router/result-observers/", 
            "text": "Route Result Observers\n\n\n\n\nDEPRECATED!\n\n\nThe route result observers feature existed prior to the stable 1.0 release,\nbut was deprecated with 1.0.0RC6. Please do not use this feature; instead,\nyou can inject middleware between the routing and dispatch middleware that can\nact on the matched route result.\n\n\n\n\nOccasionally, you may have need of the \nRouteResult\n within other application\ncode. As a primary example, a URI generator may want this information to allow\ncreating \"self\" URIs, or to allow presenting a subset of parameters to generate\na URI.\n\n\nConsider this URI:\n\n\n'/api/v{version:\\d+}/post/{post_id:\\d+}/comment/{comment_id:\\d+}'\n\n\n\n\nIf you wanted to generate URIs to a list of related comments, you may not want\nto pass the \n$version\n and \n$post_id\n parameters each and every time, but\ninstead just the \n$comment_id\n. As such, \nroute result observers\n exist to allow\nyou to notify such utilities of the results of matching.\n\n\nRouteResultObserverInterface\n\n\nRoute result observers must implement the \nRouteResultObserverInterface\n:\n\n\nnamespace Zend\\Expressive\\Router;\n\nuse Zend\\Expressive\\Router\\RouteResult;\n\ninterface RouteResultObserverInterface\n{\n    /**\n     * Observe a route result.\n     *\n     * @param RouteResult $result\n     */\n    public function update(RouteResult $result);\n}\n\n\n\n\nThese can then be attached to the \nApplication\n instance:\n\n\n$app-\nattachRouteResultObserver($observer);\n\n\n\n\nAs noted, the observer receives the \nRouteResult\n from attempting to match a\nroute.\n\n\nYou can detach an existing observer as well, by passing its instance to the\n\ndetachRouteResultObserver()\n method:\n\n\n$app-\ndetachRouteResultObserver($observer);\n\n\n\n\n\n\nRouteResultSubjectInterface\n\n\nZend\\Expressive\\Application\n implements \nZend\\Expressive\\Router\\RouteResultSubjectInterface\n,\nwhich defines methods for attaching and detaching route result observers, as\nwell as a method for notifying observers. Typically you'll only see the\n\nApplication\n class as an implementation of the interface, but you can always\ncreate your own implementations as well if desired \n for instance, if\nyou are implementing your own middleware runtime using the various interfaces\nExpressive provides.\n\n\n\n\nExample\n\n\nFor this example, we'll build a simple URI generator. It will compose a\n\nRouterInterface\n implementation, implement \nRouteResultObserverInterface\n, and,\nwhen invoked, generate a URI.\n\n\nuse Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Router\\RouteResultObserverInterface;\n\nclass UriGenerator implements RouteResultObserverInterface\n{\n    private $defaults = [];\n\n    private $routeName;\n\n    private $router;\n\n    public function __construct(RouterInterface $router)\n    {\n        $this-\nrouter = $router;\n    }\n\n    public function update(RouteResult $result)\n    {\n        if ($result-\nisFailure()) {\n            return;\n        }\n\n        $this-\nrouteName = $result-\ngetMatchedRouteName();\n        $this-\ndefaults  = $result-\ngetMatchedParams();\n    }\n\n    public function __invoke($route = null, array $params = [])\n    {\n        if (! $route \n ! $this-\nrouteName) {\n            throw new InvalidArgumentException('Missing route, and no route was matched to use as a default!');\n        }\n\n        $route = $route ?: $this-\nrouteName;\n\n        if ($route === $this-\nrouteName) {\n            $params = array_merge($this-\ndefaults, $params);\n        }\n\n        return $this-\nrouter-\ngenerateUri($route, $params);\n    }\n}\n\n\n\n\nNow that we've defined the \nUriGenerator\n, we need:\n\n\n\n\na factory for creating it\n\n\na way to attach it to the application\n\n\n\n\nFirst, the factory, which is essentially a one-liner wrapped in a class:\n\n\nuse Container\\Interop\\ContainerInterface;\nuse Zend\\Expressive\\Router\\RouterInterface;\n\nclass UriGeneratorFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new UriGenerator($container-\nget(RouterInterface::class));\n    }\n}\n\n\n\n\nAttaching the observer to the application can happen in one of two ways:\n\n\n\n\nVia modification of the bootstrap script.\n\n\nBy updating the factory to register the observer with the application.\n\n\n\n\nModifying the bootstrap script\n\n\nIf you choose this method, you will modify your \npublic/index.php\n script (or\nwhatever script you've defined as the application gateway.) The following\nassumes you're using the \npublic/index.php\n generated for you when using the\nExpressive skeleton.\n\n\nIn this case, you would attach any observers between the line where you fetch\nthe application from the container, and the line when you run it.\n\n\n$app = $container-\nget('Zend\\Expressive\\Application');\n\n// Attach observers\n$app-\nattachRouteResultObserver($container-\nget(UriGenerator::class));\n\n$app-\nrun();\n\n\n\n\nVia the observer factory\n\n\nThis approach requires a slight change to the factory to:\n\n\n\n\nCheck for a \nZend\\Expressive\\Application\n service; and, if found,\n\n\nAttach the observer to it.\n\n\n\n\nuse Container\\Interop\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Router\\RouterInterface;\n\nclass UriGeneratorFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $generator = new UriGenerator($container-\nget(RouterInterface::class));\n\n        if ($container-\nhas(Application::class)) {\n            $container\n                -\nget(Application::class)\n                -\nattachRouteResultObserver($generator);\n        }\n\n        return $generator;\n    }\n}\n\n\n\n\n\n\nNote: Helpers included!\n\n\nYou do not need to create the above URI generator for your code; this\nfunctionality is already present in the \nzendframework/zend-expressive-helpers\n\npackage, and, if you started with the Expressive skeleton, may already\nbe installed by default!\n\n\nSee the \nhelpers documentation\n for more information.", 
            "title": "Route Result Observers"
        }, 
        {
            "location": "/features/router/result-observers/#route-result-observers", 
            "text": "", 
            "title": "Route Result Observers"
        }, 
        {
            "location": "/features/router/result-observers/#deprecated", 
            "text": "The route result observers feature existed prior to the stable 1.0 release,\nbut was deprecated with 1.0.0RC6. Please do not use this feature; instead,\nyou can inject middleware between the routing and dispatch middleware that can\nact on the matched route result.   Occasionally, you may have need of the  RouteResult  within other application\ncode. As a primary example, a URI generator may want this information to allow\ncreating \"self\" URIs, or to allow presenting a subset of parameters to generate\na URI.  Consider this URI:  '/api/v{version:\\d+}/post/{post_id:\\d+}/comment/{comment_id:\\d+}'  If you wanted to generate URIs to a list of related comments, you may not want\nto pass the  $version  and  $post_id  parameters each and every time, but\ninstead just the  $comment_id . As such,  route result observers  exist to allow\nyou to notify such utilities of the results of matching.", 
            "title": "DEPRECATED!"
        }, 
        {
            "location": "/features/router/result-observers/#routeresultobserverinterface", 
            "text": "Route result observers must implement the  RouteResultObserverInterface :  namespace Zend\\Expressive\\Router;\n\nuse Zend\\Expressive\\Router\\RouteResult;\n\ninterface RouteResultObserverInterface\n{\n    /**\n     * Observe a route result.\n     *\n     * @param RouteResult $result\n     */\n    public function update(RouteResult $result);\n}  These can then be attached to the  Application  instance:  $app- attachRouteResultObserver($observer);  As noted, the observer receives the  RouteResult  from attempting to match a\nroute.  You can detach an existing observer as well, by passing its instance to the detachRouteResultObserver()  method:  $app- detachRouteResultObserver($observer);", 
            "title": "RouteResultObserverInterface"
        }, 
        {
            "location": "/features/router/result-observers/#routeresultsubjectinterface", 
            "text": "Zend\\Expressive\\Application  implements  Zend\\Expressive\\Router\\RouteResultSubjectInterface ,\nwhich defines methods for attaching and detaching route result observers, as\nwell as a method for notifying observers. Typically you'll only see the Application  class as an implementation of the interface, but you can always\ncreate your own implementations as well if desired   for instance, if\nyou are implementing your own middleware runtime using the various interfaces\nExpressive provides.", 
            "title": "RouteResultSubjectInterface"
        }, 
        {
            "location": "/features/router/result-observers/#example", 
            "text": "For this example, we'll build a simple URI generator. It will compose a RouterInterface  implementation, implement  RouteResultObserverInterface , and,\nwhen invoked, generate a URI.  use Zend\\Expressive\\Router\\RouterInterface;\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Router\\RouteResultObserverInterface;\n\nclass UriGenerator implements RouteResultObserverInterface\n{\n    private $defaults = [];\n\n    private $routeName;\n\n    private $router;\n\n    public function __construct(RouterInterface $router)\n    {\n        $this- router = $router;\n    }\n\n    public function update(RouteResult $result)\n    {\n        if ($result- isFailure()) {\n            return;\n        }\n\n        $this- routeName = $result- getMatchedRouteName();\n        $this- defaults  = $result- getMatchedParams();\n    }\n\n    public function __invoke($route = null, array $params = [])\n    {\n        if (! $route   ! $this- routeName) {\n            throw new InvalidArgumentException('Missing route, and no route was matched to use as a default!');\n        }\n\n        $route = $route ?: $this- routeName;\n\n        if ($route === $this- routeName) {\n            $params = array_merge($this- defaults, $params);\n        }\n\n        return $this- router- generateUri($route, $params);\n    }\n}  Now that we've defined the  UriGenerator , we need:   a factory for creating it  a way to attach it to the application   First, the factory, which is essentially a one-liner wrapped in a class:  use Container\\Interop\\ContainerInterface;\nuse Zend\\Expressive\\Router\\RouterInterface;\n\nclass UriGeneratorFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new UriGenerator($container- get(RouterInterface::class));\n    }\n}  Attaching the observer to the application can happen in one of two ways:   Via modification of the bootstrap script.  By updating the factory to register the observer with the application.", 
            "title": "Example"
        }, 
        {
            "location": "/features/router/result-observers/#modifying-the-bootstrap-script", 
            "text": "If you choose this method, you will modify your  public/index.php  script (or\nwhatever script you've defined as the application gateway.) The following\nassumes you're using the  public/index.php  generated for you when using the\nExpressive skeleton.  In this case, you would attach any observers between the line where you fetch\nthe application from the container, and the line when you run it.  $app = $container- get('Zend\\Expressive\\Application');\n\n// Attach observers\n$app- attachRouteResultObserver($container- get(UriGenerator::class));\n\n$app- run();", 
            "title": "Modifying the bootstrap script"
        }, 
        {
            "location": "/features/router/result-observers/#via-the-observer-factory", 
            "text": "This approach requires a slight change to the factory to:   Check for a  Zend\\Expressive\\Application  service; and, if found,  Attach the observer to it.   use Container\\Interop\\ContainerInterface;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Router\\RouterInterface;\n\nclass UriGeneratorFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $generator = new UriGenerator($container- get(RouterInterface::class));\n\n        if ($container- has(Application::class)) {\n            $container\n                - get(Application::class)\n                - attachRouteResultObserver($generator);\n        }\n\n        return $generator;\n    }\n}   Note: Helpers included!  You do not need to create the above URI generator for your code; this\nfunctionality is already present in the  zendframework/zend-expressive-helpers \npackage, and, if you started with the Expressive skeleton, may already\nbe installed by default!  See the  helpers documentation  for more information.", 
            "title": "Via the observer factory"
        }, 
        {
            "location": "/features/router/piping/", 
            "text": "Routing vs Piping\n\n\nExpressive provides two mechanisms for adding middleware to your\napplication:\n\n\n\n\npiping, which is a foundation feature of the underlying\n  \nzend-stratigility\n\n  implementation.\n\n\nrouting, which is an additional feature provided by zend-expressive.\n\n\n\n\nPiping\n\n\nzend-stratigility provides a mechanism termed \npiping\n for composing middleware\nin an application. When you \npipe\n middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.\nIf none ever returns a response instance, execution is delegated to a \"final\nhandler\", which determines whether or not to return an error, and, if so, what\nkind of error to return.\n\n\nStratigility also allows you to segregate piped middleware to specific paths. As\nan example:\n\n\n$app-\npipe('/api', $apiMiddleware);\n\n\n\n\nwill execute \n$apiMiddleware\n only if the path matches \n/api\n; otherwise, it\nwill skip over that middleware.\n\n\nThis path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.\n\n\nExpressive uses and exposes piping to users, with one addition: \nmiddleware\nmay be specified by service name, and zend-expressive will lazy-load the service\nonly when the middleware is invoked\n.\n\n\nIn order to accomplish the lazy-loading, zend-expressive wraps the calls to fetch\nthe middleware from the container and to dispatch that middleware inside a\nclosure. This poses a problem for error handling middleware, however, as\nzend-stratigility identifies error handling middleware by its arity (number of\nfunction arguments); as such, zend-expressive defines an additional method for\npiping service-driven error handling middleware, \npipeErrorHandler()\n. The\nmethod has the same signature as \npipe()\n:\n\n\n// Without a path:\n$app-\npipeErrorHandler('error handler service name');\n\n// Specific to a path:\n$app-\npipeErrorHandler('/api', 'error handler service name');\n\n\n\n\nThis method will return a closure using the error middleware signature.\n\n\nRouting\n\n\nRouting is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:\n\n\n\n\n/book/:id\n (ZF2)\n\n\n/book/{id}\n (Aura.Router)\n\n\n/book/{id:\\d+}\n (FastRoute)\n\n\n\n\nIn each of the above, if the router determines that the request matches the\ncriteria, it will indicate:\n\n\n\n\nthe route that matched\n\n\nthe \nid\n parameter was matched, and the value matched\n\n\n\n\nMost routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:\n\n\n\n\ndefault values for unmatched parameters\n\n\ncriteria for evaluating a match (such as a regular expression)\n\n\nadditional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)\n\n\n\n\nAs such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).\n\n\nWhen to Pipe\n\n\nIn Expressive, we recommend that you pipe middleware in the following\ncircumstances:\n\n\n\n\nIt should (potentially) run on every execution. Examples for such usage\n  include:\n\n\nLogging requests\n\n\nPerforming content negotiation\n\n\nHandling cookies\n\n\n\n\n\n\nError handling. Typically these should be piped after any normal middleware.\n\n\nApplication segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.\n\n\n\n\nWhen to Route\n\n\nUse routing when:\n\n\n\n\nYour middleware is reacting to a given path.\n\n\nYou want to use dynamic routing.\n\n\nYou want to restrict usage of middleware to specific HTTP methods.\n\n\nYou want to be able to generate URIs to your middleware.\n\n\n\n\nThe above cover most use cases; \nin other words, most middleware should be added\nto the application as routed middleware\n.\n\n\nControlling middleware execution order\n\n\nAs noted in the earlier section on piping, piped middleware is \nqueued\n, meaning\nit has a FIFO (\"first in, first out\") execution order.\n\n\nAdditionally, zend-expressive's routing capabilities are themselves implemented\nas piped middleware.\n\n\nAs such, if you programmatically configure the router and add routes without\nusing \nApplication::route()\n, you may run into issues with the order in which\npiped middleware (middleware added to the application via the \npipe()\n method)\nis executed.\n\n\nTo ensure that everything executes in the correct order, you can call\n\nApplication::pipeRouteMiddleware()\n at any time to pipe it to the application.\nAs an example, after you have created your application instance:\n\n\n$app-\npipe($middlewareToExecuteFirst);\n$app-\npipeRouteMiddleware();\n$app-\npipe($errorMiddleware);\n\n\n\n\nIf you fail to add any routes via \nApplication::route()\n or to call\n\nApplication::pipeRouteMiddleware()\n, the routing middleware will be called\nwhen executing the application. \nThis means that it will be last in the\nmiddleware pipeline,\n which means that if you registered any error\nmiddleware, it can never be invoked.\n\n\nTo sum:\n\n\n\n\nPipe middleware to execute on every request \nbefore\n routing any middleware\n  and/or \nbefore\n calling \nApplication::pipeRouteMiddleware()\n.\n\n\nPipe error handling middleware \nafter\n defining routes and/or \nafter\n calling\n  \nApplication::pipeRouteMiddleware()\n.\n\n\n\n\nIf you use the provided \nZend\\Expressive\\Container\\ApplicationFactory\n for\nretrieving your \nApplication\n instance, you can do this by defining pre- and\npost-pipeline middleware, and the factory will ensure everything is registered\ncorrectly.", 
            "title": "Routing vs Piping"
        }, 
        {
            "location": "/features/router/piping/#routing-vs-piping", 
            "text": "Expressive provides two mechanisms for adding middleware to your\napplication:   piping, which is a foundation feature of the underlying\n   zend-stratigility \n  implementation.  routing, which is an additional feature provided by zend-expressive.", 
            "title": "Routing vs Piping"
        }, 
        {
            "location": "/features/router/piping/#piping", 
            "text": "zend-stratigility provides a mechanism termed  piping  for composing middleware\nin an application. When you  pipe  middleware to the application, it is added to\na queue, and dequeued in order until a middleware returns a response instance.\nIf none ever returns a response instance, execution is delegated to a \"final\nhandler\", which determines whether or not to return an error, and, if so, what\nkind of error to return.  Stratigility also allows you to segregate piped middleware to specific paths. As\nan example:  $app- pipe('/api', $apiMiddleware);  will execute  $apiMiddleware  only if the path matches  /api ; otherwise, it\nwill skip over that middleware.  This path segregation, however, is limited: it will only match literal paths.\nThis is done purposefully, to provide excellent baseline performance, and to\nprevent feature creep in the library.  Expressive uses and exposes piping to users, with one addition:  middleware\nmay be specified by service name, and zend-expressive will lazy-load the service\nonly when the middleware is invoked .  In order to accomplish the lazy-loading, zend-expressive wraps the calls to fetch\nthe middleware from the container and to dispatch that middleware inside a\nclosure. This poses a problem for error handling middleware, however, as\nzend-stratigility identifies error handling middleware by its arity (number of\nfunction arguments); as such, zend-expressive defines an additional method for\npiping service-driven error handling middleware,  pipeErrorHandler() . The\nmethod has the same signature as  pipe() :  // Without a path:\n$app- pipeErrorHandler('error handler service name');\n\n// Specific to a path:\n$app- pipeErrorHandler('/api', 'error handler service name');  This method will return a closure using the error middleware signature.", 
            "title": "Piping"
        }, 
        {
            "location": "/features/router/piping/#routing", 
            "text": "Routing is the process of discovering values from the incoming request based on\ndefined criteria. That criteria might look like:   /book/:id  (ZF2)  /book/{id}  (Aura.Router)  /book/{id:\\d+}  (FastRoute)   In each of the above, if the router determines that the request matches the\ncriteria, it will indicate:   the route that matched  the  id  parameter was matched, and the value matched   Most routers allow you to define arbitrarily complex rules, and many even allow\nyou to define:   default values for unmatched parameters  criteria for evaluating a match (such as a regular expression)  additional criteria to meet (such as SSL usage, allowed query string\n  variables, etc.)   As such, routing is more powerful than the literal path matching used when\npiping, but it is also more costly (though routers such as FastRoute largely\nmake such performance issues moot).", 
            "title": "Routing"
        }, 
        {
            "location": "/features/router/piping/#when-to-pipe", 
            "text": "In Expressive, we recommend that you pipe middleware in the following\ncircumstances:   It should (potentially) run on every execution. Examples for such usage\n  include:  Logging requests  Performing content negotiation  Handling cookies    Error handling. Typically these should be piped after any normal middleware.  Application segregation. You can write re-usable middleware, potentially even\n  based off of Expressive, that contains its own routing logic, and compose it\n  such that it only executes if it matches a sub-path.", 
            "title": "When to Pipe"
        }, 
        {
            "location": "/features/router/piping/#when-to-route", 
            "text": "Use routing when:   Your middleware is reacting to a given path.  You want to use dynamic routing.  You want to restrict usage of middleware to specific HTTP methods.  You want to be able to generate URIs to your middleware.   The above cover most use cases;  in other words, most middleware should be added\nto the application as routed middleware .", 
            "title": "When to Route"
        }, 
        {
            "location": "/features/router/piping/#controlling-middleware-execution-order", 
            "text": "As noted in the earlier section on piping, piped middleware is  queued , meaning\nit has a FIFO (\"first in, first out\") execution order.  Additionally, zend-expressive's routing capabilities are themselves implemented\nas piped middleware.  As such, if you programmatically configure the router and add routes without\nusing  Application::route() , you may run into issues with the order in which\npiped middleware (middleware added to the application via the  pipe()  method)\nis executed.  To ensure that everything executes in the correct order, you can call Application::pipeRouteMiddleware()  at any time to pipe it to the application.\nAs an example, after you have created your application instance:  $app- pipe($middlewareToExecuteFirst);\n$app- pipeRouteMiddleware();\n$app- pipe($errorMiddleware);  If you fail to add any routes via  Application::route()  or to call Application::pipeRouteMiddleware() , the routing middleware will be called\nwhen executing the application.  This means that it will be last in the\nmiddleware pipeline,  which means that if you registered any error\nmiddleware, it can never be invoked.  To sum:   Pipe middleware to execute on every request  before  routing any middleware\n  and/or  before  calling  Application::pipeRouteMiddleware() .  Pipe error handling middleware  after  defining routes and/or  after  calling\n   Application::pipeRouteMiddleware() .   If you use the provided  Zend\\Expressive\\Container\\ApplicationFactory  for\nretrieving your  Application  instance, you can do this by defining pre- and\npost-pipeline middleware, and the factory will ensure everything is registered\ncorrectly.", 
            "title": "Controlling middleware execution order"
        }, 
        {
            "location": "/features/router/aura/", 
            "text": "Using Aura.Router\n\n\nAura.Router\n provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:\n\n\n\n\nA regular expression that applies the same for a given routing match:\n\n\n\n\n// Parameters named \nid\n will only match digits by default:\n$router-\naddTokens([\n  'id' =\n '\\d+',\n]);\n\n\n\n\n\n\nA default parameter and/or its default value to always provide:\n\n\n\n\n// mediatype defaults to \napplication/xhtml+xml\n and will be available in all\n// requests:\n$router-\naddValues([\n  'mediatype' =\n 'application/xhtml+xml',\n]);\n\n\n\n\n\n\nOnly match if secure (i.e., under HTTPS):\n\n\n\n\n$router-\nsetSecure(true);\n\n\n\n\nIn order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling Aura.Router\n\n\nTo use Aura.Router, you will first need to install the Aura.Router integration:\n\n\n$ composer require zendframework/zend-expressive-aurarouter\n\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\AuraRouter\n instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:\n\n\nuse Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();\n\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\AuraRouter\n during instantiation.\n\n\n?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())-\nnewInstance();\n$auraRouter-\nsetSecure(true);\n$auraRouter-\naddValues([\n    'mediatype' =\n 'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your Aura.Router implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\AuraRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraRouter();\n    }\n}\n\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container-\nsetFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n\n\n\nAnd in Pimple:\n\n\n$pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();\n\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container-\nsetInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\AuraRouter'\n);\n\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nAura\\Router\\Router\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\AuraRouter\n instance composing the\n  \nAura\\Router\\Router\n instance.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n// in src/Application/Container/AuraRouterFactory.php:\nnamespace Application\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Interop\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())-\nnewInstance();\n        $router-\nsetSecure(true);\n        $router-\naddValues([\n            'mediatype' =\n 'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container-\nget('Aura\\Router\\Router'));\n    }\n}\n\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container-\naddFactory(\n    'Aura\\Router\\Router',\n    'Application\\Container\\AuraRouterFactory'\n);\n$container-\naddFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' =\n [\n        'Aura\\Router\\Router' =\n 'Application\\Container\\AuraRouterFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' =\n 'Application\\Container\\RouterFactory',\n    ],\n];\n\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\AuraRouterFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['Aura\\Router\\Router'] = new AuraRouterFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();", 
            "title": "Using Aura"
        }, 
        {
            "location": "/features/router/aura/#using-aurarouter", 
            "text": "Aura.Router  provides a plethora of\nmethods for further configuring the router instance. One of the more useful\nconfiguration is to provide default specifications:   A regular expression that applies the same for a given routing match:   // Parameters named  id  will only match digits by default:\n$router- addTokens([\n  'id' =  '\\d+',\n]);   A default parameter and/or its default value to always provide:   // mediatype defaults to  application/xhtml+xml  and will be available in all\n// requests:\n$router- addValues([\n  'mediatype' =  'application/xhtml+xml',\n]);   Only match if secure (i.e., under HTTPS):   $router- setSecure(true);  In order to specify these, you need access to the underlying Aura.Router\ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.", 
            "title": "Using Aura.Router"
        }, 
        {
            "location": "/features/router/aura/#installing-aurarouter", 
            "text": "To use Aura.Router, you will first need to install the Aura.Router integration:  $ composer require zendframework/zend-expressive-aurarouter", 
            "title": "Installing Aura.Router"
        }, 
        {
            "location": "/features/router/aura/#quick-start", 
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\AuraRouter  instance\nwith no arguments; it will create the underlying Aura.Router objects required\nand compose them for you:  use Zend\\Expressive\\Router\\AuraRouter;\n\n$router = new AuraRouter();", 
            "title": "Quick Start"
        }, 
        {
            "location": "/features/router/aura/#programmatic-creation", 
            "text": "If you need greater control over the Aura.Router setup and configuration, you\ncan create the instances necessary and inject them into Zend\\Expressive\\Router\\AuraRouter  during instantiation.  ?php\nuse Aura\\Router\\RouterFactory;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\n$auraRouter = (new RouterFactory())- newInstance();\n$auraRouter- setSecure(true);\n$auraRouter- addValues([\n    'mediatype' =  'application/xhtml+xml',\n]);\n\n$router = new AuraBridge($auraRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);", 
            "title": "Programmatic Creation"
        }, 
        {
            "location": "/features/router/aura/#piping-the-route-middleware", 
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!", 
            "title": "Piping the route middleware"
        }, 
        {
            "location": "/features/router/aura/#factory-driven-creation", 
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your Aura.Router implementation.", 
            "title": "Factory-Driven Creation"
        }, 
        {
            "location": "/features/router/aura/#basic-router", 
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\AuraRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container- setFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);  And in Pimple:  $pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container- setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\AuraRouter'\n);", 
            "title": "Basic Router"
        }, 
        {
            "location": "/features/router/aura/#advanced-configuration", 
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Aura\\Router\\Router  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\AuraRouter  instance composing the\n   Aura\\Router\\Router  instance.   Sound difficult? It's not; we've essentially done it above already!  // in src/Application/Container/AuraRouterFactory.php:\nnamespace Application\\Container;\n\nuse Aura\\Router\\RouterFactory;\nuse Interop\\Container\\ContainerInterface;\n\nclass AuraRouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return \\Aura\\Router\\Router\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = (new RouterFactory())- newInstance();\n        $router- setSecure(true);\n        $router- addValues([\n            'mediatype' =  'application/xhtml+xml',\n        ]);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\AuraRouter as AuraBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return AuraBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new AuraBridge($container- get('Aura\\Router\\Router'));\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container- addFactory(\n    'Aura\\Router\\Router',\n    'Application\\Container\\AuraRouterFactory'\n);\n$container- addFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' =  [\n        'Aura\\Router\\Router' =  'Application\\Container\\AuraRouterFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' =  'Application\\Container\\RouterFactory',\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\AuraRouterFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['Aura\\Router\\Router'] = new AuraRouterFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();", 
            "title": "Advanced Configuration"
        }, 
        {
            "location": "/features/router/fast-route/", 
            "text": "Using FastRoute\n\n\nFastRoute\n provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.\n\n\nInternally, we use the standard route parser (\nFastRoute\\RouterParser\\Std\n) to\nparse routes, a \nRouteCollector\n to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.\n\n\nIf you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the \nZend\\Expressive\\Router\\FastRouteRouter\n class, at instantiation.\n\n\nThe \nFastRouteRouter\n bridge class accepts two arguments at instantiation:\n\n\n\n\nA \nFastRoute\\RouteCollector\n instance\n\n\nA callable that will return a \nFastRoute\\Dispatcher\\RegexBasedAbstract\n\n  instance.\n\n\n\n\nInjection can be done either programmatically or via a factory to use in\nconjunction with your container instance.\n\n\nInstalling FastRoute\n\n\nTo use FastRoute, you will first need to install the FastRoute integration:\n\n\n$ composer require zendframework/zend-expressive-fastroute\n\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\FastRouteRouter\n instance\nwith no arguments; it will create the underlying FastRoute objects required\nand compose them for you:\n\n\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\n$router = new FastRouteRouter();\n\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the FastRoute setup and configuration, you\ncan create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\FastRouteRouter\n during instantiation.\n\n\nTo do so, you will need to setup your \nRouteCollector\n instance and/or\noptionally callable to return your \nRegexBasedAbstract\n instance manually,\ninject them in your \nZend\\Expressive\\Router\\FastRouteRouter\n instance, and inject use\nthat when creating your \nApplication\n instance.\n\n\n?php\nuse FastRoute;\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\n$fastRoute = new RouteCollector(\n    new RouteParser(),\n    new RouteGenerator()\n);\n$getDispatcher = function ($data) {\n    return new FastRouteDispatcher($data);\n};\n\n\n$router = new FastRouteBridge($fastRoute, $getDispatcher);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your FastRoute implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\FastRouteRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteRouter();\n    }\n}\n\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container-\nsetFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n\n\n\nAnd in Pimple:\n\n\n$pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();\n\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container-\nsetInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\FastRouteRouter'\n);\n\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:\n\n\n\n\nA factory to register as and generate a \nFastRoute\\RouteCollector\n instance.\n\n\nA factory to register as \nFastRoute\\DispatcherFactory\n and return a callable\n  factory that returns a \nRegexBasedAbstract\n instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\FastRouteRouter\n instance composing the\n  two services.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n?php\n// in src/Application/Container/FastRouteCollectorFactory.php:\nnamespace Application\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Interop\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/Application/Container/FastRouteDispatcherFactory:\nnamespace Application\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Interop\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container-\nget('FastRoute\\RouteCollector'),\n            $container-\nget('FastRoute\\DispatcherFactory'),\n        );\n    }\n}\n\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container-\naddFactory(\n    'FastRoute\\RouteCollector',\n    'Application\\Container\\FastRouteCollectorFactory'\n);\n$container-\naddFactory(\n    'FastRoute\\DispatcherFactory',\n    'Application\\Container\\FastRouteDispatcherFactory'\n);\n$container-\naddFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' =\n [\n        'FastRoute\\RouteCollector' =\n 'Application\\Container\\FastRouteCollectorFactory',\n        'FastRoute\\DispatcherFactory' =\n 'Application\\Container\\FastRouteDispatcherFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' =\n 'Application\\Container\\RouterFactory',\n    ],\n];\n\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\FastRouteCollectorFactory;\nuse Application\\Container\\FastRouteDispatcherFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['FastRoute\\RouteCollector'] = new FastRouteCollectorFactory();\n$container['FastRoute\\RouteDispatcher'] = new FastRouteDispatcherFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();", 
            "title": "Using FastRoute"
        }, 
        {
            "location": "/features/router/fast-route/#using-fastroute", 
            "text": "FastRoute  provides a number of different\ncombinations for how to both parse routes and match incoming requests against\nthem.  Internally, we use the standard route parser ( FastRoute\\RouterParser\\Std ) to\nparse routes, a  RouteCollector  to collect them, and the \"Group Count Based\"\ndispatcher to match incoming requests against routes.  If you wish to use a different combination \u2014 e.g., to use the Group Position\nBased route matcher \u2014 you will need to create your own instances and inject them\ninto the  Zend\\Expressive\\Router\\FastRouteRouter  class, at instantiation.  The  FastRouteRouter  bridge class accepts two arguments at instantiation:   A  FastRoute\\RouteCollector  instance  A callable that will return a  FastRoute\\Dispatcher\\RegexBasedAbstract \n  instance.   Injection can be done either programmatically or via a factory to use in\nconjunction with your container instance.", 
            "title": "Using FastRoute"
        }, 
        {
            "location": "/features/router/fast-route/#installing-fastroute", 
            "text": "To use FastRoute, you will first need to install the FastRoute integration:  $ composer require zendframework/zend-expressive-fastroute", 
            "title": "Installing FastRoute"
        }, 
        {
            "location": "/features/router/fast-route/#quick-start", 
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\FastRouteRouter  instance\nwith no arguments; it will create the underlying FastRoute objects required\nand compose them for you:  use Zend\\Expressive\\Router\\FastRouteRouter;\n\n$router = new FastRouteRouter();", 
            "title": "Quick Start"
        }, 
        {
            "location": "/features/router/fast-route/#programmatic-creation", 
            "text": "If you need greater control over the FastRoute setup and configuration, you\ncan create the instances necessary and inject them into Zend\\Expressive\\Router\\FastRouteRouter  during instantiation.  To do so, you will need to setup your  RouteCollector  instance and/or\noptionally callable to return your  RegexBasedAbstract  instance manually,\ninject them in your  Zend\\Expressive\\Router\\FastRouteRouter  instance, and inject use\nthat when creating your  Application  instance.  ?php\nuse FastRoute;\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\n$fastRoute = new RouteCollector(\n    new RouteParser(),\n    new RouteGenerator()\n);\n$getDispatcher = function ($data) {\n    return new FastRouteDispatcher($data);\n};\n\n\n$router = new FastRouteBridge($fastRoute, $getDispatcher);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);", 
            "title": "Programmatic Creation"
        }, 
        {
            "location": "/features/router/fast-route/#piping-the-route-middleware", 
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!", 
            "title": "Piping the route middleware"
        }, 
        {
            "location": "/features/router/fast-route/#factory-driven-creation", 
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your FastRoute implementation.", 
            "title": "Factory-Driven Creation"
        }, 
        {
            "location": "/features/router/fast-route/#basic-router", 
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\FastRouteRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container- setFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);  And in Pimple:  $pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container- setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\FastRouteRouter'\n);", 
            "title": "Basic Router"
        }, 
        {
            "location": "/features/router/fast-route/#advanced-configuration", 
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining three factories:   A factory to register as and generate a  FastRoute\\RouteCollector  instance.  A factory to register as  FastRoute\\DispatcherFactory  and return a callable\n  factory that returns a  RegexBasedAbstract  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\FastRouteRouter  instance composing the\n  two services.   Sound difficult? It's not; we've essentially done it above already!  ?php\n// in src/Application/Container/FastRouteCollectorFactory.php:\nnamespace Application\\Container;\n\nuse FastRoute\\RouteCollector;\nuse FastRoute\\RouteGenerator;\nuse FastRoute\\RouteParser\\Std as RouteParser;\nuse Interop\\Container\\ContainerInterface;\n\nclass FastRouteCollectorFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return RouteCollector\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RouteCollector(\n            new RouteParser(),\n            new RouteGenerator()\n        );\n    }\n}\n\n// in src/Application/Container/FastRouteDispatcherFactory:\nnamespace Application\\Container;\n\nuse FastRoute\\Dispatcher\\GroupPosBased as FastRouteDispatcher;\nuse Interop\\Container\\ContainerInterface;\n\nclass FastRouteDispatcherFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return callable\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return function ($data) {\n            return new FastRouteDispatcher($data);\n        };\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\FastRouteRouter as FastRouteBridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return FastRouteBridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new FastRouteBridge(\n            $container- get('FastRoute\\RouteCollector'),\n            $container- get('FastRoute\\DispatcherFactory'),\n        );\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container- addFactory(\n    'FastRoute\\RouteCollector',\n    'Application\\Container\\FastRouteCollectorFactory'\n);\n$container- addFactory(\n    'FastRoute\\DispatcherFactory',\n    'Application\\Container\\FastRouteDispatcherFactory'\n);\n$container- addFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' =  [\n        'FastRoute\\RouteCollector' =  'Application\\Container\\FastRouteCollectorFactory',\n        'FastRoute\\DispatcherFactory' =  'Application\\Container\\FastRouteDispatcherFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' =  'Application\\Container\\RouterFactory',\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\FastRouteCollectorFactory;\nuse Application\\Container\\FastRouteDispatcherFactory;\nuse Application\\Container\\RouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop as Pimple;\n\n$container = new Pimple();\n$container['FastRoute\\RouteCollector'] = new FastRouteCollectorFactory();\n$container['FastRoute\\RouteDispatcher'] = new FastRouteDispatcherFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();", 
            "title": "Advanced Configuration"
        }, 
        {
            "location": "/features/router/zf2/", 
            "text": "Using the ZF2 Router\n\n\nzend-mvc\n provides a router\nimplementation; for HTTP applications, the default used in ZF2 applications is\n\nZend\\Mvc\\Router\\Http\\TreeRouteStack\n, which can compose a number of different\nroutes of differing types in order to perform routing.\n\n\nThe ZF2 bridge we provide, \nZend\\Expressive\\Router\\ZendRouter\n, uses the\n\nTreeRouteStack\n, and injects \nSegment\n routes to it; these are in turn injected\nwith \nMethod\n routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.\n\n\nIf you instantiate it with no arguments, it will create an empty\n\nTreeRouteStack\n. Thus, the simplest way to start with this router is:\n\n\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$app = AppFactory::create(null, new ZendRouter());\n\n\n\n\nThe \nTreeRouteStack\n offers some unique features:\n\n\n\n\nRoute \"prototypes\". These are essentially like child routes that must \nalso\n\n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.\n\n\nBase URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.\n\n\n\n\nTo specify these, you need access to the underlying \nTreeRouteStack\n\ninstance, however, and the \nRouterInterface\n does not provide an accessor!\n\n\nThe answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.\n\n\nInstalling the ZF2 Router\n\n\nTo use the ZF2 router, you will need to install the zend-mvc router integration:\n\n\n$ composer require zendframework/zend-expressive-zendrouter\n\n\n\n\nQuick Start\n\n\nAt its simplest, you can instantiate a \nZend\\Expressive\\Router\\ZendRouter\n instance\nwith no arguments; it will create the underlying zend-mvc routing objects\nrequired and compose them for you:\n\n\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$router = new ZendRouter();\n\n\n\n\nProgrammatic Creation\n\n\nIf you need greater control over the zend-mvc router setup and configuration,\nyou can create the instances necessary and inject them into\n\nZend\\Expressive\\Router\\ZendRouter\n during instantiation.\n\n\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\nuse Zend\\Mvc\\Router\\Http\\TreeRouteStack;\n\n$zendRouter = new TreeRouteStack();\n$zendRouter-\naddPrototypes(/* ... */);\n$zendRouter-\nsetBaseUrl(/* ... */);\n\n$router = new Zf2Bridge($zendRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);\n\n\n\n\n\n\nPiping the route middleware\n\n\nAs a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the \npiping documentation\n. This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!\n\n\n\n\nFactory-Driven Creation\n\n\nWe recommend using an Inversion of Control container\n\nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your zend-mvc router implementation.\n\n\nBasic Router\n\n\nIf you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of \nZend\\Expressive\\Router\\ZendRouter\n for the\nservice name \nZend\\Expressive\\Router\\RouterInterface\n.\n\n\nA factory would look like this:\n\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return ZendRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new ZendRouter();\n    }\n}\n\n\n\n\nYou would register this with zend-servicemanager using:\n\n\n$container-\nsetFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n\n\n\nAnd in Pimple:\n\n\n$pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();\n\n\n\n\nFor zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:\n\n\n$container-\nsetInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\ZendRouter'\n);\n\n\n\n\nAdvanced Configuration\n\n\nIf you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:\n\n\n\n\nA factory to register as and generate an \nZend\\Mvc\\Router\\Http\\TreeRouteStack\n\n  instance.\n\n\nA factory registered as \nZend\\Expressive\\Router\\RouterInterface\n, which\n  creates and returns a \nZend\\Expressive\\Router\\ZendRouter\n instance composing the\n  \nZend\\Mvc\\Router\\Http\\TreeRouteStack\n instance.\n\n\n\n\nSound difficult? It's not; we've essentially done it above already!\n\n\n// in src/Application/Container/TreeRouteStackFactory.php:\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Http\\Mvc\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router-\naddPrototypes(/* ... */);\n        $router-\nsetBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container-\nget('Zend\\Mvc\\Router\\Http\\TreeRouteStack'));\n    }\n}\n\n\n\n\nFrom here, you will need to register your factories with your IoC container.\n\n\nIf you are using zend-servicemanager, this will look like:\n\n\n// Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container-\naddFactory(\n    'Zend\\Mvc\\Router\\Http\\TreeRouteStack',\n    'Application\\Container\\TreeRouteStackFactory'\n);\n$container-\naddFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' =\n [\n        'Zend\\Mvc\\Router\\Http\\TreeRouteStack' =\n 'Application\\Container\\TreeRouteStackFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' =\n 'Application\\Container\\RouterFactory',\n    ],\n];\n\n\n\n\nFor Pimple, configuration looks like:\n\n\nuse Application\\Container\\TreeRouteStackFactory;\nuse Application\\Container\\ZfRouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop;\n\n$container = new PimpleInterop();\n$container['Zend\\Mvc\\Router\\Http\\TreeRouteStackFactory'] = new TreeRouteStackFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();", 
            "title": "Using the ZF2 Router"
        }, 
        {
            "location": "/features/router/zf2/#using-the-zf2-router", 
            "text": "zend-mvc  provides a router\nimplementation; for HTTP applications, the default used in ZF2 applications is Zend\\Mvc\\Router\\Http\\TreeRouteStack , which can compose a number of different\nroutes of differing types in order to perform routing.  The ZF2 bridge we provide,  Zend\\Expressive\\Router\\ZendRouter , uses the TreeRouteStack , and injects  Segment  routes to it; these are in turn injected\nwith  Method  routes, and a special \"method not allowed\" route at negative\npriority to enable us to distinguish between failure to match the path and\nfailure to match the HTTP method.  If you instantiate it with no arguments, it will create an empty TreeRouteStack . Thus, the simplest way to start with this router is:  use Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\n$app = AppFactory::create(null, new ZendRouter());  The  TreeRouteStack  offers some unique features:   Route \"prototypes\". These are essentially like child routes that must  also \n  match in order for a given route to match. These are useful for implementing\n  functionality such as ensuring the request comes in over HTTPS, or over a\n  specific subdomain.  Base URL functionality. If a base URL is injected, comparisons will be\n  relative to that URL. This is mostly unnecessary with Stratigility-based\n  middleware, but could solve some edge cases.   To specify these, you need access to the underlying  TreeRouteStack \ninstance, however, and the  RouterInterface  does not provide an accessor!  The answer, then, is to use dependency injection. This can be done in two ways:\nprogrammatically, or via a factory to use in conjunction with your container\ninstance.", 
            "title": "Using the ZF2 Router"
        }, 
        {
            "location": "/features/router/zf2/#installing-the-zf2-router", 
            "text": "To use the ZF2 router, you will need to install the zend-mvc router integration:  $ composer require zendframework/zend-expressive-zendrouter", 
            "title": "Installing the ZF2 Router"
        }, 
        {
            "location": "/features/router/zf2/#quick-start", 
            "text": "At its simplest, you can instantiate a  Zend\\Expressive\\Router\\ZendRouter  instance\nwith no arguments; it will create the underlying zend-mvc routing objects\nrequired and compose them for you:  use Zend\\Expressive\\Router\\ZendRouter;\n\n$router = new ZendRouter();", 
            "title": "Quick Start"
        }, 
        {
            "location": "/features/router/zf2/#programmatic-creation", 
            "text": "If you need greater control over the zend-mvc router setup and configuration,\nyou can create the instances necessary and inject them into Zend\\Expressive\\Router\\ZendRouter  during instantiation.  use Zend\\Expressive\\AppFactory;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\nuse Zend\\Mvc\\Router\\Http\\TreeRouteStack;\n\n$zendRouter = new TreeRouteStack();\n$zendRouter- addPrototypes(/* ... */);\n$zendRouter- setBaseUrl(/* ... */);\n\n$router = new Zf2Bridge($zendRouter);\n\n// First argument is the container to use, if not using the default;\n// second is the router.\n$app = AppFactory::create(null, $router);", 
            "title": "Programmatic Creation"
        }, 
        {
            "location": "/features/router/zf2/#piping-the-route-middleware", 
            "text": "As a reminder, you will need to ensure that middleware is piped in the order\nin which it needs to be executed; please see the section on \"Controlling\nmiddleware execution order\" in the  piping documentation . This is\nparticularly salient when defining routes before injecting the router in the\napplication instance!", 
            "title": "Piping the route middleware"
        }, 
        {
            "location": "/features/router/zf2/#factory-driven-creation", 
            "text": "We recommend using an Inversion of Control container \nfor your applications; as such, in this section we will demonstrate \ntwo strategies for creating your zend-mvc router implementation.", 
            "title": "Factory-Driven Creation"
        }, 
        {
            "location": "/features/router/zf2/#basic-router", 
            "text": "If you don't need to provide any setup or configuration, you can simply\ninstantiate and return an instance of  Zend\\Expressive\\Router\\ZendRouter  for the\nservice name  Zend\\Expressive\\Router\\RouterInterface .  A factory would look like this:  // in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return ZendRouter\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new ZendRouter();\n    }\n}  You would register this with zend-servicemanager using:  $container- setFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);  And in Pimple:  $pimple['Zend\\Expressive\\Router\\RouterInterface'] = new Application\\Container\\RouterFactory();  For zend-servicemanager, you can omit the factory entirely, and register the\nclass as an invokable:  $container- setInvokableClass(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Zend\\Expressive\\Router\\ZendRouter'\n);", 
            "title": "Basic Router"
        }, 
        {
            "location": "/features/router/zf2/#advanced-configuration", 
            "text": "If you want to provide custom setup or configuration, you can do so. In this\nexample, we will be defining two factories:   A factory to register as and generate an  Zend\\Mvc\\Router\\Http\\TreeRouteStack \n  instance.  A factory registered as  Zend\\Expressive\\Router\\RouterInterface , which\n  creates and returns a  Zend\\Expressive\\Router\\ZendRouter  instance composing the\n   Zend\\Mvc\\Router\\Http\\TreeRouteStack  instance.   Sound difficult? It's not; we've essentially done it above already!  // in src/Application/Container/TreeRouteStackFactory.php:\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Http\\Mvc\\Router\\TreeRouteStack;\n\nclass TreeRouteStackFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return TreeRouteStack\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        $router = new TreeRouteStack();\n        $router- addPrototypes(/* ... */);\n        $router- setBaseUrl(/* ... */);\n\n        return $router;\n    }\n}\n\n// in src/Application/Container/RouterFactory.php\nnamespace Application\\Container;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Router\\ZendRouter as Zf2Bridge;\n\nclass RouterFactory\n{\n    /**\n     * @param ContainerInterface $container\n     * @return Zf2Bridge\n     */\n    public function __invoke(ContainerInterface $container)\n    {\n        return new Zf2Bridge($container- get('Zend\\Mvc\\Router\\Http\\TreeRouteStack'));\n    }\n}  From here, you will need to register your factories with your IoC container.  If you are using zend-servicemanager, this will look like:  // Programmatically:\nuse Zend\\ServiceManager\\ServiceManager;\n\n$container = new ServiceManager();\n$container- addFactory(\n    'Zend\\Mvc\\Router\\Http\\TreeRouteStack',\n    'Application\\Container\\TreeRouteStackFactory'\n);\n$container- addFactory(\n    'Zend\\Expressive\\Router\\RouterInterface',\n    'Application\\Container\\RouterFactory'\n);\n\n// Alternately, via configuration:\nreturn [\n    'factories' =  [\n        'Zend\\Mvc\\Router\\Http\\TreeRouteStack' =  'Application\\Container\\TreeRouteStackFactory',\n        'Zend\\Expressive\\Router\\RouterInterface' =  'Application\\Container\\RouterFactory',\n    ],\n];  For Pimple, configuration looks like:  use Application\\Container\\TreeRouteStackFactory;\nuse Application\\Container\\ZfRouterFactory;\nuse Interop\\Container\\Pimple\\PimpleInterop;\n\n$container = new PimpleInterop();\n$container['Zend\\Mvc\\Router\\Http\\TreeRouteStackFactory'] = new TreeRouteStackFactory();\n$container['Zend\\Expressive\\Router\\RouterInterface'] = new RouterFactory();", 
            "title": "Advanced Configuration"
        }, 
        {
            "location": "/features/template/intro/", 
            "text": "Templating\n\n\nBy default, no middleware in Expressive is templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.\n\n\nWe do, however, provide abstraction for templating via the interface\n\nZend\\Expressive\\Template\\TemplateRendererInterface\n, which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:\n\n\n\n\nAll adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation \nnamespace::template\n when rendering.\n\n\nAdapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).\n\n\nAdapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.\n\n\nAdapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.\n\n\n\n\nIn this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.\n\n\nWe currently support:\n\n\n\n\nPlates\n\n\nTwig\n\n\nzend-view\n\n\n\n\nEach has an associated container factory; details are found in the\n\nfactories documentation\n.", 
            "title": "Introduction"
        }, 
        {
            "location": "/features/template/intro/#templating", 
            "text": "By default, no middleware in Expressive is templated. We do not even\nprovide a default templating engine, as the choice of templating engine is often\nvery specific to the project and/or organization.  We do, however, provide abstraction for templating via the interface Zend\\Expressive\\Template\\TemplateRendererInterface , which allows you to write\nmiddleware that is engine-agnostic. For Expressive, this means:   All adapters MUST support template namespacing. Namespaces MUST be referenced\n  using the notation  namespace::template  when rendering.  Adapters MUST allow rendering templates that omit the extension; they will, of\n  course, resolve to whatever default extension they require (or as configured).  Adapters SHOULD allow passing an extension in the template name, but how that\n  is handled is left up to the adapter.  Adapters SHOULD abstract layout capabilities. Many templating systems provide\n  this out of the box, or similar, compatible features such as template\n  inheritance. This should be transparent to end-users; they should be able to\n  simply render a template and assume it has the full content to return.   In this documentation, we'll detail the features of this interface, the various\nimplementations we provide, and how you can configure, inject, and consume\ntemplating in your middleware.  We currently support:   Plates  Twig  zend-view   Each has an associated container factory; details are found in the factories documentation .", 
            "title": "Templating"
        }, 
        {
            "location": "/features/template/interface/", 
            "text": "The Template Renderer Interface\n\n\nExpressive defines \nZend\\Expressive\\Template\\TemplateRendererInterface\n, which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:\n\n\nnamespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param string $name\n     * @param array|object $params\n     * @return string\n     */\n    public function render($name, $params = []);\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     *\n     * @param string $path\n     * @param string $namespace\n     */\n    public function addPath($path, $namespace = null);\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths();\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param string $param Param name.\n     * @param mixed $value\n     */\n    public function addDefaultParam($templateName, $param, $value);\n}\n\n\n\n\n\n\nNamespaces\n\n\nUnfortunately, namespace syntax varies between different template engine\nimplementations. As an example:\n\n\n\n\nPlates uses the syntax \nnamespace::template\n.\n\n\nTwig uses the syntax \n@namespace/template\n.\n\n\nzend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.\n\n\n\n\nTo make different engines compatible, we require implementations to support\nthe syntax \nnamespace::template\n (where \nnamespace::\n is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.\n\n\nWhen using a \nTemplateRendererInterface\n implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.\n\n\n\n\nPaths\n\n\nMost template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the \naddPath()\n method to do so:\n\n\n$renderer-\naddPath('templates');\n\n\n\n\nTemplate engines adapted for zend-expressive are also required to allow\n\nnamespacing\n templates; when adding a path, you specify the template\n\nnamespace\n that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.\n\n\n// Resolves to a path registered with the namespace \nerror\n;\n// this example is specific to the Plates engine.\n$content = $renderer-\nrender('error::404');\n\n\n\n\nYou can provide a namespace when registering a path via an optional second\nargument:\n\n\n// Registers the \nerror\n namespace to the path \ntemplates/error/\n\n$renderer-\naddPath('templates/error/', 'error');\n\n\n\n\nRendering\n\n\nTo render a template, call the \nrender()\n method. This method requires the name\nof a template as the first argument:\n\n\n$content = $renderer-\nrender('foo');\n\n\n\n\nYou can specify a namespaced template using the syntax \nnamespace::template\n;\nthe \ntemplate\n segment of the template name may use additional directory\nseparators when necessary.\n\n\nOne key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to \nrender()\n:\n\n\n$content = $renderer-\nrender('message', [\n    'greeting'  =\n 'Hello',\n    'recipient' =\n 'World',\n]);\n\n\n\n\nIt is up to the underlying template engine to determine how to perform the\ninjections.\n\n\nDefault params\n\n\nThe \nTemplateRendererInterface\n defines the method \naddDefaultParam()\n. This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:\n\n\npublic function addDefaultParam($templateName, $param, $value)\n\n\n\n\nIf you want a parameter to be used for \nevery\n template, you can specify the\nconstant \nTemplateRendererInterface::TEMPLATE_ALL\n for the \n$templateName\n\nparameter.\n\n\nWhen rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:\n\n\n\n\nDefault parameters specified for all templates.\n\n\nDefault parameters specified for the template specified at rendering.\n\n\nParameters specified when rendering.\n\n\n\n\nAs an example, if we did the following:\n\n\n$renderer-\naddDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer-\naddDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer-\naddDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer-\naddDefaultParam('example', 'foo', 'template default foo');\n$renderer-\naddDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer-\nrender('example', [\n    'foo' =\n 'override',\n]);\n\n\n\n\nThen we can expect the following substitutions will occur when rendering:\n\n\n\n\nReferences to the \"foo\" variable will contain \"override\".\n\n\nReferences to the \"bar\" variable will contain \"template default bar\".\n\n\nReferences to the \"baz\" variable will contain \"bat\".\n\n\n\n\n\n\nSupport for default params\n\n\nThe support for default params will often be renderer-specific. The reason is\nbecause the \nrender()\n signature does not specify a type for \n$params\n, in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given \n$params\n argument does not support it.\n\n\nAt the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.", 
            "title": "Template Renderer Interface"
        }, 
        {
            "location": "/features/template/interface/#the-template-renderer-interface", 
            "text": "Expressive defines  Zend\\Expressive\\Template\\TemplateRendererInterface , which can be\ninjected into middleware in order to create templated response bodies. The\ninterface is defined as follows:  namespace Zend\\Expressive\\Template;\n\ninterface TemplateRendererInterface\n{\n    /**\n     * Render a template, optionally with parameters.\n     *\n     * Implementations MUST support the `namespace::template` naming convention,\n     * and allow omitting the filename extension.\n     *\n     * @param string $name\n     * @param array|object $params\n     * @return string\n     */\n    public function render($name, $params = []);\n\n    /**\n     * Add a template path to the engine.\n     *\n     * Adds a template path, with optional namespace the templates in that path\n     * provide.\n     *\n     * @param string $path\n     * @param string $namespace\n     */\n    public function addPath($path, $namespace = null);\n\n    /**\n     * Retrieve configured paths from the engine.\n     *\n     * @return TemplatePath[]\n     */\n    public function getPaths();\n\n    /**\n     * Add a default parameter to use with a template.\n     *\n     * Use this method to provide a default parameter to use when a template is\n     * rendered. The parameter may be overridden by providing it when calling\n     * `render()`, or by calling this method again with a null value.\n     *\n     * The parameter will be specific to the template name provided. To make\n     * the parameter available to any template, pass the TEMPLATE_ALL constant\n     * for the template name.\n     *\n     * If the default parameter existed previously, subsequent invocations with\n     * the same template name and parameter name will overwrite.\n     *\n     * @param string $templateName Name of template to which the param applies;\n     *     use TEMPLATE_ALL to apply to all templates.\n     * @param string $param Param name.\n     * @param mixed $value\n     */\n    public function addDefaultParam($templateName, $param, $value);\n}", 
            "title": "The Template Renderer Interface"
        }, 
        {
            "location": "/features/template/interface/#namespaces", 
            "text": "Unfortunately, namespace syntax varies between different template engine\nimplementations. As an example:   Plates uses the syntax  namespace::template .  Twig uses the syntax  @namespace/template .  zend-view does not natively support namespaces, though custom resolvers\n  can provide the functionality.   To make different engines compatible, we require implementations to support\nthe syntax  namespace::template  (where  namespace::  is optional) when\nrendering. Additionally, we require that engines allow omitting the filename\nsuffix.  When using a  TemplateRendererInterface  implementation, feel free to use namespaced\ntemplates, and to omit the filename suffix; this will make your code portable\nand allow it to use alternate template engines.", 
            "title": "Namespaces"
        }, 
        {
            "location": "/features/template/interface/#paths", 
            "text": "Most template engines and implementations will require that you specify one or\nmore paths to templates; these are then used when resolving a template name to\nthe actual template. You may use the  addPath()  method to do so:  $renderer- addPath('templates');  Template engines adapted for zend-expressive are also required to allow namespacing  templates; when adding a path, you specify the template namespace  that it fulfills, and the engine will only return a template from\nthat path if the namespace provided matches the namespace for the path.  // Resolves to a path registered with the namespace  error ;\n// this example is specific to the Plates engine.\n$content = $renderer- render('error::404');  You can provide a namespace when registering a path via an optional second\nargument:  // Registers the  error  namespace to the path  templates/error/ \n$renderer- addPath('templates/error/', 'error');", 
            "title": "Paths"
        }, 
        {
            "location": "/features/template/interface/#rendering", 
            "text": "To render a template, call the  render()  method. This method requires the name\nof a template as the first argument:  $content = $renderer- render('foo');  You can specify a namespaced template using the syntax  namespace::template ;\nthe  template  segment of the template name may use additional directory\nseparators when necessary.  One key reason to use templates is to dynamically provide data to inject in the\ntemplate. You may do so by passing either an associative array or an object as\nthe second argument to  render() :  $content = $renderer- render('message', [\n    'greeting'  =  'Hello',\n    'recipient' =  'World',\n]);  It is up to the underlying template engine to determine how to perform the\ninjections.", 
            "title": "Rendering"
        }, 
        {
            "location": "/features/template/interface/#default-params", 
            "text": "The  TemplateRendererInterface  defines the method  addDefaultParam() . This\nmethod can be used to specify default parameters to use when rendering a\ntemplate. The signature is:  public function addDefaultParam($templateName, $param, $value)  If you want a parameter to be used for  every  template, you can specify the\nconstant  TemplateRendererInterface::TEMPLATE_ALL  for the  $templateName \nparameter.  When rendering, parameters are considered in the following order, with later\nitems having precedence over earlier ones:   Default parameters specified for all templates.  Default parameters specified for the template specified at rendering.  Parameters specified when rendering.   As an example, if we did the following:  $renderer- addDefaultParam($renderer::TEMPLATE_ALL, 'foo', 'bar');\n$renderer- addDefaultParam($renderer::TEMPLATE_ALL, 'bar', 'baz');\n$renderer- addDefaultParam($renderer::TEMPLATE_ALL, 'baz', 'bat');\n\n$renderer- addDefaultParam('example', 'foo', 'template default foo');\n$renderer- addDefaultParam('example', 'bar', 'template default bar');\n\n$content = $renderer- render('example', [\n    'foo' =  'override',\n]);  Then we can expect the following substitutions will occur when rendering:   References to the \"foo\" variable will contain \"override\".  References to the \"bar\" variable will contain \"template default bar\".  References to the \"baz\" variable will contain \"bat\".", 
            "title": "Default params"
        }, 
        {
            "location": "/features/template/interface/#support-for-default-params", 
            "text": "The support for default params will often be renderer-specific. The reason is\nbecause the  render()  signature does not specify a type for  $params , in\norder to allow passing alternative arguments such as view models. In such\ncases, the implementation will indicate its behavior when default parameters\nare specified, but a given  $params  argument does not support it.  At the time of writing, each of the Plates, Twig, and zend-view\nimplementations support the feature.", 
            "title": "Support for default params"
        }, 
        {
            "location": "/features/template/middleware/", 
            "text": "Templated Middleware\n\n\nThe primary use case for templating is within middleware, to provide templated\nresponses. To do this, you will:\n\n\n\n\nInject an instance of \nZend\\Expressive\\Template\\TemplateRendererInterface\n into your\n  middleware.\n\n\nPotentially add paths to the templating instance.\n\n\nRender a template.\n\n\nAdd the results of rendering to your response.\n\n\n\n\nInjecting a TemplateRendererInterface\n\n\nWe encourage the use of dependency injection. As such, we recommend writing your\nmiddleware to accept the \nTemplateRendererInterface\n via either the constructor or a\nsetter. As an example:\n\n\nnamespace Acme\\Blog;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this-\ntemplateRenderer = $renderer;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        // ...\n    }\n}\n\n\n\n\nThis will necessitate having a factory for your middleware:\n\n\nnamespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryMiddleware;\nuse Interop\\Container\\ContainerInterface;\n\nclass EntryMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryMiddleware(\n            $container-\nget('Zend\\Expressive\\Template\\TemplateRendererInterface')\n        );\n    }\n}\n\n\n\n\nAnd, of course, you'll need to tell your container to use the factory; see the\n\ncontainer documentation\n for more information on how you\nmight accomplish that.\n\n\nConsuming templates\n\n\nNow that we have the templating engine injected into our middleware, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:\n\n\n?php\nnamespace Acme\\Blog;\n\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this-\ntemplateRenderer = $renderer;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this-\ntemplateRenderer-\nrender('blog::entry', [\n                'entry' =\n $entry,\n            ])\n        );\n    }\n}\n\n\n\n\nAlternately, you can write to the composed response:\n\n\n$response-\ngetBody()-\nwrite($this-\ntemplateRenderer-\nrender('blog::entry', [\n    'entry' =\n $entry,\n]));\nreturn $response;", 
            "title": "Templated Middleware"
        }, 
        {
            "location": "/features/template/middleware/#templated-middleware", 
            "text": "The primary use case for templating is within middleware, to provide templated\nresponses. To do this, you will:   Inject an instance of  Zend\\Expressive\\Template\\TemplateRendererInterface  into your\n  middleware.  Potentially add paths to the templating instance.  Render a template.  Add the results of rendering to your response.", 
            "title": "Templated Middleware"
        }, 
        {
            "location": "/features/template/middleware/#injecting-a-templaterendererinterface", 
            "text": "We encourage the use of dependency injection. As such, we recommend writing your\nmiddleware to accept the  TemplateRendererInterface  via either the constructor or a\nsetter. As an example:  namespace Acme\\Blog;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this- templateRenderer = $renderer;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        // ...\n    }\n}  This will necessitate having a factory for your middleware:  namespace Acme\\Blog\\Container;\n\nuse Acme\\Blog\\EntryMiddleware;\nuse Interop\\Container\\ContainerInterface;\n\nclass EntryMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new EntryMiddleware(\n            $container- get('Zend\\Expressive\\Template\\TemplateRendererInterface')\n        );\n    }\n}  And, of course, you'll need to tell your container to use the factory; see the container documentation  for more information on how you\nmight accomplish that.", 
            "title": "Injecting a TemplateRendererInterface"
        }, 
        {
            "location": "/features/template/middleware/#consuming-templates", 
            "text": "Now that we have the templating engine injected into our middleware, we can\nconsume it. Most often, we will want to render a template, optionally with\nsubstitutions to pass to it. This will typically look like the following:  ?php\nnamespace Acme\\Blog;\n\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass EntryMiddleware\n{\n    private $templateRenderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this- templateRenderer = $renderer;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        // do some work...\n        return new HtmlResponse(\n            $this- templateRenderer- render('blog::entry', [\n                'entry' =  $entry,\n            ])\n        );\n    }\n}  Alternately, you can write to the composed response:  $response- getBody()- write($this- templateRenderer- render('blog::entry', [\n    'entry' =  $entry,\n]));\nreturn $response;", 
            "title": "Consuming templates"
        }, 
        {
            "location": "/features/template/plates/", 
            "text": "Using Plates\n\n\nPlates\n is a native PHP template system\nmaintained by \nThe League of Extraordinary Packages\n.\nit provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Plates via\n\nZend\\Expressive\\Plates\\PlatesRenderer\n.\n\n\nInstalling Plates\n\n\nTo use the Plates wrapper, you must install the Plates integration:\n\n\n$ composer require zendframework/zend-expressive-platesrenderer\n\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Plates\\PlatesRenderer\n will create\nan instance of the Plates engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();\n\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Plates\\PlatesRenderer\n constructor:\n\n\nuse League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates-\naddFolder('error', 'templates/error/');\n$plates-\nloadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new PlatesRenderer($plates);", 
            "title": "Using Plates"
        }, 
        {
            "location": "/features/template/plates/#using-plates", 
            "text": "Plates  is a native PHP template system\nmaintained by  The League of Extraordinary Packages .\nit provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Plates via Zend\\Expressive\\Plates\\PlatesRenderer .", 
            "title": "Using Plates"
        }, 
        {
            "location": "/features/template/plates/#installing-plates", 
            "text": "To use the Plates wrapper, you must install the Plates integration:  $ composer require zendframework/zend-expressive-platesrenderer", 
            "title": "Installing Plates"
        }, 
        {
            "location": "/features/template/plates/#using-the-wrapper", 
            "text": "If instantiated without arguments,  Zend\\Expressive\\Plates\\PlatesRenderer  will create\nan instance of the Plates engine, which it will then proxy to.  use Zend\\Expressive\\Plates\\PlatesRenderer;\n\n$renderer = new PlatesRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Plates\\PlatesRenderer  constructor:  use League\\Plates\\Engine as PlatesEngine;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\n\n// Create the engine instance:\n$plates = new PlatesEngine();\n\n// Configure it:\n$plates- addFolder('error', 'templates/error/');\n$plates- loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new PlatesRenderer($plates);", 
            "title": "Using the wrapper"
        }, 
        {
            "location": "/features/template/twig/", 
            "text": "Using Twig\n\n\nTwig\n is a template language and engine provided\nas a standalone component by SensioLabs. It provides:\n\n\n\n\nLayout facilities.\n\n\nTemplate inheritance.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for Twig via\n\nZend\\Expressive\\Twig\\TwigRenderer\n.\n\n\nInstalling Twig\n\n\nTo use the Twig wrapper, you must first install the Twig integration:\n\n\n$ composer require zendframework/zend-expressive-twigrenderer\n\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\Twig\\TwigRenderer\n will create\nan instance of the Twig engine, which it will then proxy to.\n\n\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();\n\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\Twig\\TwigRenderer\n constructor:\n\n\nuse Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig-\naddExtension(new CustomExtension());\n$twig-\nloadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);\n\n\n\n\nIncluded extensions and functions\n\n\nThe included Twig extension adds support for url generation. The extension is\nautomatically activated if the \nUrlHelper\n and\n\nServerUrlHelper\n are registered with the\ncontainer.\n\n\nThe following template functions are exposed:\n\n\n\n\npath\n: Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.\n\n\n\n\n{{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3\n\n\n\n\n\n\nurl\n: Render the absolute url for a given route and parameters. If there is\n  no route, it returns the current url.\n\n\n\n\n{{ url('article_show', {'slug': 'article.slug'}) }}\nGenerates: http://example.com/article/article.slug\n\n\n\n\n\n\nabsolute_url\n: Render the absolute url from a given path. If the path is\n  empty, it returns the current url.\n\n\n\n\n{{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something\n\n\n\n\n\n\nasset\n Render an (optionally versioned) asset url.\n\n\n\n\n{{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3\n\n\n\n\nTo get the absolute url for an asset:\n\n\n{{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3\n\n\n\n\nConfiguration\n\n\nThe following details configuration specific to Twig, as consumed by the\n\nTwigRendererFactory\n:\n\n\nreturn [\n    'templates' =\n [\n        'extension' =\n 'file extension used by templates; defaults to html.twig',\n        'paths' =\n [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' =\n [\n        'cache_dir' =\n 'path to cached templates',\n        'assets_url' =\n 'base URL for assets',\n        'assets_version' =\n 'base version for assets',\n        'extensions' =\n [\n            // extension service names or instances\n        ],\n        'globals' =\n [\n            // Global variables passed to twig templates\n            'ga_tracking' =\n 'UA-XXXXX-X'\n        ],\n    ],\n];", 
            "title": "Using Twig"
        }, 
        {
            "location": "/features/template/twig/#using-twig", 
            "text": "Twig  is a template language and engine provided\nas a standalone component by SensioLabs. It provides:   Layout facilities.  Template inheritance.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for Twig via Zend\\Expressive\\Twig\\TwigRenderer .", 
            "title": "Using Twig"
        }, 
        {
            "location": "/features/template/twig/#installing-twig", 
            "text": "To use the Twig wrapper, you must first install the Twig integration:  $ composer require zendframework/zend-expressive-twigrenderer", 
            "title": "Installing Twig"
        }, 
        {
            "location": "/features/template/twig/#using-the-wrapper", 
            "text": "If instantiated without arguments,  Zend\\Expressive\\Twig\\TwigRenderer  will create\nan instance of the Twig engine, which it will then proxy to.  use Zend\\Expressive\\Twig\\TwigRenderer;\n\n$renderer = new TwigRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\Twig\\TwigRenderer  constructor:  use Twig_Environment;\nuse Twig_Loader_Array;\nuse Zend\\Expressive\\Twig\\TwigRenderer;\n\n// Create the engine instance:\n$loader = new Twig_Loader_Array(include 'config/templates.php');\n$twig = new Twig_Environment($loader);\n\n// Configure it:\n$twig- addExtension(new CustomExtension());\n$twig- loadExtension(new CustomExtension();\n\n// Inject:\n$renderer = new TwigRenderer($twig);", 
            "title": "Using the wrapper"
        }, 
        {
            "location": "/features/template/twig/#included-extensions-and-functions", 
            "text": "The included Twig extension adds support for url generation. The extension is\nautomatically activated if the  UrlHelper  and ServerUrlHelper  are registered with the\ncontainer.  The following template functions are exposed:   path : Render the relative path for a given route and parameters. If there\n  is no route, it returns the current path.   {{ path('article_show', {'id': '3'}) }}\nGenerates: /article/3   url : Render the absolute url for a given route and parameters. If there is\n  no route, it returns the current url.   {{ url('article_show', {'slug': 'article.slug'}) }}\nGenerates: http://example.com/article/article.slug   absolute_url : Render the absolute url from a given path. If the path is\n  empty, it returns the current url.   {{ absolute_url('path/to/something') }}\nGenerates: http://example.com/path/to/something   asset  Render an (optionally versioned) asset url.   {{ asset('path/to/asset/name.ext', version=3) }}\nGenerates: path/to/asset/name.ext?v=3  To get the absolute url for an asset:  {{ absolute_url(asset('path/to/asset/name.ext', version=3)) }}\nGenerates: http://example.com/path/to/asset/name.ext?v=3", 
            "title": "Included extensions and functions"
        }, 
        {
            "location": "/features/template/twig/#configuration", 
            "text": "The following details configuration specific to Twig, as consumed by the TwigRendererFactory :  return [\n    'templates' =  [\n        'extension' =  'file extension used by templates; defaults to html.twig',\n        'paths' =  [\n            // namespace / path pairs\n            //\n            // Numeric namespaces imply the default/main namespace. Paths may be\n            // strings or arrays of string paths to associate with the namespace.\n        ],\n    ],\n    'twig' =  [\n        'cache_dir' =  'path to cached templates',\n        'assets_url' =  'base URL for assets',\n        'assets_version' =  'base version for assets',\n        'extensions' =  [\n            // extension service names or instances\n        ],\n        'globals' =  [\n            // Global variables passed to twig templates\n            'ga_tracking' =  'UA-XXXXX-X'\n        ],\n    ],\n];", 
            "title": "Configuration"
        }, 
        {
            "location": "/features/template/zend-view/", 
            "text": "Using zend-view\n\n\nzend-view\n provides a native PHP\ntemplate system via its \nPhpRenderer\n, and is maintained by Zend Framework. It\nprovides:\n\n\n\n\nLayout facilities.\n\n\nHelpers for escaping, and the ability to provide custom helper extensions.\n\n\n\n\nWe provide a \nTemplateRendererInterface\n wrapper for zend-view's\n\nPhpRenderer\n via \nZend\\Expressive\\ZendView\\ZendViewRenderer\n.\n\n\nInstalling zend-view\n\n\nTo use the zend-view wrapper, you must first install the zend-view integration:\n\n\n$ composer require zendframework/zend-expressive-zendviewrenderer\n\n\n\n\nUsing the wrapper\n\n\nIf instantiated without arguments, \nZend\\Expressive\\ZendView\\ZendViewRenderer\n will create\nan instance of the \nPhpRenderer\n, which it will then proxy to.\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();\n\n\n\n\nAlternately, you can instantiate and configure the engine yourself, and pass it\nto the \nZend\\Expressive\\ZendView\\ZendViewRenderer\n constructor:\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver-\nattach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver-\nattach(\n    (new Resolver\\TemplatePathStack())\n    -\nsetPaths(include 'config/template_paths.php')\n);\n$renderer-\nsetResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);\n\n\n\n\n\n\nNamespaced path resolving\n\n\nExpressive defines a custom zend-view resolver,\n\nZend\\Expressive\\ZendView\\NamespacedPathStackResolver\n. This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the \nnamespace::template\n notation\nrequired of \nTemplateRendererInterface\n implementations.\n\n\nThe \nZendView\n adapter ensures that:\n\n\n\n\nAn \nAggregateResolver\n is registered with the renderer. If the registered\n  resolver is not an \nAggregateResolver\n, it creates one and adds the original\n  resolver to it.\n\n\nA \nNamespacedPathStackResolver\n is registered with the \nAggregateResolver\n, at\n  a low priority (0), ensuring attempts to resolve hit it later.\n\n\n\n\nWith resolvers such as the \nTemplateMapResolver\n, you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!\n\n\n\n\nLayouts\n\n\nUnlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:\n\n\n\n\nYou may pass a layout template name or \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout as the second argument to the constructor.\n\n\nYou may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a \nZend\\View\\Model\\ModelInterface\n\n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.\n\n\n\n\nIn each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.\n\n\nLayout name passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');\n\n\n\n\nLayout view model passed to constructor\n\n\nuse Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' =\n 'utf-8',\n    'cssPath'  =\n '/css/prod/',\n]);\n$layout-\nsetTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);\n\n\n\n\nProvide a layout name when rendering\n\n\n$content = $renderer-\nrender('blog/entry', [\n    'layout' =\n 'layout::blog',\n    'entry'  =\n $entry,\n]);\n\n\n\n\nProvide a layout view model when rendering\n\n\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' =\n 'utf-8',\n    'cssPath'  =\n '/css/blog/',\n]);\n$layout-\nsetTemplate('layout::layout');\n\n$content = $renderer-\nrender('blog/entry', [\n    'layout' =\n $layout,\n    'entry'  =\n $entry,\n]);\n\n\n\n\nHelpers\n\n\nExpressive provides overrides of specific view helpers in order to better\nintegrate with PSR-7. These include:\n\n\n\n\nZend\\Expressive\\ZendView\\UrlHelper\n. This helper consumes the\n  application's \nZend\\Expressive\\Router\\RouterInterface\n instance in order\n  to generate URIs. It's signature is:\n  \nurl($routeName, array $substitutions = [])\n\n\nZend\\Expressive\\ZendView\\ServerUrlHelper\n. This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  It's signature is: \nserverUrl($path = null)\n.\n\n\n\n\nTo use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:\n\n\n$serverUrlHelper-\nsetUri($request-\ngetUri());\n\n\n\n\nWe recommend doing this within a pre-pipeline middleware.\n\n\nRecommendations\n\n\nWe recommend the following practices when using the zend-view adapter:\n\n\n\n\nIf using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.\n\n\nWhile we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.", 
            "title": "Using zend-view"
        }, 
        {
            "location": "/features/template/zend-view/#using-zend-view", 
            "text": "zend-view  provides a native PHP\ntemplate system via its  PhpRenderer , and is maintained by Zend Framework. It\nprovides:   Layout facilities.  Helpers for escaping, and the ability to provide custom helper extensions.   We provide a  TemplateRendererInterface  wrapper for zend-view's PhpRenderer  via  Zend\\Expressive\\ZendView\\ZendViewRenderer .", 
            "title": "Using zend-view"
        }, 
        {
            "location": "/features/template/zend-view/#installing-zend-view", 
            "text": "To use the zend-view wrapper, you must first install the zend-view integration:  $ composer require zendframework/zend-expressive-zendviewrenderer", 
            "title": "Installing zend-view"
        }, 
        {
            "location": "/features/template/zend-view/#using-the-wrapper", 
            "text": "If instantiated without arguments,  Zend\\Expressive\\ZendView\\ZendViewRenderer  will create\nan instance of the  PhpRenderer , which it will then proxy to.  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n$renderer = new ZendViewRenderer();  Alternately, you can instantiate and configure the engine yourself, and pass it\nto the  Zend\\Expressive\\ZendView\\ZendViewRenderer  constructor:  use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Renderer\\PhpRenderer;\nuse Zend\\View\\Resolver;\n\n// Create the engine instance:\n$renderer = new PhpRenderer();\n\n// Configure it:\n$resolver = new Resolver\\AggregateResolver();\n$resolver- attach(\n    new Resolver\\TemplateMapResolver(include 'config/templates.php'),\n    100\n);\n$resolver- attach(\n    (new Resolver\\TemplatePathStack())\n    - setPaths(include 'config/template_paths.php')\n);\n$renderer- setResolver($resolver);\n\n// Inject:\n$renderer = new ZendViewRenderer($renderer);", 
            "title": "Using the wrapper"
        }, 
        {
            "location": "/features/template/zend-view/#namespaced-path-resolving", 
            "text": "Expressive defines a custom zend-view resolver, Zend\\Expressive\\ZendView\\NamespacedPathStackResolver . This resolver\nprovides the ability to segregate paths by namespace, and later resolve a\ntemplate according to the namespace, using the  namespace::template  notation\nrequired of  TemplateRendererInterface  implementations.  The  ZendView  adapter ensures that:   An  AggregateResolver  is registered with the renderer. If the registered\n  resolver is not an  AggregateResolver , it creates one and adds the original\n  resolver to it.  A  NamespacedPathStackResolver  is registered with the  AggregateResolver , at\n  a low priority (0), ensuring attempts to resolve hit it later.   With resolvers such as the  TemplateMapResolver , you can also resolve\nnamespaced templates, mapping them directly to the template on the filesystem\nthat matches; adding such a resolver can be a nice performance boost!", 
            "title": "Namespaced path resolving"
        }, 
        {
            "location": "/features/template/zend-view/#layouts", 
            "text": "Unlike the other supported template engines, zend-view does not support layouts\nout-of-the-box. Expressive abstracts this fact away, providing two facilities\nfor doing so:   You may pass a layout template name or  Zend\\View\\Model\\ModelInterface \n  instance representing the layout as the second argument to the constructor.  You may pass a \"layout\" parameter during rendering, with a value of either a\n  layout template name or a  Zend\\View\\Model\\ModelInterface \n  instance representing the layout. Passing a layout this way will override any\n  layout provided to the constructor.   In each case, the zend-view implementation will do a depth-first, recursive\nrender in order to provide content within the selected layout.", 
            "title": "Layouts"
        }, 
        {
            "location": "/features/template/zend-view/#layout-name-passed-to-constructor", 
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\n\n// Create the engine instance with a layout name:\n$renderer = new ZendViewRenderer(null, 'layout::layout');", 
            "title": "Layout name passed to constructor"
        }, 
        {
            "location": "/features/template/zend-view/#layout-view-model-passed-to-constructor", 
            "text": "use Zend\\Expressive\\ZendView\\ZendViewRenderer;\nuse Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' =  'utf-8',\n    'cssPath'  =  '/css/prod/',\n]);\n$layout- setTemplate('layout::layout');\n\n// Create the engine instance with the layout:\n$renderer = new ZendViewRenderer(null, $layout);", 
            "title": "Layout view model passed to constructor"
        }, 
        {
            "location": "/features/template/zend-view/#provide-a-layout-name-when-rendering", 
            "text": "$content = $renderer- render('blog/entry', [\n    'layout' =  'layout::blog',\n    'entry'  =  $entry,\n]);", 
            "title": "Provide a layout name when rendering"
        }, 
        {
            "location": "/features/template/zend-view/#provide-a-layout-view-model-when-rendering", 
            "text": "use Zend\\View\\Model\\ViewModel;\n\n// Create the layout view model:\n$layout = new ViewModel([\n    'encoding' =  'utf-8',\n    'cssPath'  =  '/css/blog/',\n]);\n$layout- setTemplate('layout::layout');\n\n$content = $renderer- render('blog/entry', [\n    'layout' =  $layout,\n    'entry'  =  $entry,\n]);", 
            "title": "Provide a layout view model when rendering"
        }, 
        {
            "location": "/features/template/zend-view/#helpers", 
            "text": "Expressive provides overrides of specific view helpers in order to better\nintegrate with PSR-7. These include:   Zend\\Expressive\\ZendView\\UrlHelper . This helper consumes the\n  application's  Zend\\Expressive\\Router\\RouterInterface  instance in order\n  to generate URIs. It's signature is:\n   url($routeName, array $substitutions = [])  Zend\\Expressive\\ZendView\\ServerUrlHelper . This helper consumes the\n  URI from the application's request in order to provide fully qualified URIs.\n  It's signature is:  serverUrl($path = null) .   To use this particular helper, you will need to inject it with the request URI\n  somewhere within your application:  $serverUrlHelper- setUri($request- getUri());  We recommend doing this within a pre-pipeline middleware.", 
            "title": "Helpers"
        }, 
        {
            "location": "/features/template/zend-view/#recommendations", 
            "text": "We recommend the following practices when using the zend-view adapter:   If using a layout, create a factory to return the layout view model as a\n  service; this allows you to inject it into middleware and add variables to it.  While we support passing the layout as a rendering parameter, be aware that if\n  you change engines, this may not be supported.", 
            "title": "Recommendations"
        }, 
        {
            "location": "/features/error-handling/", 
            "text": "Error Handling\n\n\nExpressive provides error handling out of the box, via zend-stratigility's \nFinalHandler\nimplementation\n.\nThis pseudo-middleware is executed in the following conditions:\n\n\n\n\nIf the middleware stack is exhausted, and no middleware has returned a response.\n\n\nIf an error has been passed via \n$next()\n, but not handled by any error middleware.\n\n\n\n\nThe \nFinalHandler\n essentially tries to recover gracefully. In the case that no error was passed, it\ndoes the following:\n\n\n\n\nIf the response passed to it differs from the response provided at initialization, it will return\n  the response directly; the assumption is that some middleware along the way called \n$next()\n\n  with a new response.\n\n\nIf the response instances are identical, it checks to see if the body size has changed; if it has,\n  the assumption is that a middleware at some point has written to the response body.\n\n\nAt this point, it assumes no middleware was able to handle the request, and creates a 404\n  response, indicating \"Not Found.\"\n\n\n\n\nIn the event that an error \nwas\n passed, it does the following:\n\n\n\n\nIf \n$error\n is not an exception, it will use the response status if it already indicates an error\n  (ie., \n= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase.\n\n\nIf \n$error\n \nis\n an exception, it will use the exception status if it already indicates an error\n  (ie., \n= 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase. If the \nFinalHandler\n was initialized with an option indicating that it is in\n  development mode, it writes the exception stack trace to the response body.\n\n\n\n\nThis workflow stays the same throughout zend-expressive. But sometimes, it's just not enough.\n\n\nTemplated Errors\n\n\nYou'll typically want to provide error messages in your site template. To do so, we provide\n\nZend\\Expressive\\TemplatedErrorHandler\n. This class is similar to the \nFinalHandler\n, but accepts,\noptionally, a \nZend\\Expressive\\Template\\TemplateRendererInterface\n instance, and template names to use for\n404 and general error conditions. This makes it a good choice for use in production.\n\n\nFirst, of course, you'll need to select a templating system and ensure you have\nthe appropriate dependencies installed; see the \ntemplating documentation\n\nfor information on what we support and how to install supported systems.\n\n\nOnce you have selected your templating system, you can setup the templated error\nhandler.\n\n\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\TemplatedErrorHandler;\n\n$plates = new PlatesRenderer();\n$plates-\naddPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new TemplatedErrorHandler($plates, 'error::404', 'error::500');\n\n$app = new Application($router, $container, $finalHandler);\n\n\n\n\nThe above will use the templates \nerror::404\n and \nerror::500\n for 404 and general errors,\nrespectively, rendering them using our Plates template adapter.\n\n\nYou can also use the \nTemplatedErrorHandler\n as a substitute for the \nFinalHandler\n, without using\ntemplated capabilities, by omitting the \nTemplateRendererInterface\n instance when instantiating it. In this\ncase, the response message bodies will be empty, though the response status will reflect the error.\n\n\nSee the section titled \"Container Factories and Configuration\", below, for techniques on configuring\nthe \nTemplatedErrorHandler\n as your final handler within a container-based application.\n\n\nWhoops\n\n\nwhoops\n is a library for providing a more usable UI around\nexceptions and PHP errors. We provide integration with this library through\n\nZend\\Express\\WhoopsErrorHandler\n. This error handler derives from the \nTemplatedErrorHandler\n, and\nuses its features for 404 status and non-exception errors. For exceptions, however, it will return\nthe whoops output. As such, it is a good choice for use in development.\n\n\nTo use it, you must first install whoops:\n\n\n$ composer require filp/whoops\n\n\n\n\nThen you will need to provide the error handler a whoops runtime instance, as well as a\n\nWhoops\\Handler\\PrettyPageHandler\n instance. You can also optionally provide a \nTemplateRendererInterface\n\ninstance and template names, just as you would for a \nTemplatedErrorHandler\n.\n\n\nuse Whoops\\Handler\\PrettyPageHandler;\nuse Whoops\\Run as Whoops;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\WhoopsErrorHandler;\n\n$handler = new PrettyPageHandler();\n\n$whoops = new Whoops;\n$whoops-\nwriteToOutput(false);\n$whoops-\nallowQuit(false);\n$whoops-\npushHandler($handler);\n\n$plates = new PlatesRenderer();\n$plates-\naddPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new WhoopsErrorHandler(\n    $whoops,\n    $handler,\n    $plates,\n    'error::404',\n    'error::500'\n);\n\n$app = new Application($router, $container, $finalHandler);\n\n// Register Whoops just before running the application, as otherwise it can\n// swallow bootstrap errors. \n$whoops-\nregister();\n$app-\nrun();\n\n\n\n\nThe calls to \nwriteToOutput(false)\n, \nallowQuit(false)\n, and \nregister()\n must be made to guarantee\nwhoops will interoperate well with zend-expressive.\n\n\nYou can add more handlers if desired.\n\n\nInternally, when an exception is discovered, zend-expressive adds some data to the whoops output,\nprimarily around the request information (URI, HTTP request method, route match attributes, etc.).\n\n\nSee the next section for techniques on configuring the \nWhoopsErrorHandler\n as your final handler\nwithin a container-based application.\n\n\nContainer Factories and Configuration\n\n\nThe above may feel like a bit much when creating your application. As such, we provide several\nfactories that work with \ncontainer-interop\n-compatible\ncontainer implementations to simplify setup.\n\n\nIn each case, you should register the selected error handler's factory as the service\n\nZend\\Expressive\\FinalHandler\n.\n\n\n\n\nFor the \nTemplatedErrorHandler\n, use \nZend\\Expressive\\Container\\TemplatedErrorHandlerFactory\n.\n\n\nFor the \nWhoopsErrorHandler\n, use \nZend\\Expressive\\Container\\WhoopsErrorHandlerFactory\n.", 
            "title": "Error Handling"
        }, 
        {
            "location": "/features/error-handling/#error-handling", 
            "text": "Expressive provides error handling out of the box, via zend-stratigility's  FinalHandler\nimplementation .\nThis pseudo-middleware is executed in the following conditions:   If the middleware stack is exhausted, and no middleware has returned a response.  If an error has been passed via  $next() , but not handled by any error middleware.   The  FinalHandler  essentially tries to recover gracefully. In the case that no error was passed, it\ndoes the following:   If the response passed to it differs from the response provided at initialization, it will return\n  the response directly; the assumption is that some middleware along the way called  $next() \n  with a new response.  If the response instances are identical, it checks to see if the body size has changed; if it has,\n  the assumption is that a middleware at some point has written to the response body.  At this point, it assumes no middleware was able to handle the request, and creates a 404\n  response, indicating \"Not Found.\"   In the event that an error  was  passed, it does the following:   If  $error  is not an exception, it will use the response status if it already indicates an error\n  (ie.,  = 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase.  If  $error   is  an exception, it will use the exception status if it already indicates an error\n  (ie.,  = 400 status), or will use a 500 status, and return the response directly with the\n  reason phrase. If the  FinalHandler  was initialized with an option indicating that it is in\n  development mode, it writes the exception stack trace to the response body.   This workflow stays the same throughout zend-expressive. But sometimes, it's just not enough.", 
            "title": "Error Handling"
        }, 
        {
            "location": "/features/error-handling/#templated-errors", 
            "text": "You'll typically want to provide error messages in your site template. To do so, we provide Zend\\Expressive\\TemplatedErrorHandler . This class is similar to the  FinalHandler , but accepts,\noptionally, a  Zend\\Expressive\\Template\\TemplateRendererInterface  instance, and template names to use for\n404 and general error conditions. This makes it a good choice for use in production.  First, of course, you'll need to select a templating system and ensure you have\nthe appropriate dependencies installed; see the  templating documentation \nfor information on what we support and how to install supported systems.  Once you have selected your templating system, you can setup the templated error\nhandler.  use Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\TemplatedErrorHandler;\n\n$plates = new PlatesRenderer();\n$plates- addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new TemplatedErrorHandler($plates, 'error::404', 'error::500');\n\n$app = new Application($router, $container, $finalHandler);  The above will use the templates  error::404  and  error::500  for 404 and general errors,\nrespectively, rendering them using our Plates template adapter.  You can also use the  TemplatedErrorHandler  as a substitute for the  FinalHandler , without using\ntemplated capabilities, by omitting the  TemplateRendererInterface  instance when instantiating it. In this\ncase, the response message bodies will be empty, though the response status will reflect the error.  See the section titled \"Container Factories and Configuration\", below, for techniques on configuring\nthe  TemplatedErrorHandler  as your final handler within a container-based application.", 
            "title": "Templated Errors"
        }, 
        {
            "location": "/features/error-handling/#whoops", 
            "text": "whoops  is a library for providing a more usable UI around\nexceptions and PHP errors. We provide integration with this library through Zend\\Express\\WhoopsErrorHandler . This error handler derives from the  TemplatedErrorHandler , and\nuses its features for 404 status and non-exception errors. For exceptions, however, it will return\nthe whoops output. As such, it is a good choice for use in development.  To use it, you must first install whoops:  $ composer require filp/whoops  Then you will need to provide the error handler a whoops runtime instance, as well as a Whoops\\Handler\\PrettyPageHandler  instance. You can also optionally provide a  TemplateRendererInterface \ninstance and template names, just as you would for a  TemplatedErrorHandler .  use Whoops\\Handler\\PrettyPageHandler;\nuse Whoops\\Run as Whoops;\nuse Zend\\Expressive\\Application;\nuse Zend\\Expressive\\Plates\\PlatesRenderer;\nuse Zend\\Expressive\\WhoopsErrorHandler;\n\n$handler = new PrettyPageHandler();\n\n$whoops = new Whoops;\n$whoops- writeToOutput(false);\n$whoops- allowQuit(false);\n$whoops- pushHandler($handler);\n\n$plates = new PlatesRenderer();\n$plates- addPath(__DIR__ . '/templates/error', 'error');\n$finalHandler = new WhoopsErrorHandler(\n    $whoops,\n    $handler,\n    $plates,\n    'error::404',\n    'error::500'\n);\n\n$app = new Application($router, $container, $finalHandler);\n\n// Register Whoops just before running the application, as otherwise it can\n// swallow bootstrap errors. \n$whoops- register();\n$app- run();  The calls to  writeToOutput(false) ,  allowQuit(false) , and  register()  must be made to guarantee\nwhoops will interoperate well with zend-expressive.  You can add more handlers if desired.  Internally, when an exception is discovered, zend-expressive adds some data to the whoops output,\nprimarily around the request information (URI, HTTP request method, route match attributes, etc.).  See the next section for techniques on configuring the  WhoopsErrorHandler  as your final handler\nwithin a container-based application.", 
            "title": "Whoops"
        }, 
        {
            "location": "/features/error-handling/#container-factories-and-configuration", 
            "text": "The above may feel like a bit much when creating your application. As such, we provide several\nfactories that work with  container-interop -compatible\ncontainer implementations to simplify setup.  In each case, you should register the selected error handler's factory as the service Zend\\Expressive\\FinalHandler .   For the  TemplatedErrorHandler , use  Zend\\Expressive\\Container\\TemplatedErrorHandlerFactory .  For the  WhoopsErrorHandler , use  Zend\\Expressive\\Container\\WhoopsErrorHandlerFactory .", 
            "title": "Container Factories and Configuration"
        }, 
        {
            "location": "/features/helpers/intro/", 
            "text": "Helpers\n\n\nSome tasks and features will be common to many if not all applications. For\nthose, Expressive provides \nhelpers\n. These are typically utility classes that\nmay integrate features or simply provide standalone benefits.\n\n\nCurrently, these include:\n\n\n\n\nUrlHelper\n\n\nServerUrlHelper\n\n\n\n\nInstallation\n\n\nIf you started your project using the Expressive skeleton package, the helpers\nare already installed.\n\n\nIf not, you can install them as follows:\n\n\n$ composer require zendframework/zend-expressive-helpers", 
            "title": "Introduction"
        }, 
        {
            "location": "/features/helpers/intro/#helpers", 
            "text": "Some tasks and features will be common to many if not all applications. For\nthose, Expressive provides  helpers . These are typically utility classes that\nmay integrate features or simply provide standalone benefits.  Currently, these include:   UrlHelper  ServerUrlHelper", 
            "title": "Helpers"
        }, 
        {
            "location": "/features/helpers/intro/#installation", 
            "text": "If you started your project using the Expressive skeleton package, the helpers\nare already installed.  If not, you can install them as follows:  $ composer require zendframework/zend-expressive-helpers", 
            "title": "Installation"
        }, 
        {
            "location": "/features/helpers/url-helper/", 
            "text": "UrlHelper\n\n\nZend\\Expressive\\Helper\\UrlHelper\n provides the ability to generate a URI path\nbased on a given route defined in the \nZend\\Expressive\\Router\\RouterInterface\n.\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper-\ngenerate('resource', ['id' =\n 'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' =\n 'sha1']);\n\n\n\n\nThe signature for both is:\n\n\nfunction ($routeName, array $params = []) : string\n\n\n\n\nWhere:\n\n\n\n\n$routeName\n is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.\n\n\n$params\n is an array of substitutions to use for the provided route, with the\n  following behavior:\n\n\nIf a \nRouteResult\n is composed in the helper, and the \n$routeName\n matches\n    it, the provided \n$params\n will be merged with any matched parameters, with\n    those provided taking precedence.\n\n\nIf a \nRouteResult\n is not composed, or if the composed result does not match\n    the provided \n$routeName\n, then only the \n$params\n provided will be used \n    for substitutions.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n matches the currently\n    matched route, then any matched parameters found will be used.\n    parameters found will be used.\n\n\nIf no \n$params\n are provided, and the \n$routeName\n does not match the\n    currently matched route, or if no route result is present, then no\n    substitutions will be made.\n\n\n\n\nEach method will raise an exception if:\n\n\n\n\nNo \n$routeName\n is provided, and no \nRouteResult\n is composed.\n\n\nNo \n$routeName\n is provided, a \nRouteResult\n is composed, but that result\n  represents a matching failure.\n\n\nThe given \n$routeName\n is not defined in the router.\n\n\n\n\nCreating an instance\n\n\nIn order to use the helper, you will need to instantiate it with the current\n\nRouterInterface\n. The factory \nZend\\Expressive\\Helper\\UrlHelperFactory\n has\nbeen provided for this purpose, and can be used trivially with most\ndependency injection containers implementing container-interop. Additionally,\nit is most useful when injected with the current results of routing, which\nrequires registering middleware with the application that can inject the route\nresult. The following steps should be followed to register and configure the helper:\n\n\n\n\nRegister the \nUrlHelper\n as a service in your container, using the provided\n  factory.\n\n\nRegister the \nUrlHelperMiddleware\n as a service in your container, using the\n  provided factory.\n\n\nRegister the \nUrlHelperMiddleware\n as pipeline middleware, immediately\n  following the routing middleware.\n\n\n\n\nRegistering the helper service\n\n\nThe following examples demonstrate programmatic registration of the \nUrlHelper\n\nservice in your selected dependency injection container.\n\n\nuse Zend\\Expressive\\Helper\\UrlHelper;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\n\n// zend-servicemanager:\n$services-\nsetFactory(UrlHelper::class, UrlHelperFactory::class);\n\n// Pimple:\n$pimple[UrlHelper::class] = function ($container) {\n    $factory = new UrlHelperFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container-\nset(UrlHelperFactory::class, $container-\nlazyNew(UrlHelperFactory::class));\n$container-\nset(\n    UrlHelper::class,\n    $container-\nlazyGetCall(UrlHelperFactory::class, '__invoke', $container)\n);\n\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn ['dependencies' =\n [\n    'factories' =\n [\n        UrlHelper::class =\n UrlHelperFactory::class,\n    ],\n]]\n\n\n\n\n\n\nUrlHelperFactory requires RouterInterface\n\n\nThe factory requires that a service named \nZend\\Expressive\\Router\\RouterInterface\n is present,\nand will raise an exception if the service is not found.\n\n\n\n\nRegistering the pipeline middleware\n\n\nTo register the \nUrlHelperMiddleware\n as pipeline middleware following the\nrouting middleware:\n\n\nuse Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app-\npipeRoutingMiddleware();\n$app-\npipe(UrlHelperMiddleware::class);\n$app-\npipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' =\n [\n//         /* ... */\n//         Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n//         ['middleware' =\n UrlHelperMiddleware::class],\n//         Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n//         /* ... */\n//     ],\n// ]\n//\n// Alternately, create a nested middleware pipeline for the routing, UrlHelper,\n// and dispatch middleware:\n// [\n//     'middleware_pipeline' =\n [\n//         /* ... */\n//         'routing' =\n [\n//             'middleware' =\n [\n//                 Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n//                 UrlHelperMiddleware::class\n//                 Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n//             ],\n//             'priority' =\n 1,\n//         ],\n//         /* ... */\n//     ],\n// ]\n\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn [\n    'dependencies' =\n [\n        'factories' =\n [\n            UrlHelper::class =\n UrlHelperFactory::class,\n            UrlHelperMiddleware::class =\n UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' =\n [\n        Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n        ['middleware' =\n UrlHelperMiddleware::class],\n        Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n    ],\n];\n\n// OR:\nreturn [\n    'dependencies' =\n [\n        'factories' =\n [\n            UrlHelper::class =\n UrlHelperFactory::class,\n            UrlHelperMiddleware::class =\n UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' =\n [\n        'routing' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n    ],\n];\n\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nUrlHelper\n and \nUrlHelperMiddleware\n factories are already registered for\nyou, as is the \nUrlHelperMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this-\nhelper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response-\nwithHeader(\n            'Link',\n            $this-\nhelper-\ngenerate('resource', ['id' =\n 'sha1'])\n        );\n        return $next($request, $response);\n    }\n}\n\n\n\n\nBase Path support\n\n\nIf your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the \nbase path\n, and thus be invalid. To\naccommodate this, the \nUrlHelper\n supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.\n\n\nAs an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the \nUrlHelper\n with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:\n\n\nuse Locale;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this-\nhelper = $helper;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $uri = $request-\ngetUri();\n        $path = $uri-\ngetPath();\n        if (! preg_match('#^/(?P\nlocale\n[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $next($request, $response);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this-\nhelper-\nsetBasePath($locale);\n\n        return $next(\n            $request-\nwithUri(\n                $uri-\nwithPath(substr($path, (strlen($locale) + 1)))\n            ),\n            $response\n        );\n    }\n}\n\n\n\n\n(Note: if the base path injected is not prefixed with \n/\n, the helper will add\nthe slash.)\n\n\nPaths generated by the \nUriHelper\n from this point forward will have the\ndetected language prefix.", 
            "title": "UrlHelper"
        }, 
        {
            "location": "/features/helpers/url-helper/#urlhelper", 
            "text": "Zend\\Expressive\\Helper\\UrlHelper  provides the ability to generate a URI path\nbased on a given route defined in the  Zend\\Expressive\\Router\\RouterInterface .\nIf injected with a route result, and the route being used was also the one\nmatched during routing, you can provide a subset of routing parameters, and any\nnot provided will be pulled from those matched.", 
            "title": "UrlHelper"
        }, 
        {
            "location": "/features/helpers/url-helper/#usage", 
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper- generate('resource', ['id' =  'sha1']);\n\n// is equivalent to invocation:\n$url = $helper('resource', ['id' =  'sha1']);  The signature for both is:  function ($routeName, array $params = []) : string  Where:   $routeName  is the name of a route defined in the composed router. You may\n  omit this argument if you want to generate the path for the currently matched\n  request.  $params  is an array of substitutions to use for the provided route, with the\n  following behavior:  If a  RouteResult  is composed in the helper, and the  $routeName  matches\n    it, the provided  $params  will be merged with any matched parameters, with\n    those provided taking precedence.  If a  RouteResult  is not composed, or if the composed result does not match\n    the provided  $routeName , then only the  $params  provided will be used \n    for substitutions.  If no  $params  are provided, and the  $routeName  matches the currently\n    matched route, then any matched parameters found will be used.\n    parameters found will be used.  If no  $params  are provided, and the  $routeName  does not match the\n    currently matched route, or if no route result is present, then no\n    substitutions will be made.   Each method will raise an exception if:   No  $routeName  is provided, and no  RouteResult  is composed.  No  $routeName  is provided, a  RouteResult  is composed, but that result\n  represents a matching failure.  The given  $routeName  is not defined in the router.", 
            "title": "Usage"
        }, 
        {
            "location": "/features/helpers/url-helper/#creating-an-instance", 
            "text": "In order to use the helper, you will need to instantiate it with the current RouterInterface . The factory  Zend\\Expressive\\Helper\\UrlHelperFactory  has\nbeen provided for this purpose, and can be used trivially with most\ndependency injection containers implementing container-interop. Additionally,\nit is most useful when injected with the current results of routing, which\nrequires registering middleware with the application that can inject the route\nresult. The following steps should be followed to register and configure the helper:   Register the  UrlHelper  as a service in your container, using the provided\n  factory.  Register the  UrlHelperMiddleware  as a service in your container, using the\n  provided factory.  Register the  UrlHelperMiddleware  as pipeline middleware, immediately\n  following the routing middleware.", 
            "title": "Creating an instance"
        }, 
        {
            "location": "/features/helpers/url-helper/#registering-the-helper-service", 
            "text": "The following examples demonstrate programmatic registration of the  UrlHelper \nservice in your selected dependency injection container.  use Zend\\Expressive\\Helper\\UrlHelper;\nuse Zend\\Expressive\\Helper\\UrlHelperFactory;\n\n// zend-servicemanager:\n$services- setFactory(UrlHelper::class, UrlHelperFactory::class);\n\n// Pimple:\n$pimple[UrlHelper::class] = function ($container) {\n    $factory = new UrlHelperFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container- set(UrlHelperFactory::class, $container- lazyNew(UrlHelperFactory::class));\n$container- set(\n    UrlHelper::class,\n    $container- lazyGetCall(UrlHelperFactory::class, '__invoke', $container)\n);  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return ['dependencies' =  [\n    'factories' =  [\n        UrlHelper::class =  UrlHelperFactory::class,\n    ],\n]]", 
            "title": "Registering the helper service"
        }, 
        {
            "location": "/features/helpers/url-helper/#urlhelperfactory-requires-routerinterface", 
            "text": "The factory requires that a service named  Zend\\Expressive\\Router\\RouterInterface  is present,\nand will raise an exception if the service is not found.", 
            "title": "UrlHelperFactory requires RouterInterface"
        }, 
        {
            "location": "/features/helpers/url-helper/#registering-the-pipeline-middleware", 
            "text": "To register the  UrlHelperMiddleware  as pipeline middleware following the\nrouting middleware:  use Zend\\Expressive\\Helper\\UrlHelperMiddleware;\n\n// Programmatically:\n$app- pipeRoutingMiddleware();\n$app- pipe(UrlHelperMiddleware::class);\n$app- pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' =  [\n//         /* ... */\n//         Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n//         ['middleware' =  UrlHelperMiddleware::class],\n//         Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n//         /* ... */\n//     ],\n// ]\n//\n// Alternately, create a nested middleware pipeline for the routing, UrlHelper,\n// and dispatch middleware:\n// [\n//     'middleware_pipeline' =  [\n//         /* ... */\n//         'routing' =  [\n//             'middleware' =  [\n//                 Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n//                 UrlHelperMiddleware::class\n//                 Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n//             ],\n//             'priority' =  1,\n//         ],\n//         /* ... */\n//     ],\n// ]  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return [\n    'dependencies' =  [\n        'factories' =  [\n            UrlHelper::class =  UrlHelperFactory::class,\n            UrlHelperMiddleware::class =  UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' =  [\n        Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n        ['middleware' =  UrlHelperMiddleware::class],\n        Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n    ],\n];\n\n// OR:\nreturn [\n    'dependencies' =  [\n        'factories' =  [\n            UrlHelper::class =  UrlHelperFactory::class,\n            UrlHelperMiddleware::class =  UrlHelperMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' =  [\n        'routing' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n    ],\n];", 
            "title": "Registering the pipeline middleware"
        }, 
        {
            "location": "/features/helpers/url-helper/#skeleton-configures-helpers", 
            "text": "If you started your project using the Expressive skeleton package, the UrlHelper  and  UrlHelperMiddleware  factories are already registered for\nyou, as is the  UrlHelperMiddleware  pipeline middleware.", 
            "title": "Skeleton configures helpers"
        }, 
        {
            "location": "/features/helpers/url-helper/#using-the-helper-in-middleware", 
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  use Zend\\Expressive\\Helper\\UrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this- helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response- withHeader(\n            'Link',\n            $this- helper- generate('resource', ['id' =  'sha1'])\n        );\n        return $next($request, $response);\n    }\n}", 
            "title": "Using the helper in middleware"
        }, 
        {
            "location": "/features/helpers/url-helper/#base-path-support", 
            "text": "If your application is running under a subdirectory, or if you are running\npipeline middleware that is intercepting on a subpath, the paths generated\nby the router may not reflect the  base path , and thus be invalid. To\naccommodate this, the  UrlHelper  supports injection of the base path; when\npresent, it will be prepended to the path generated by the router.  As an example, perhaps you have middleware running to intercept a language\nprefix in the URL; this middleware could then inject the  UrlHelper  with the\ndetected language, before stripping it off the request URI instance to pass on\nto the router:  use Locale;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass LocaleMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this- helper = $helper;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $uri = $request- getUri();\n        $path = $uri- getPath();\n        if (! preg_match('#^/(?P locale [a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            return $next($request, $response);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this- helper- setBasePath($locale);\n\n        return $next(\n            $request- withUri(\n                $uri- withPath(substr($path, (strlen($locale) + 1)))\n            ),\n            $response\n        );\n    }\n}  (Note: if the base path injected is not prefixed with  / , the helper will add\nthe slash.)  Paths generated by the  UriHelper  from this point forward will have the\ndetected language prefix.", 
            "title": "Base Path support"
        }, 
        {
            "location": "/features/helpers/server-url-helper/", 
            "text": "ServerUrlHelper\n\n\nZend\\Expressive\\Helper\\ServerUrlHelper\n provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent \nPsr\\Http\\Message\\UriInterface\n instance provided to it in order to\ngenerate a fully qualified URI.\n\n\nUsage\n\n\nWhen you have an instance, use either its \ngenerate()\n method, or call the\ninstance as an invokable:\n\n\n// Using the generate() method:\n$url = $helper-\ngenerate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');\n\n\n\n\nThe helper is particularly useful when used in conjunction with the\n\nUrlHelper\n, as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:\n\n\n$url = $serverUrl($url('resource', ['id' =\n 'sha1']));\n\n\n\n\nThe signature for the ServerUrlHelper \ngenerate()\n and \n__invoke()\n methods is:\n\n\nfunction ($path = null) : string\n\n\n\n\nWhere:\n\n\n\n\n$path\n, when provided, can be a string path to use to generate a URI.\n\n\n\n\nCreating an instance\n\n\nIn order to use the helper, you will need to inject it with the current\n\nUriInterface\n from the request instance. To automate this, we provide\n\nZend\\Expressive\\Helper\\ServerUrlMiddleware\n, which composes a \nServerUrl\n\ninstance, and, when invoked, injects it with the URI instance.\n\n\nAs such, you will need to:\n\n\n\n\nRegister the \nServerUrlHelper\n as a service in your container.\n\n\nRegister the \nServerUrlMiddleware\n as a service in your container.\n\n\nRegister the \nServerUrlMiddleware\n as pipeline middleware, anytime\n  before the routing middleware.\n\n\n\n\nThe following examples demonstrate registering the services.\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory;\n\n// zend-servicemanager:\n$services-\nsetInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class);\n$services-\nsetFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class);\n\n// Pimple:\n$pimple[ServerUrlHelper::class] = function ($container) {\n    return new ServerUrlHelper();\n};\n$pimple[ServerUrlMiddleware::class] = function ($container) {\n    $factory = new ServerUrlMiddlewareFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container-\nset(ServerUrlHelper::class, $container-\nlazyNew(ServerUrlHelper::class));\n$container-\nset(ServerUrlMiddlewareFactory::class, $container-\nlazyNew(ServerUrlMiddlewareFactory::class));\n$container-\nset(\n    ServerUrlMiddleware::class,\n    $container-\nlazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container)\n);\n\n\n\n\nTo register the \nServerUrlMiddleware\n as pipeline middleware anytime before the\nrouting middleware:\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app-\npipe(ServerUrlMiddleware::class);\n$app-\npipeRoutingMiddleware();\n$app-\npipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' =\n [\n//         ['middleware' =\n ServerUrlMiddleware::class, 'priority' =\n PHP_INT_MAX],\n//         /* ... */\n//     ],\n// ]\n\n\n\n\nThe following dependency configuration will work for all three when using the\nExpressive skeleton:\n\n\nreturn [\n    'dependencies' =\n [\n        'invokables' =\n [\n            ServerUrlHelper::class =\n ServerUrlHelper::class,\n        ],\n        'factories' =\n [\n            ServerUrlMiddleware::class =\n ServerUrlMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' =\n [\n        ['middleware' =\n ServerUrlMiddleware::class, 'priority' =\n PHP_INT_MAX],\n        /* ... */\n    ],\n];\n\n\n\n\n\n\nSkeleton configures helpers\n\n\nIf you started your project using the Expressive skeleton package, the\n\nServerUrlHelper\n and \nServerUrlMiddleware\n factories are already registered\nfor you, as is the \nServerUrlMiddleware\n pipeline middleware.\n\n\n\n\nUsing the helper in middleware\n\n\nCompose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:\n\n\nuse Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this-\nhelper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response-\nwithHeader(\n            'Link',\n            $this-\nhelper-\ngenerate() . '; rel=\nself\n'\n        );\n        return $next($request, $response);\n    }\n}", 
            "title": "ServerUrlHelper"
        }, 
        {
            "location": "/features/helpers/server-url-helper/#serverurlhelper", 
            "text": "Zend\\Expressive\\Helper\\ServerUrlHelper  provides the ability to generate a full\nURI by passing only the path to the helper; it will then use that path with the\ncurrent  Psr\\Http\\Message\\UriInterface  instance provided to it in order to\ngenerate a fully qualified URI.", 
            "title": "ServerUrlHelper"
        }, 
        {
            "location": "/features/helpers/server-url-helper/#usage", 
            "text": "When you have an instance, use either its  generate()  method, or call the\ninstance as an invokable:  // Using the generate() method:\n$url = $helper- generate('/foo');\n\n// is equivalent to invocation:\n$url = $helper('/foo');  The helper is particularly useful when used in conjunction with the UrlHelper , as you can then create fully qualified URIs for use\nwith headers, API hypermedia links, etc.:  $url = $serverUrl($url('resource', ['id' =  'sha1']));  The signature for the ServerUrlHelper  generate()  and  __invoke()  methods is:  function ($path = null) : string  Where:   $path , when provided, can be a string path to use to generate a URI.", 
            "title": "Usage"
        }, 
        {
            "location": "/features/helpers/server-url-helper/#creating-an-instance", 
            "text": "In order to use the helper, you will need to inject it with the current UriInterface  from the request instance. To automate this, we provide Zend\\Expressive\\Helper\\ServerUrlMiddleware , which composes a  ServerUrl \ninstance, and, when invoked, injects it with the URI instance.  As such, you will need to:   Register the  ServerUrlHelper  as a service in your container.  Register the  ServerUrlMiddleware  as a service in your container.  Register the  ServerUrlMiddleware  as pipeline middleware, anytime\n  before the routing middleware.   The following examples demonstrate registering the services.  use Zend\\Expressive\\Helper\\ServerUrlHelper;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddleware;\nuse Zend\\Expressive\\Helper\\ServerUrlMiddlewareFactory;\n\n// zend-servicemanager:\n$services- setInvokableClass(ServerUrlHelper::class, ServerUrlHelper::class);\n$services- setFactory(ServerUrlMiddleware::class, ServerUrlMiddlewareFactory::class);\n\n// Pimple:\n$pimple[ServerUrlHelper::class] = function ($container) {\n    return new ServerUrlHelper();\n};\n$pimple[ServerUrlMiddleware::class] = function ($container) {\n    $factory = new ServerUrlMiddlewareFactory();\n    return $factory($container);\n};\n\n// Aura.Di:\n$container- set(ServerUrlHelper::class, $container- lazyNew(ServerUrlHelper::class));\n$container- set(ServerUrlMiddlewareFactory::class, $container- lazyNew(ServerUrlMiddlewareFactory::class));\n$container- set(\n    ServerUrlMiddleware::class,\n    $container- lazyGetCall(ServerUrlMiddlewareFactory::class, '__invoke', $container)\n);  To register the  ServerUrlMiddleware  as pipeline middleware anytime before the\nrouting middleware:  use Zend\\Expressive\\Helper\\ServerUrlMiddleware;\n\n// Programmatically:\n$app- pipe(ServerUrlMiddleware::class);\n$app- pipeRoutingMiddleware();\n$app- pipeDispatchMiddleware();\n\n// Or use configuration:\n// [\n//     'middleware_pipeline' =  [\n//         ['middleware' =  ServerUrlMiddleware::class, 'priority' =  PHP_INT_MAX],\n//         /* ... */\n//     ],\n// ]  The following dependency configuration will work for all three when using the\nExpressive skeleton:  return [\n    'dependencies' =  [\n        'invokables' =  [\n            ServerUrlHelper::class =  ServerUrlHelper::class,\n        ],\n        'factories' =  [\n            ServerUrlMiddleware::class =  ServerUrlMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' =  [\n        ['middleware' =  ServerUrlMiddleware::class, 'priority' =  PHP_INT_MAX],\n        /* ... */\n    ],\n];", 
            "title": "Creating an instance"
        }, 
        {
            "location": "/features/helpers/server-url-helper/#skeleton-configures-helpers", 
            "text": "If you started your project using the Expressive skeleton package, the ServerUrlHelper  and  ServerUrlMiddleware  factories are already registered\nfor you, as is the  ServerUrlMiddleware  pipeline middleware.", 
            "title": "Skeleton configures helpers"
        }, 
        {
            "location": "/features/helpers/server-url-helper/#using-the-helper-in-middleware", 
            "text": "Compose the helper in your middleware (or elsewhere), and then use it to\ngenerate URI paths:  use Zend\\Expressive\\Helper\\ServerUrlHelper;\n\nclass FooMiddleware\n{\n    private $helper;\n\n    public function __construct(ServerUrlHelper $helper)\n    {\n        $this- helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $response = $response- withHeader(\n            'Link',\n            $this- helper- generate() . '; rel= self '\n        );\n        return $next($request, $response);\n    }\n}", 
            "title": "Using the helper in middleware"
        }, 
        {
            "location": "/features/helpers/body-parse/", 
            "text": "Body Parsing Middleware\n\n\nZend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware\n provides generic PSR-7\nmiddleware for parsing the request body into parameters, and returning a new\nrequest instance that composes them. The subcomponent provides a strategy\npattern around matching the request \nContent-Type\n, and then parsing it, giving\nyou a flexible approach that can grow with your accepted content types.\n\n\nBy default, this middleware will detect the following content types:\n\n\n\n\napplication/x-www-form-urlencoded\n (standard web-based forms, without file\n  uploads)\n\n\napplication/json\n, \napplication/*+json\n (JSON payloads)\n\n\n\n\nRegistering the middleware\n\n\nYou can register it manually:\n\n\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\n$app-\npipe(BodyParamsMiddleware::class);\n\n// register other middleware\n// register routing middleware\n$app-\nrun();\n\n\n\n\nor as pipeline middleware:\n\n\n// config/autoload/middleware-pipeline.global.php\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' =\n [\n        'invokables' =\n [\n            Helper\\BodyParams\\BodyParamsMiddleware::class =\n Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' =\n [\n            /* ... */\n        ],\n    ],\n    'middleware_pipeline' =\n [\n        [ 'middleware' =\n Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' =\n 100],\n        /* ... */\n        'routing' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\nAnother option is to incorporate it in route-specific middleware queues:\n\n\n// config/autoload/routes.global.php\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nreturn [\n    'dependencies' =\n [\n        'invokables' =\n [\n            Helper\\BodyParams\\BodyParamsMiddleware::class =\n Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' =\n [\n            /* ... */\n        ],\n    ],\n    'routes' =\n [\n        [\n            'name' =\n 'contact:process',\n            'path' =\n '/contact/process',\n            'middleware' =\n [\n                BodyParamsMiddleware::class,\n                Contact\\Process::class,\n            ],\n            'allowed_methods' =\n ['POST'],\n        ]\n    ],\n];\n\n\n\n\nThis latter approach has a slight advantage: the middleware will only execute\nfor routes that require the processing. While the middleware has some checks to\nensure it only triggers for HTTP methods that accept bodies, those checks are\nstill overhead that you might want to avoid; the above strategy of using the\nmiddleware only with specific routes can accomplish that.\n\n\nStrategies\n\n\nIf you want to intercept and parse other payload types, you can add \nstrategies\n\nto the middleware. Strategies implement \nZend\\Expressive\\Helper\\BodyParams\\StrategyInterface\n:\n\n\nnamespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     *\n     * @param string $contentType\n     * @return bool Whether or not the strategy matches.\n     */\n    public function match($contentType);\n\n    /**\n     * Parse the body content and return a new response.\n     *\n     * @param ServerRequestInterface $request\n     * @return ServerRequestInterface\n     */\n    public function parse(ServerRequestInterface $request);\n}\n\n\n\n\nYou then register them with the middleware using the \naddStrategy()\n method:\n\n\n$bodyParams-\naddStrategy(new MyCustomBodyParamsStrategy());\n\n\n\n\nTo automate the registration, we recommend writing a factory for the\n\nBodyParamsMiddleware\n, and replacing the \ninvokables\n registration with a\nregistration in the \nfactories\n section of the \nmiddleware-pipeline.config.php\n\nfile:\n\n\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams-\naddStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' =\n [\n        'invokables' =\n [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class =\n Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' =\n [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class =\n MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];\n\n\n\n\nRemoving the default strategies\n\n\nBy default, \nBodyParamsMiddleware\n composes the following strategies:\n\n\n\n\nZend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy\n\n\nZend\\Expressive\\Helper\\BodyParams\\JsonStrategy\n\n\n\n\nThese provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type \n\n\napplication/x-www-form-urlencoded\n \n matches first, as the middleware\ndelegates parsing to the first match.\n\n\nIf you do not want to use these default strategies, you can clear them from the\nmiddleware using \nclearStrategies()\n:\n\n\n$bodyParamsMiddleware-\nclearStrategies();\n\n\n\n\nNote: if you do this, \nall\n strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.", 
            "title": "Body Parsing Middleware"
        }, 
        {
            "location": "/features/helpers/body-parse/#body-parsing-middleware", 
            "text": "Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware  provides generic PSR-7\nmiddleware for parsing the request body into parameters, and returning a new\nrequest instance that composes them. The subcomponent provides a strategy\npattern around matching the request  Content-Type , and then parsing it, giving\nyou a flexible approach that can grow with your accepted content types.  By default, this middleware will detect the following content types:   application/x-www-form-urlencoded  (standard web-based forms, without file\n  uploads)  application/json ,  application/*+json  (JSON payloads)", 
            "title": "Body Parsing Middleware"
        }, 
        {
            "location": "/features/helpers/body-parse/#registering-the-middleware", 
            "text": "You can register it manually:  use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\n$app- pipe(BodyParamsMiddleware::class);\n\n// register other middleware\n// register routing middleware\n$app- run();  or as pipeline middleware:  // config/autoload/middleware-pipeline.global.php\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' =  [\n        'invokables' =  [\n            Helper\\BodyParams\\BodyParamsMiddleware::class =  Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' =  [\n            /* ... */\n        ],\n    ],\n    'middleware_pipeline' =  [\n        [ 'middleware' =  Helper\\BodyParams\\BodyParamsMiddleware::class, 'priority' =  100],\n        /* ... */\n        'routing' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n        /* ... */\n    ],\n];  Another option is to incorporate it in route-specific middleware queues:  // config/autoload/routes.global.php\nuse Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nreturn [\n    'dependencies' =  [\n        'invokables' =  [\n            Helper\\BodyParams\\BodyParamsMiddleware::class =  Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' =  [\n            /* ... */\n        ],\n    ],\n    'routes' =  [\n        [\n            'name' =  'contact:process',\n            'path' =  '/contact/process',\n            'middleware' =  [\n                BodyParamsMiddleware::class,\n                Contact\\Process::class,\n            ],\n            'allowed_methods' =  ['POST'],\n        ]\n    ],\n];  This latter approach has a slight advantage: the middleware will only execute\nfor routes that require the processing. While the middleware has some checks to\nensure it only triggers for HTTP methods that accept bodies, those checks are\nstill overhead that you might want to avoid; the above strategy of using the\nmiddleware only with specific routes can accomplish that.", 
            "title": "Registering the middleware"
        }, 
        {
            "location": "/features/helpers/body-parse/#strategies", 
            "text": "If you want to intercept and parse other payload types, you can add  strategies \nto the middleware. Strategies implement  Zend\\Expressive\\Helper\\BodyParams\\StrategyInterface :  namespace Zend\\Expressive\\Helper\\BodyParams;\n\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ninterface StrategyInterface\n{\n    /**\n     * Match the content type to the strategy criteria.\n     *\n     * @param string $contentType\n     * @return bool Whether or not the strategy matches.\n     */\n    public function match($contentType);\n\n    /**\n     * Parse the body content and return a new response.\n     *\n     * @param ServerRequestInterface $request\n     * @return ServerRequestInterface\n     */\n    public function parse(ServerRequestInterface $request);\n}  You then register them with the middleware using the  addStrategy()  method:  $bodyParams- addStrategy(new MyCustomBodyParamsStrategy());  To automate the registration, we recommend writing a factory for the BodyParamsMiddleware , and replacing the  invokables  registration with a\nregistration in the  factories  section of the  middleware-pipeline.config.php \nfile:  use Zend\\Expressive\\Helper\\BodyParams\\BodyParamsMiddleware;\n\nclass MyCustomBodyParamsStrategyFactory\n{\n    public function __invoke($container)\n    {\n        $bodyParams = new BodyParamsMiddleware();\n        $bodyParams- addStrategy(new MyCustomBodyParamsStrategy());\n        return $bodyParams;\n    }\n}\n\n// In config/autoload/middleware-pipeline.config.php:\nuse Zend\\Expressive\\Helper;\n\nreturn [\n    'dependencies' =  [\n        'invokables' =  [\n            // Remove this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class =  Helper\\BodyParams\\BodyParamsMiddleware::class,\n            /* ... */\n        ],\n        'factories' =  [\n            // Add this line:\n            Helper\\BodyParams\\BodyParamsMiddleware::class =  MyCustomBodyParamsStrategyFactory::class,\n            /* ... */\n        ],\n    ],\n];", 
            "title": "Strategies"
        }, 
        {
            "location": "/features/helpers/body-parse/#removing-the-default-strategies", 
            "text": "By default,  BodyParamsMiddleware  composes the following strategies:   Zend\\Expressive\\Helper\\BodyParams\\FormUrlEncodedStrategy  Zend\\Expressive\\Helper\\BodyParams\\JsonStrategy   These provide the most basic approaches to parsing the request body. They\noperate in the order they do to ensure the most common content type   application/x-www-form-urlencoded    matches first, as the middleware\ndelegates parsing to the first match.  If you do not want to use these default strategies, you can clear them from the\nmiddleware using  clearStrategies() :  $bodyParamsMiddleware- clearStrategies();  Note: if you do this,  all  strategies will be removed! As such, we recommend\ndoing this only immediately before registering any custom strategies you might\nbe using.", 
            "title": "Removing the default strategies"
        }, 
        {
            "location": "/features/emitters/", 
            "text": "Emitters\n\n\nTo simplify the usage of Expressive, we added the \nrun()\n method, which handles\nthe incoming request, and emits a response.\n\n\nThe latter aspect, emitting the response, is the responsibility of an\n\nemitter\n.\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.\n\n\nDiactoros defines an \nEmitterInterface\n, and \u2014 as of the time we write this \u2014 a\nsingle emitter implementation, \nZend\\Diactoros\\Response\\SapiEmitter\n, which\nsends headers and output using PHP's standard SAPI mechanisms (the \nheader()\n\nmethod and the output buffer).\n\n\nWe recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use \nReact\n, the SAPI\nemitter will likely not work for you.\n\n\nTo facilitate alternate emitters, we offer two facilities:\n\n\n\n\nFirst, \nApplication\n composes an emitter, and you can specify an alternate\n  emitter during instantiation, or via the \nZend\\Diactoros\\Response\\EmitterInterface\n\n  service when using the container factory.\n\n\nSecond, we provide \nZend\\Expressive\\Emitter\\EmitterStack\n, which allows you to\n  compose multiple emitter strategies; the first to return a value other than\n  boolean \nfalse\n will cause execution of the stack to short-circuit.\n  \nApplication\n composes an \nEmitterStack\n by default, with an \nSapiEmitter\n\n  composed at the bottom of the stack.\n\n\n\n\nEmitterStack\n\n\nThe \nEmitterStack\n is an \nSplStack\n extension that implements\n\nEmitterInterface\n. You can add emitters to the stack by pushing them on:\n\n\n$stack-\npush($emitterInstance);\n\n\n\n\nAs a stack, execution is in LIFO (last in, first out) order; the first emitter\non the stack will be evaluated last.", 
            "title": "Emitters"
        }, 
        {
            "location": "/features/emitters/#emitters", 
            "text": "To simplify the usage of Expressive, we added the  run()  method, which handles\nthe incoming request, and emits a response.  The latter aspect, emitting the response, is the responsibility of an emitter .\nAn emitter accepts a response instance, and then does something with it, usually\nsending the response back to a browser.  Diactoros defines an  EmitterInterface , and \u2014 as of the time we write this \u2014 a\nsingle emitter implementation,  Zend\\Diactoros\\Response\\SapiEmitter , which\nsends headers and output using PHP's standard SAPI mechanisms (the  header() \nmethod and the output buffer).  We recognize that there are times when you may want to use alternate emitter\nimplementations; for example, if you use  React , the SAPI\nemitter will likely not work for you.  To facilitate alternate emitters, we offer two facilities:   First,  Application  composes an emitter, and you can specify an alternate\n  emitter during instantiation, or via the  Zend\\Diactoros\\Response\\EmitterInterface \n  service when using the container factory.  Second, we provide  Zend\\Expressive\\Emitter\\EmitterStack , which allows you to\n  compose multiple emitter strategies; the first to return a value other than\n  boolean  false  will cause execution of the stack to short-circuit.\n   Application  composes an  EmitterStack  by default, with an  SapiEmitter \n  composed at the bottom of the stack.", 
            "title": "Emitters"
        }, 
        {
            "location": "/features/emitters/#emitterstack", 
            "text": "The  EmitterStack  is an  SplStack  extension that implements EmitterInterface . You can add emitters to the stack by pushing them on:  $stack- push($emitterInstance);  As a stack, execution is in LIFO (last in, first out) order; the first emitter\non the stack will be evaluated last.", 
            "title": "EmitterStack"
        }, 
        {
            "location": "/cookbook/common-prefix-for-routes/", 
            "text": "How can I prepend a common path to all my routes?\n\n\nYou may have multiple middlewares providing their own functionality:\n\n\n$middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$app = AppFactory::create();\n$app-\npipe($middleware1);\n$app-\npipe($middleware2);\n\n$app-\nrun();\n\n\n\n\nLet's assume the above represents an API.\n\n\nAs your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path \n/api\n.\n\n\nThis is essentially the same problem as addressed in the\n\n\"Segregating your application to a subpath\"\n example.\n\n\nTo accomplish it:\n\n\n\n\nCreate a new application.\n\n\nPipe the previous application to the new one, under the path \n/api\n.\n\n\n\n\n$middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$api = AppFactory::create();\n$api-\npipe($middleware1);\n$api-\npipe($middleware2);\n\n$app = AppFactory::create();\n$app-\npipe('/api', $api);\n\n$app-\nrun();\n\n\n\n\nThe above works, because every \nApplication\n instance is itself middleware, and, more specifically,\nan instance of \nStratigility's \nMiddlewarePipe\n,\nwhich provides the ability to compose middleware.", 
            "title": "Prepending a common path to all routes"
        }, 
        {
            "location": "/cookbook/common-prefix-for-routes/#how-can-i-prepend-a-common-path-to-all-my-routes", 
            "text": "You may have multiple middlewares providing their own functionality:  $middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$app = AppFactory::create();\n$app- pipe($middleware1);\n$app- pipe($middleware2);\n\n$app- run();  Let's assume the above represents an API.  As your application progresses, you may have a mixture of different content, and now want to have\nthe above segregated under the path  /api .  This is essentially the same problem as addressed in the \"Segregating your application to a subpath\"  example.  To accomplish it:   Create a new application.  Pipe the previous application to the new one, under the path  /api .   $middleware1 = new UserMiddleware();\n$middleware2 = new ProjectMiddleware();\n\n$api = AppFactory::create();\n$api- pipe($middleware1);\n$api- pipe($middleware2);\n\n$app = AppFactory::create();\n$app- pipe('/api', $api);\n\n$app- run();  The above works, because every  Application  instance is itself middleware, and, more specifically,\nan instance of  Stratigility's  MiddlewarePipe ,\nwhich provides the ability to compose middleware.", 
            "title": "How can I prepend a common path to all my routes?"
        }, 
        {
            "location": "/cookbook/route-specific-pipeline/", 
            "text": "How can I specify a route-specific middleware pipeline?\n\n\nSometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:\n\n\n\n\ncheck for authentication credentials\n\n\ncheck for authorization for the selected action\n\n\nparse the incoming body\n\n\nvalidate the parsed body parameters\n\n\n\n\nbefore\n you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.\n\n\nYou can accomplish this in one of two ways:\n\n\n\n\nHave your middleware service resolve to a \nMiddlewarePipe\n instance that\n  composes the various middlewares.\n\n\nSpecify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a \nMiddlewarePipe\n.\n\n\n\n\nResolving to a MiddlewarePipe\n\n\nYou can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.\n\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline-\npipe($container-\nget('AuthenticationMiddleware'));\n        $pipeline-\npipe($container-\nget('AuthorizationMiddleware'));\n        $pipeline-\npipe($container-\nget('BodyParsingMiddleware'));\n        $pipeline-\npipe($container-\nget('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline-\npipe($container-\nget('ApiResource'));\n\n        return $pipeline;\n    }\n}\n\n\n\n\nThis gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.\n\n\nOne alternative when using zend-servicemanager is to use a \ndelegator factory\n.\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:\n\n\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory\n{\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline-\npipe($container-\nget('AuthenticationMiddleware'));\n        $pipeline-\npipe($container-\nget('AuthorizationMiddleware'));\n        $pipeline-\npipe($container-\nget('BodyParsingMiddleware'));\n        $pipeline-\npipe($container-\nget('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline-\npipe($callback());\n\n        return $pipeline;\n    }\n}\n\n\n\n\nWhen configuring the container, you'd do something like the following:\n\n\nreturn [\n    'dependencies' =\n [\n        'factories' =\n [\n            'AuthenticationMiddleware' =\n '...',\n            'AuthorizationMiddleware' =\n '...',\n            'BodyParsingMiddleware' =\n '...',\n            'ValidationMiddleware' =\n '...',\n            'ApiResourceMiddleware' =\n '...',\n        ],\n        'delegator_factories' =\n [\n            'ApiResourceMiddleware' =\n [\n                'ApiResourcePipelineDelegatorFactory',\n            ],\n        ],\n    ],\n];\n\n\n\n\nThis approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.\n\n\nMiddleware Arrays\n\n\nIf you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares in your configuration or when routing manually.\n\n\nVia configuration looks like this:\n\n\nreturn [\n    'routes' =\n [\n        [\n            'name' =\n 'api-resource',\n            'path' =\n '/api/resource[/{id:[a-f0-9]{32}}]',\n            'allowed_methods' =\n ['GET', 'POST', 'PATCH', 'DELETE'],\n            'middleware' =\n [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n                'ApiResourceMiddleware',\n            ],\n        ],\n    ],\n];\n\n\n\n\nManual routing looks like this:\n\n\n$app-\nroute('/api/resource[/{id:[a-f0-9]{32}}]', [\n    'AuthenticationMiddleware',\n    'AuthorizationMiddleware',\n    'BodyParsingMiddleware',\n    'ValidationMiddleware',\n    'ApiResourceMiddleware',\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');\n\n\n\n\nWhen either of these approaches are used, the individual middleware listed\n\nMUST\n be one of the following:\n\n\n\n\na callable middleware;\n\n\na service name of middleware available in the container;\n\n\na fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.\n\n\n\n\nThis approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.\n\n\nWhat about pipeline middleware configuration?\n\n\nWhat if you want to do this with your pipeline middleware configuration? The\nanswer is that the syntax is exactly the same!\n\n\nreturn [\n    'middleware_pipeline' =\n [\n        'api' =\n [\n            'path' =\n '/api',\n            'middleware' =\n [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n            ],\n            'priority' =\n 100,\n        ],\n    ],\n];", 
            "title": "Route-specific middleware pipelines"
        }, 
        {
            "location": "/cookbook/route-specific-pipeline/#how-can-i-specify-a-route-specific-middleware-pipeline", 
            "text": "Sometimes you may want to use a middleware pipeline only if a particular route\nis matched. As an example, for an API resource, you might want to:   check for authentication credentials  check for authorization for the selected action  parse the incoming body  validate the parsed body parameters   before  you actually execute the selected middleware. The above might each be\nencapsulated as discrete middleware, but should be executed within the routed\nmiddleware's context.  You can accomplish this in one of two ways:   Have your middleware service resolve to a  MiddlewarePipe  instance that\n  composes the various middlewares.  Specify an array of middlewares (either as actual instances, or as container\n  service names); this effectively creates and returns a  MiddlewarePipe .", 
            "title": "How can I specify a route-specific middleware pipeline?"
        }, 
        {
            "location": "/cookbook/route-specific-pipeline/#resolving-to-a-middlewarepipe", 
            "text": "You can do this programmatically within a container factory, assuming you are\nusing a container that supports factories.  use Interop\\Container\\ContainerInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline- pipe($container- get('AuthenticationMiddleware'));\n        $pipeline- pipe($container- get('AuthorizationMiddleware'));\n        $pipeline- pipe($container- get('BodyParsingMiddleware'));\n        $pipeline- pipe($container- get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline- pipe($container- get('ApiResource'));\n\n        return $pipeline;\n    }\n}  This gives you full control over the creation of the pipeline. You would,\nhowever, need to ensure that you map the middleware to the pipeline factory when\nsetting up your container configuration.  One alternative when using zend-servicemanager is to use a  delegator factory .\nDelegator factories allow you to decorate the primary factory used to create the\nmiddleware in order to change the instance or return an alternate instance. In\nthis case, we'd do the latter. The following is an example:  use Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nclass ApiResourcePipelineDelegatorFactory\n{\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        $pipeline = new MiddlewarePipe();\n\n        // These correspond to the bullet points above\n        $pipeline- pipe($container- get('AuthenticationMiddleware'));\n        $pipeline- pipe($container- get('AuthorizationMiddleware'));\n        $pipeline- pipe($container- get('BodyParsingMiddleware'));\n        $pipeline- pipe($container- get('ValidationMiddleware'));\n\n        // This is the actual middleware you're routing to.\n        $pipeline- pipe($callback());\n\n        return $pipeline;\n    }\n}  When configuring the container, you'd do something like the following:  return [\n    'dependencies' =  [\n        'factories' =  [\n            'AuthenticationMiddleware' =  '...',\n            'AuthorizationMiddleware' =  '...',\n            'BodyParsingMiddleware' =  '...',\n            'ValidationMiddleware' =  '...',\n            'ApiResourceMiddleware' =  '...',\n        ],\n        'delegator_factories' =  [\n            'ApiResourceMiddleware' =  [\n                'ApiResourcePipelineDelegatorFactory',\n            ],\n        ],\n    ],\n];  This approach allows you to cleanly separate the factory for your middleware\nfrom the pipeline you want to compose it in, and allows you to re-use the\npipeline creation across multiple middleware if desired.", 
            "title": "Resolving to a MiddlewarePipe"
        }, 
        {
            "location": "/cookbook/route-specific-pipeline/#middleware-arrays", 
            "text": "If you'd rather not create a factory for each such middleware, the other option\nis to use arrays of middlewares in your configuration or when routing manually.  Via configuration looks like this:  return [\n    'routes' =  [\n        [\n            'name' =  'api-resource',\n            'path' =  '/api/resource[/{id:[a-f0-9]{32}}]',\n            'allowed_methods' =  ['GET', 'POST', 'PATCH', 'DELETE'],\n            'middleware' =  [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n                'ApiResourceMiddleware',\n            ],\n        ],\n    ],\n];  Manual routing looks like this:  $app- route('/api/resource[/{id:[a-f0-9]{32}}]', [\n    'AuthenticationMiddleware',\n    'AuthorizationMiddleware',\n    'BodyParsingMiddleware',\n    'ValidationMiddleware',\n    'ApiResourceMiddleware',\n], ['GET', 'POST', 'PATCH', 'DELETE'], 'api-resource');  When either of these approaches are used, the individual middleware listed MUST  be one of the following:   a callable middleware;  a service name of middleware available in the container;  a fully qualified class name of a directly instantiable (no constructor\n  arguments) middleware class.   This approach is essentially equivalent to creating a factory that returns a\nmiddleware pipeline.", 
            "title": "Middleware Arrays"
        }, 
        {
            "location": "/cookbook/route-specific-pipeline/#what-about-pipeline-middleware-configuration", 
            "text": "What if you want to do this with your pipeline middleware configuration? The\nanswer is that the syntax is exactly the same!  return [\n    'middleware_pipeline' =  [\n        'api' =  [\n            'path' =  '/api',\n            'middleware' =  [\n                'AuthenticationMiddleware',\n                'AuthorizationMiddleware',\n                'BodyParsingMiddleware',\n                'ValidationMiddleware',\n            ],\n            'priority' =  100,\n        ],\n    ],\n];", 
            "title": "What about pipeline middleware configuration?"
        }, 
        {
            "location": "/cookbook/custom-404-page-handling/", 
            "text": "How can I set custom 404 page handling?\n\n\nIn some cases, you may want to handle 404 errors separately from the\n\nfinal handler\n. This can be done by registering\nmiddleware that operates late \n specifically, after the routing\nmiddleware. Such middleware will be executed if no other middleware has\nexecuted, and/or when all other middleware calls \nreturn $next()\n\nwithout returning a response. Such situations typically mean that no middleware\nwas able to complete the request.\n\n\nYour 404 handler can take one of two approaches:\n\n\n\n\nIt can set the response status and call \n$next()\n with an error condition. In\n  such a case, the final handler \nwill\n likely be executed, but will have an\n  explicit 404 status to work with.\n\n\nIt can create and return a 404 response itself.\n\n\n\n\nCalling next with an error condition\n\n\nIn the first approach, the \nNotFound\n middleware can be as simple as this:\n\n\nnamespace Application;\n\nclass NotFound\n{\n    public function __invoke($req, $res, $next)\n    {\n        // Other things can be done here; e.g., logging\n        return $next($req, $res-\nwithStatus(404), 'Page Not Found');\n    }\n}\n\n\n\n\nThis example uses the third, optional argument to \n$next()\n, which is an error\ncondition. Internally, the final handler will typically see this, and return an\nerror page of some sort. Since we set the response status, and it's an error\nstatus code, that status code will be used in the generated response.\n\n\nThe \nTemplatedErrorHandler\n will use the error template in this particular case,\nso you will likely need to make some accommodations for 404 responses in that\ntemplate if you choose this approach.\n\n\n404 Middleware\n\n\nIn the second approach, the \nNotFound\n middleware will return a full response.\nIn our example here, we will render a specific template, and use this to seed\nand return a response.\n\n\nnamespace Application;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass NotFound\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this-\nrenderer = $renderer;\n    }\n\n    public function __invoke($req, $res, $next)\n    {\n        // other things can be done here; e.g., logging\n        // Now set the response status and write to the body\n        $response = $res-\nwithStatus(404);\n        $response-\ngetBody()-\nwrite($this-\nrenderer-\nrender('error::not-found'));\n        return $response;\n    }\n}\n\n\n\n\nThis approach allows you to have an application-specific workflow for 404 errors\nthat does not rely on the final handler.\n\n\nRegistering custom 404 handlers\n\n\nWe can register either \nApplication\\NotFound\n class above as service in the\n\nservice container\n. In the case of the second approach,\nyou would also need to provide a factory for creating the middleware (to ensure\nyou inject the template renderer).\n\n\nFrom there, you still need to register the middleware. This middleware is not\nrouted, and thus needs to be piped to the application instance. You can do this\nvia either configuration, or manually.\n\n\nTo do this via configuration, add an entry under the \nmiddleware_pipeline\n\nconfiguration, after the dispatch middleware:\n\n\n'middleware_pipeline' =\n [\n    /* ... */\n    'routing' =\n [\n        'middleware' =\n [\n            Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n            Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n            Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        ],\n        'priority' =\n 1,\n    ],\n    [\n        'middleware' =\n 'Application\\NotFound',\n        'priority' =\n -1,\n    ],\n    /* ... */\n],\n\n\n\n\nThe above example assumes you are using the \nApplicationFactory\n and/or the\nExpressive skeleton to manage your application instantiation and configuration.\n\n\nTo manually add the middleware, you will need to pipe it to the application\ninstance:\n\n\n$app-\npipe($container-\nget('Application\\NotFound'));\n\n\n\n\nThis must be done \nafter\n:\n\n\n\n\ncalling \n$app-\npipeDispatchMiddleware()\n, \nOR\n\n\npulling the \nApplication\n instance from the service container (assuming you\n  used the \nApplicationFactory\n).\n\n\n\n\nThis is to ensure that the \nNotFound\n middleware executes \nafter\n any routed\nmiddleware, as you only want it to execute if no routed middleware was selected.", 
            "title": "Setting custom 404 page handling"
        }, 
        {
            "location": "/cookbook/custom-404-page-handling/#how-can-i-set-custom-404-page-handling", 
            "text": "In some cases, you may want to handle 404 errors separately from the final handler . This can be done by registering\nmiddleware that operates late   specifically, after the routing\nmiddleware. Such middleware will be executed if no other middleware has\nexecuted, and/or when all other middleware calls  return $next() \nwithout returning a response. Such situations typically mean that no middleware\nwas able to complete the request.  Your 404 handler can take one of two approaches:   It can set the response status and call  $next()  with an error condition. In\n  such a case, the final handler  will  likely be executed, but will have an\n  explicit 404 status to work with.  It can create and return a 404 response itself.", 
            "title": "How can I set custom 404 page handling?"
        }, 
        {
            "location": "/cookbook/custom-404-page-handling/#calling-next-with-an-error-condition", 
            "text": "In the first approach, the  NotFound  middleware can be as simple as this:  namespace Application;\n\nclass NotFound\n{\n    public function __invoke($req, $res, $next)\n    {\n        // Other things can be done here; e.g., logging\n        return $next($req, $res- withStatus(404), 'Page Not Found');\n    }\n}  This example uses the third, optional argument to  $next() , which is an error\ncondition. Internally, the final handler will typically see this, and return an\nerror page of some sort. Since we set the response status, and it's an error\nstatus code, that status code will be used in the generated response.  The  TemplatedErrorHandler  will use the error template in this particular case,\nso you will likely need to make some accommodations for 404 responses in that\ntemplate if you choose this approach.", 
            "title": "Calling next with an error condition"
        }, 
        {
            "location": "/cookbook/custom-404-page-handling/#404-middleware", 
            "text": "In the second approach, the  NotFound  middleware will return a full response.\nIn our example here, we will render a specific template, and use this to seed\nand return a response.  namespace Application;\n\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass NotFound\n{\n    private $renderer;\n\n    public function __construct(TemplateRendererInterface $renderer)\n    {\n        $this- renderer = $renderer;\n    }\n\n    public function __invoke($req, $res, $next)\n    {\n        // other things can be done here; e.g., logging\n        // Now set the response status and write to the body\n        $response = $res- withStatus(404);\n        $response- getBody()- write($this- renderer- render('error::not-found'));\n        return $response;\n    }\n}  This approach allows you to have an application-specific workflow for 404 errors\nthat does not rely on the final handler.", 
            "title": "404 Middleware"
        }, 
        {
            "location": "/cookbook/custom-404-page-handling/#registering-custom-404-handlers", 
            "text": "We can register either  Application\\NotFound  class above as service in the service container . In the case of the second approach,\nyou would also need to provide a factory for creating the middleware (to ensure\nyou inject the template renderer).  From there, you still need to register the middleware. This middleware is not\nrouted, and thus needs to be piped to the application instance. You can do this\nvia either configuration, or manually.  To do this via configuration, add an entry under the  middleware_pipeline \nconfiguration, after the dispatch middleware:  'middleware_pipeline' =  [\n    /* ... */\n    'routing' =  [\n        'middleware' =  [\n            Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n            Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n            Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        ],\n        'priority' =  1,\n    ],\n    [\n        'middleware' =  'Application\\NotFound',\n        'priority' =  -1,\n    ],\n    /* ... */\n],  The above example assumes you are using the  ApplicationFactory  and/or the\nExpressive skeleton to manage your application instantiation and configuration.  To manually add the middleware, you will need to pipe it to the application\ninstance:  $app- pipe($container- get('Application\\NotFound'));  This must be done  after :   calling  $app- pipeDispatchMiddleware() ,  OR  pulling the  Application  instance from the service container (assuming you\n  used the  ApplicationFactory ).   This is to ensure that the  NotFound  middleware executes  after  any routed\nmiddleware, as you only want it to execute if no routed middleware was selected.", 
            "title": "Registering custom 404 handlers"
        }, 
        {
            "location": "/cookbook/using-custom-view-helpers/", 
            "text": "How do you register custom view helpers when using zend-view?\n\n\nIf you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?\n\n\nAssuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for \nZend\\View\\HelperPluginManager\n, and it will\nbe injected into the \nPhpRenderer\n instance used. Since the \nHelperPluginManager\n\nis available, we can configure it.\n\n\nOpen the file \nconfig/autoload/templates.global.php\n. In that file, you'll see\nthree top-level keys:\n\n\nreturn [\n    'dependencies' =\n [ /* ... */ ],\n    'templates' =\n [ /* ... */ ],\n    'view_helpers' =\n [ /* ... */ ],\n];\n\n\n\n\nThe last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created.\n\nSee the zend-view custom helpers documentation\n\nfor information on how to populate this configuration.", 
            "title": "Registering custom view helpers when using zend-view"
        }, 
        {
            "location": "/cookbook/using-custom-view-helpers/#how-do-you-register-custom-view-helpers-when-using-zend-view", 
            "text": "If you've selected zend-view as your preferred template renderer, you may want\nto define and use custom view helpers. How can you use them?  Assuming you've used the Expressive skeleton to start your application, you will\nalready have a factory defined for  Zend\\View\\HelperPluginManager , and it will\nbe injected into the  PhpRenderer  instance used. Since the  HelperPluginManager \nis available, we can configure it.  Open the file  config/autoload/templates.global.php . In that file, you'll see\nthree top-level keys:  return [\n    'dependencies' =  [ /* ... */ ],\n    'templates' =  [ /* ... */ ],\n    'view_helpers' =  [ /* ... */ ],\n];  The last is the one you want. In this, you can define service mappings,\nincluding aliases, invokables, factories, and abstract factories to define how\nhelpers are named and created. See the zend-view custom helpers documentation \nfor information on how to populate this configuration.", 
            "title": "How do you register custom view helpers when using zend-view?"
        }, 
        {
            "location": "/cookbook/using-zend-form-view-helpers/", 
            "text": "How can I use zend-form view helpers?\n\n\nIf you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:\n\n\n\n\nzend-form\n\n\nzend-i18n\n\n\nzend-navigation\n\n\n\n\nBy default, only the view helpers directly available in zend-view are available;\nhow can you add the others?\n\n\nTo add the zend-form view helpers create a file \nconfig/autoload/zend-form.global.php\n\nwith the contents:\n\n\n?php\nuse Zend\\Form\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();\n\n\n\n\nand that will essentially do everything needed.\n\n\nIf you installed Expressive via the skeleton, the service\n\nZend\\View\\HelperPluginManager\n is registered for you, and represents the helper\nplugin manager injected into the \nPhpRenderer\n instance. As such, you only need\nto configure this. The question is: where?\n\n\nYou have three options:\n\n\n\n\nReplace the \nHelperPluginManager\n factory with your own; or\n\n\nAdd a delegator factory to or extend the \nHelperPluginManager\n service to\n  inject the additional helper configuration; or\n\n\nAdd pipeline middleware that composes the \nHelperPluginManager\n and configures\n  it.\n\n\n\n\nReplacing the HelperPluginManager factory\n\n\nThe zend-view integration provides \nZend\\Expressive\\ZendView\\HelperPluginManagerFactory\n,\nand the Expressive skeleton registers it be default. The simplest solution for\nadding other helpers is to replace it with your own. In your own factory, you\nwill \nalso\n configure the plugin manager with the configuration from the\nzend-form component (or whichever other components you wish to use).\n\n\nnamespace Your\\Application;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\View\\HelperPluginManager;\n\nclass HelperPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $manager = new HelperPluginManager($container);\n\n        $config = $container-\nhas('config') ? $container-\nget('config') : [];\n        $config = isset($config['view_helpers']) ? $config['view_helpers'] : [];\n        (new Config($config))-\nconfigureServiceManager($manager);\n\n        return $manager;\n    }\n}\n\n\n\n\nIn your \nconfig/autoload/templates.global.php\n file, change the line that reads:\n\n\nZend\\View\\HelperPluginManager::class =\n Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class,\n\n\n\n\nto instead read as:\n\n\nZend\\View\\HelperPluginManager::class =\n Your\\Application\\HelperPluginManagerFactory::class,\n\n\n\n\nThis approach will work for any of the various containers supported.\n\n\nDelegator factories/service extension\n\n\nDelegator factories\n\nand \nservice extension\n\noperate on the same principle: they intercept after the original factory was\ncalled, and then operate on the generated instance, either modifying or\nreplacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the\ntime of writing, we're unaware of a mechanism for doing so in Aura.Di.\n\n\nzend-servicemanager\n\n\nYou'll first need to create a delegator factory:\n\n\nnamespace Your\\Application;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FormHelpersDelegatorFactory\n{\n    /**\n     * zend-servicemanager v3 usage\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $helpers = $callback();\n\n        $config = $container-\nhas('config') ? $container-\nget('config') : [];\n        $config = new Config($config['view_helpers']);\n        $config-\nconfigureServiceManager($helpers);\n        return $helpers;\n    }\n\n    /**\n     * zend-servicemanager v2 compatibility\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}\n\n\n\n\nThe above creates an instance of \nZend\\ServiceManager\\Config\n, uses it to\nconfigure the already created \nZend\\View\\HelperPluginManager\n instance, and then\nreturns the plugin manager instance.\n\n\nFrom here, you'll add a \ndelegators\n configuration key in your\n\nconfig/autoload/templates.global.php\n file:\n\n\nreturn [\n    'dependencies' =\n [\n        'delegators' =\n [\n            Zend\\View\\HelperPluginManager::class =\n [\n                Your\\Application\\FormHelpersDelegatorFactory::class,\n            ],\n        ],\n        /* ... */\n    ],\n    'templates' =\n [\n        /* ... */\n    ],\n    'view_helpers' =\n [\n        /* ... */\n    ],\n];\n\n\n\n\nNote: delegator factories are keyed by the service they modify, and the value is\nan \narray\n of delegator factories, to allow multiple such factories to be in\nuse.\n\n\nPimple\n\n\nFor Pimple, we don't currently support configuration of service extensions, so\nyou'll need to edit the main container configuration file,\n\nconfig/container.php\n. Place the following anywhere after the factories and\ninvokables are defined:\n\n\n// The following assumes you've added the following import statements to\n// the start of the file:\n// use Zend\\ServiceManager\\Config as ServiceConfig;\n// use Zend\\View\\HelperPluginManager;\n$container[HelperPluginManager::class] = $container-\nextend(\n    HelperPluginManager::class,\n    function ($helpers, $container) {\n        $config = isset($container['config']) ? $container['config'] : [];\n        $config = new ServiceConfig($config['view_helpers']);\n        $config-\nconfigureServiceManager($helpers);\n        return $helpers;\n    }\n);\n\n\n\n\nPipeline middleware\n\n\nAnother option is to use pipeline middleware. This approach will\nrequire that the middleware execute on every request, which introduces (very\nslight) performance overhead. However, it's a portable method that works\nregardless of the container implementation you choose.\n\n\nFirst, define the middleware:\n\n\nnamespace Your\\Application\n\nuse Zend\\Form\\View\\HelperConfig as FormHelperConfig;\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddleware\n{\n    private $helpers;\n\n    public function __construct(HelperPluginManager $helpers)\n    {\n        $this-\nhelpers = $helpers;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $config = new FormHelperConfig();\n        $config-\nconfigureServiceManager($this-\nhelpers);\n        return $next($request, $response);\n    }\n}\n\n\n\n\nYou'll also need a factory for the middleware, to ensure it receives the\n\nHelperPluginManager\n:\n\n\nnamespace Your\\Application\n\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return new FormHelpersMiddleware(\n            $container-\nget(HelperPluginManager::class)\n        );\n    }\n}\n\n\n\n\nNow, register these in the file\n\nconfig/autoload/middleware-pipeline.global.php\n:\n\n\nreturn [\n    'dependencies' =\n [\n        'factories' =\n [\n            Your\\Application\\FormHelpersMiddleware::class =\n Your\\Application\\FormHelpersMiddlewareFactory::class\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =\n [\n        ['middleware' =\n Your\\Application\\FormHelpersMiddleware::class, 'priority' =\n 1000],\n        /* ... */\n        'routing' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\nAt that point, you're all set!\n\n\nRegistering more helpers\n\n\nWhat if you need to register helpers from multiple components?\n\n\nYou can do so using the same technique above. Better yet, do them all at once!\n\n\n\n\nIf you chose to use delegator factories/service extension, do all helper\n  configuration registrations for all components in the same factory.\n\n\nIf you chose to use middleware, do all helper configuration registrations for\n  all components in the same middleware.", 
            "title": "Using zend-form view helpers"
        }, 
        {
            "location": "/cookbook/using-zend-form-view-helpers/#how-can-i-use-zend-form-view-helpers", 
            "text": "If you've selected zend-view as your preferred template renderer, you'll likely\nwant to use the various view helpers available in other components, such as:   zend-form  zend-i18n  zend-navigation   By default, only the view helpers directly available in zend-view are available;\nhow can you add the others?  To add the zend-form view helpers create a file  config/autoload/zend-form.global.php \nwith the contents:  ?php\nuse Zend\\Form\\ConfigProvider;\n\n$provider = new ConfigProvider();\nreturn $provider();  and that will essentially do everything needed.  If you installed Expressive via the skeleton, the service Zend\\View\\HelperPluginManager  is registered for you, and represents the helper\nplugin manager injected into the  PhpRenderer  instance. As such, you only need\nto configure this. The question is: where?  You have three options:   Replace the  HelperPluginManager  factory with your own; or  Add a delegator factory to or extend the  HelperPluginManager  service to\n  inject the additional helper configuration; or  Add pipeline middleware that composes the  HelperPluginManager  and configures\n  it.", 
            "title": "How can I use zend-form view helpers?"
        }, 
        {
            "location": "/cookbook/using-zend-form-view-helpers/#replacing-the-helperpluginmanager-factory", 
            "text": "The zend-view integration provides  Zend\\Expressive\\ZendView\\HelperPluginManagerFactory ,\nand the Expressive skeleton registers it be default. The simplest solution for\nadding other helpers is to replace it with your own. In your own factory, you\nwill  also  configure the plugin manager with the configuration from the\nzend-form component (or whichever other components you wish to use).  namespace Your\\Application;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\View\\HelperPluginManager;\n\nclass HelperPluginManagerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        $manager = new HelperPluginManager($container);\n\n        $config = $container- has('config') ? $container- get('config') : [];\n        $config = isset($config['view_helpers']) ? $config['view_helpers'] : [];\n        (new Config($config))- configureServiceManager($manager);\n\n        return $manager;\n    }\n}  In your  config/autoload/templates.global.php  file, change the line that reads:  Zend\\View\\HelperPluginManager::class =  Zend\\Expressive\\ZendView\\HelperPluginManagerFactory::class,  to instead read as:  Zend\\View\\HelperPluginManager::class =  Your\\Application\\HelperPluginManagerFactory::class,  This approach will work for any of the various containers supported.", 
            "title": "Replacing the HelperPluginManager factory"
        }, 
        {
            "location": "/cookbook/using-zend-form-view-helpers/#delegator-factoriesservice-extension", 
            "text": "Delegator factories \nand  service extension \noperate on the same principle: they intercept after the original factory was\ncalled, and then operate on the generated instance, either modifying or\nreplacing it. We'll demonstrate this for zend-servicemanager and Pimple; at the\ntime of writing, we're unaware of a mechanism for doing so in Aura.Di.", 
            "title": "Delegator factories/service extension"
        }, 
        {
            "location": "/cookbook/using-zend-form-view-helpers/#zend-servicemanager", 
            "text": "You'll first need to create a delegator factory:  namespace Your\\Application;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\DelegatorFactoryInterface;\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\n\nclass FormHelpersDelegatorFactory\n{\n    /**\n     * zend-servicemanager v3 usage\n     */\n    public function __invoke(\n        ContainerInterface $container,\n        $name,\n        callable $callback,\n        array $options = null\n    ) {\n        $helpers = $callback();\n\n        $config = $container- has('config') ? $container- get('config') : [];\n        $config = new Config($config['view_helpers']);\n        $config- configureServiceManager($helpers);\n        return $helpers;\n    }\n\n    /**\n     * zend-servicemanager v2 compatibility\n     */\n    public function createDelegatorWithName(\n        ServiceLocatorInterface $container,\n        $name,\n        $requestedName,\n        $callback\n    ) {\n        return $this($container, $name, $callback);\n    }\n}  The above creates an instance of  Zend\\ServiceManager\\Config , uses it to\nconfigure the already created  Zend\\View\\HelperPluginManager  instance, and then\nreturns the plugin manager instance.  From here, you'll add a  delegators  configuration key in your config/autoload/templates.global.php  file:  return [\n    'dependencies' =  [\n        'delegators' =  [\n            Zend\\View\\HelperPluginManager::class =  [\n                Your\\Application\\FormHelpersDelegatorFactory::class,\n            ],\n        ],\n        /* ... */\n    ],\n    'templates' =  [\n        /* ... */\n    ],\n    'view_helpers' =  [\n        /* ... */\n    ],\n];  Note: delegator factories are keyed by the service they modify, and the value is\nan  array  of delegator factories, to allow multiple such factories to be in\nuse.", 
            "title": "zend-servicemanager"
        }, 
        {
            "location": "/cookbook/using-zend-form-view-helpers/#pimple", 
            "text": "For Pimple, we don't currently support configuration of service extensions, so\nyou'll need to edit the main container configuration file, config/container.php . Place the following anywhere after the factories and\ninvokables are defined:  // The following assumes you've added the following import statements to\n// the start of the file:\n// use Zend\\ServiceManager\\Config as ServiceConfig;\n// use Zend\\View\\HelperPluginManager;\n$container[HelperPluginManager::class] = $container- extend(\n    HelperPluginManager::class,\n    function ($helpers, $container) {\n        $config = isset($container['config']) ? $container['config'] : [];\n        $config = new ServiceConfig($config['view_helpers']);\n        $config- configureServiceManager($helpers);\n        return $helpers;\n    }\n);", 
            "title": "Pimple"
        }, 
        {
            "location": "/cookbook/using-zend-form-view-helpers/#pipeline-middleware", 
            "text": "Another option is to use pipeline middleware. This approach will\nrequire that the middleware execute on every request, which introduces (very\nslight) performance overhead. However, it's a portable method that works\nregardless of the container implementation you choose.  First, define the middleware:  namespace Your\\Application\n\nuse Zend\\Form\\View\\HelperConfig as FormHelperConfig;\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddleware\n{\n    private $helpers;\n\n    public function __construct(HelperPluginManager $helpers)\n    {\n        $this- helpers = $helpers;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $config = new FormHelperConfig();\n        $config- configureServiceManager($this- helpers);\n        return $next($request, $response);\n    }\n}  You'll also need a factory for the middleware, to ensure it receives the HelperPluginManager :  namespace Your\\Application\n\nuse Zend\\View\\HelperPluginManager;\n\nclass FormHelpersMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return new FormHelpersMiddleware(\n            $container- get(HelperPluginManager::class)\n        );\n    }\n}  Now, register these in the file config/autoload/middleware-pipeline.global.php :  return [\n    'dependencies' =  [\n        'factories' =  [\n            Your\\Application\\FormHelpersMiddleware::class =  Your\\Application\\FormHelpersMiddlewareFactory::class\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =  [\n        ['middleware' =  Your\\Application\\FormHelpersMiddleware::class, 'priority' =  1000],\n        /* ... */\n        'routing' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n        /* ... */\n    ],\n];  At that point, you're all set!", 
            "title": "Pipeline middleware"
        }, 
        {
            "location": "/cookbook/using-zend-form-view-helpers/#registering-more-helpers", 
            "text": "What if you need to register helpers from multiple components?  You can do so using the same technique above. Better yet, do them all at once!   If you chose to use delegator factories/service extension, do all helper\n  configuration registrations for all components in the same factory.  If you chose to use middleware, do all helper configuration registrations for\n  all components in the same middleware.", 
            "title": "Registering more helpers"
        }, 
        {
            "location": "/cookbook/using-a-base-path/", 
            "text": "How can I tell my application about a base path?\n\n\nIn some environments, your application may be running in a subdirectory of your\nweb root. For example:\n\n\nvar/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php\n\n\n\n\nwhere \n/var/www\n is the web root, and your Expressive application is in the\n\nexpressive/\n subdirectory. How can you make your application work correctly in\nthis environment?\n\n\n.htaccess in the application root.\n\n\nIf you are using Apache, your first step is to add an \n.htaccess\n file to your\napplication root, with directives for rewriting to the \npublic/\n directory:\n\n\nRewriteEngine On\nRewriteRule (.*) ./public/$1\n\n\n\n\n\n\nUsing other web servers\n\n\nIf you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to\n\nour issue tracker\n!\n\n\n\n\nUse middleware to rewrite the path\n\n\nThe above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!\n\n\nTo do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.\n\n\nAt the time of writing, we have two suggestions:\n\n\n\n\nlos/basepath\n provides the basic\n  mechanics of rewriting the URL, and has a stable release.\n\n\nmtymek/blast-base-url\n provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path, but does not have a stable release yet.\n\n\n\n\nlos/basepath\n\n\nTo use \nlos/basepath\n, install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.\n\n\nTo install and copy the configuration:\n\n\n$ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php\n\n\n\n\nWe recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):\n\n\n$ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php\n\n\n\n\nThen edit one or both, to change the \nlos_basepath\n settings:\n\n\nreturn [\n    'los_basepath' =\n '\nbase path here\n',\n    /* ... */\n];\n\n\n\n\nThe base path should be the portion of the web root leading up to the\n\nindex.php\n of your application. In the above example, this would be\n\n/expressive\n.\n\n\nmtymek/blast-base-url\n\n\nTo use \nmtymek/blast-base-url\n, install it via Composer, and register some\nconfiguration.\n\n\nTo install it:\n\n\n$ composer require mtymek/blast-base-url\n\n\n\n\nTo configure it, update the file \nconfig/autoload/middleware-pipeline.global.php\n,\nwith the following contents:\n\n\nreturn [\n    'dependencies' =\n [\n        'factories' =\n [\n            Blast\\BaseUrl\\BaseUrlMiddleware::class =\n Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =\n [\n        [ 'middleware' =\n [ Blast\\BaseUrl\\BaseUrlMiddleware::class ], 'priority' =\n 1000 ],\n        /* ... */\n        'routing' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\nAt this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.\n\n\nThe primary advantage of \nmtymek/blast-base-url\n is in its additional features:\n\n\n\n\nit injects \nZend\\Expressive\\Helper\\UrlHelper\n with the base path, allowing you \n  to create relative route-based URLs.\n\n\nit provides a new helper, \nBlast\\BaseUrl\\BasePathHelper\n, which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.\n\n\n\n\nTo enable these features, we'll add some configuration to\n\nconfig/autoload/dependencies.global.php\n file:\n\n\nreturn [\n    'dependencies' =\n [\n        'invokables' =\n [\n            Blast\\BaseUrl\\BasePathHelper::class =\n Blast\\BaseUrl\\BasePathHelper::class,            \n            /* ... */\n        ],\n    ],\n];\n\n\n\n\nFinally, if you're using zend-view, you can register a new \"basePath\" helper in\nyour \nconfig/autoload/templates.global.php\n:\n\n\nreturn [\n    /* ... */\n    'view_helpers' =\n [\n        'factories' =\n [\n            'basePath' =\n Blast\\BaseUrl\\BasePathViewHelperFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\nUsage of the \nBasePath\n helper is as follows:\n\n\n// where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this-\nbasePath('/icons/favicon.ico');", 
            "title": "Using Expressive from a subdirectory"
        }, 
        {
            "location": "/cookbook/using-a-base-path/#how-can-i-tell-my-application-about-a-base-path", 
            "text": "In some environments, your application may be running in a subdirectory of your\nweb root. For example:  var/\n|- www/\n|  |- wordpress/\n|  |- expressive/\n|  |  |- public/\n|  |  |  |- index.php  where  /var/www  is the web root, and your Expressive application is in the expressive/  subdirectory. How can you make your application work correctly in\nthis environment?", 
            "title": "How can I tell my application about a base path?"
        }, 
        {
            "location": "/cookbook/using-a-base-path/#htaccess-in-the-application-root", 
            "text": "If you are using Apache, your first step is to add an  .htaccess  file to your\napplication root, with directives for rewriting to the  public/  directory:  RewriteEngine On\nRewriteRule (.*) ./public/$1", 
            "title": ".htaccess in the application root."
        }, 
        {
            "location": "/cookbook/using-a-base-path/#using-other-web-servers", 
            "text": "If you are using a web-server other than Apache, and know how to do a similar\nrewrite, we'd love to know! Please submit ideas/instructions to our issue tracker !", 
            "title": "Using other web servers"
        }, 
        {
            "location": "/cookbook/using-a-base-path/#use-middleware-to-rewrite-the-path", 
            "text": "The above step ensures that clients can hit the website. Now we need to ensure\nthat the application can route to middleware!  To do this, we will add pipeline middleware to intercept the request, and\nrewrite the URL accordingly.  At the time of writing, we have two suggestions:   los/basepath  provides the basic\n  mechanics of rewriting the URL, and has a stable release.  mtymek/blast-base-url  provides the\n  URL rewriting mechanics, as well as utilities for generating URIs that retain\n  the base path, but does not have a stable release yet.", 
            "title": "Use middleware to rewrite the path"
        }, 
        {
            "location": "/cookbook/using-a-base-path/#losbasepath", 
            "text": "To use  los/basepath , install it via Composer, copy the configuration files to\nyour application, and then edit the configuration.  To install and copy the configuration:  $ composer require los/basepath\n$ cp vendor/los/basepath/config/los-basepath.global.php.dist config/autoload/los-basepath.global.php  We recommend copying the global configuration to a local configuration file as\nwell; this allows you to have the production settings in your global\nconfiguration, and development settings in a local configuration (which is\nexcluded from git by default):  $ cp config/autoload/los-basepath.global.php config/autoload/los-basepath.local.php  Then edit one or both, to change the  los_basepath  settings:  return [\n    'los_basepath' =  ' base path here ',\n    /* ... */\n];  The base path should be the portion of the web root leading up to the index.php  of your application. In the above example, this would be /expressive .", 
            "title": "los/basepath"
        }, 
        {
            "location": "/cookbook/using-a-base-path/#mtymekblast-base-url", 
            "text": "To use  mtymek/blast-base-url , install it via Composer, and register some\nconfiguration.  To install it:  $ composer require mtymek/blast-base-url  To configure it, update the file  config/autoload/middleware-pipeline.global.php ,\nwith the following contents:  return [\n    'dependencies' =  [\n        'factories' =  [\n            Blast\\BaseUrl\\BaseUrlMiddleware::class =  Blast\\BaseUrl\\BaseUrlMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =  [\n        [ 'middleware' =  [ Blast\\BaseUrl\\BaseUrlMiddleware::class ], 'priority' =  1000 ],\n        /* ... */\n        'routing' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n        /* ... */\n    ],\n];  At this point, the middleware will take care of the rewriting for you. No\nconfiguration is necessary, as it does auto-detection of the base path based on\nthe request URI and the operating system path to the application.  The primary advantage of  mtymek/blast-base-url  is in its additional features:   it injects  Zend\\Expressive\\Helper\\UrlHelper  with the base path, allowing you \n  to create relative route-based URLs.  it provides a new helper,  Blast\\BaseUrl\\BasePathHelper , which allows you to\n  create URLs relative to the base path; this is particularly useful for assets.   To enable these features, we'll add some configuration to config/autoload/dependencies.global.php  file:  return [\n    'dependencies' =  [\n        'invokables' =  [\n            Blast\\BaseUrl\\BasePathHelper::class =  Blast\\BaseUrl\\BasePathHelper::class,            \n            /* ... */\n        ],\n    ],\n];  Finally, if you're using zend-view, you can register a new \"basePath\" helper in\nyour  config/autoload/templates.global.php :  return [\n    /* ... */\n    'view_helpers' =  [\n        'factories' =  [\n            'basePath' =  Blast\\BaseUrl\\BasePathViewHelperFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  Usage of the  BasePath  helper is as follows:  // where $basePathHelper is an instance of Blast\\BaseUrl\\BasePathHelper\n// as pulled from your container:\necho $basePathHelper('/icons/favicon.ico');\n\n// or, from zend-view's PhpRenderer:\necho $this- basePath('/icons/favicon.ico');", 
            "title": "mtymek/blast-base-url"
        }, 
        {
            "location": "/cookbook/modular-layout/", 
            "text": "How can I make my application modular?\n\n\nZend Framework 2 applications have a concept of modules, independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.\n\n\nWhile zend-modulemanager could be used with Expressive, we suggest another\napproach: modules that are based only on configuration. This powerful approach\ndoesn't affect performance, and offers extensive flexibility: each module can\nprovide its own services (with factories), default configuration, and routes. \n\n\nThis cookbook will show how to organize modules using \n\nmtymek/expressive-config-manager\n,\na lightweight library that aggregates and merges configuration, optionally caching it.\n\n\nInstall the configuration manager\n\n\nThe configuration manager is available in Packagist:\n\n\n$ composer require mtymek/expressive-config-manager\n\n\n\n\nGenerate your config\n\n\nThe default Expressive skeleton installs a \nconfig/config.php\n file, which\naggregates all configuration. When using the configuration manager, you will\nneed to replace the contents of that file with the following code: \n\n\n?php\n\nuse Zend\\Expressive\\ConfigManager\\ConfigManager;\nuse Zend\\Expressive\\ConfigManager\\PhpFileProvider;\n\n$configManager = new ConfigManager([\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\nreturn new ArrayObject($configManager-\ngetMergedConfig());\n\n\n\n\nIf you open your application in a browser, it should still work in exactly the\nsame way as it was before. Now you can start adding your modules.\n\n\nFirst module\n\n\nConfigManager\n does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.\n\n\nFor instance, this is how your module could provide its own routes:\n\n\nnamespace MyModule;\n\nclass ModuleConfig\n{\n    public function __invoke()\n    {\n        return [\n            'routes' =\n [\n                [\n                    'name' =\n 'api.list-transactions',\n                    'path' =\n '/api/transactions',\n                    'middleware' =\n App\\Action\\ListTransactionsAction::class,\n                    'allowed_methods' =\n ['GET'],\n                ],\n                [\n                    'name' =\n 'api.refund-transaction',\n                    'path' =\n '/api/refund',\n                    'middleware' =\n App\\Action\\RefundAction::class,\n                    'allowed_methods' =\n ['POST'],\n                ],\n            ],\n        ];\n    }\n}\n\n\n\n\nEnabling the module\n\n\nFinally, you can enable your module by adding a reference to your config class\nwithin the arguments of the \nConfigManager\n constructor in the \nconfig/config.php\n\nfile:\n\n\n$configManager = new ConfigManager([\n    MyModule\\ModuleConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\n\n\n\nCaching configuration\n\n\nIn order to provide configuration caching, two things must occur:\n\n\n\n\nFirst, you must define a \nconfig_cache_enabled\n key in your configuration\n  somewhere.\n\n\nSecond, you must pass a second argument to the \nConfigManager\n, the location\n  of the cache file to use.\n\n\n\n\nThe \nconfig_cache_enabled\n key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:\n\n\n\n\nconfig/autoload/global.php\n should define the value to \ntrue\n, as the\n  production setting.\n\n\nconfig/autoload/local.php\n should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be \nfalse\n.\n\n\n\n\n// config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' =\n true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' =\n false, // \n- development!\n    /* ... */\n];\n\n\n\n\nYou would then alter your \nconfig/config.php\n file to add the second argument.\nThe following example builds on the previous, and demonstrates having the\n\nAppConfig\n entry enabled. The configuration will be cached to\n\ndata/config-cache.php\n in the application root:\n\n\n$configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');\n\n\n\n\nWhen the configuration cache path is present, if the \nconfig_cache_enabled\n flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.\n\n\nFinal notes\n\n\nThis approach may look simple, but it is flexible and powerful:\n\n\n\n\nYou pass a list of config providers to the \nConfigManager\n constructor.\n\n\nConfiguration is merged in the same order as it is passed, with later entries\n  having precedence.\n\n\nYou can override module configuration using \n*.global.php\n and \n*.local.php\n files.\n\n\nIf cached config is found, \nConfigManager\n does not iterate over provider list.\n\n\n\n\nFor more details, please refer to the\n\nConfig Manager Documentation\n.", 
            "title": "Building modular applications"
        }, 
        {
            "location": "/cookbook/modular-layout/#how-can-i-make-my-application-modular", 
            "text": "Zend Framework 2 applications have a concept of modules, independent units that\ncan provide configuration, services, and hooks into its MVC lifecycle. This\nfunctionality is provided by zend-modulemanager.  While zend-modulemanager could be used with Expressive, we suggest another\napproach: modules that are based only on configuration. This powerful approach\ndoesn't affect performance, and offers extensive flexibility: each module can\nprovide its own services (with factories), default configuration, and routes.   This cookbook will show how to organize modules using  mtymek/expressive-config-manager ,\na lightweight library that aggregates and merges configuration, optionally caching it.", 
            "title": "How can I make my application modular?"
        }, 
        {
            "location": "/cookbook/modular-layout/#install-the-configuration-manager", 
            "text": "The configuration manager is available in Packagist:  $ composer require mtymek/expressive-config-manager", 
            "title": "Install the configuration manager"
        }, 
        {
            "location": "/cookbook/modular-layout/#generate-your-config", 
            "text": "The default Expressive skeleton installs a  config/config.php  file, which\naggregates all configuration. When using the configuration manager, you will\nneed to replace the contents of that file with the following code:   ?php\n\nuse Zend\\Expressive\\ConfigManager\\ConfigManager;\nuse Zend\\Expressive\\ConfigManager\\PhpFileProvider;\n\n$configManager = new ConfigManager([\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);\n\nreturn new ArrayObject($configManager- getMergedConfig());  If you open your application in a browser, it should still work in exactly the\nsame way as it was before. Now you can start adding your modules.", 
            "title": "Generate your config"
        }, 
        {
            "location": "/cookbook/modular-layout/#first-module", 
            "text": "ConfigManager  does not force you to use any particular structure for your\nmodule; its only requirement is to expose default configuration using a \"config\nprovider\", which is simply an invokable class that returns a configuration\narray.  For instance, this is how your module could provide its own routes:  namespace MyModule;\n\nclass ModuleConfig\n{\n    public function __invoke()\n    {\n        return [\n            'routes' =  [\n                [\n                    'name' =  'api.list-transactions',\n                    'path' =  '/api/transactions',\n                    'middleware' =  App\\Action\\ListTransactionsAction::class,\n                    'allowed_methods' =  ['GET'],\n                ],\n                [\n                    'name' =  'api.refund-transaction',\n                    'path' =  '/api/refund',\n                    'middleware' =  App\\Action\\RefundAction::class,\n                    'allowed_methods' =  ['POST'],\n                ],\n            ],\n        ];\n    }\n}", 
            "title": "First module"
        }, 
        {
            "location": "/cookbook/modular-layout/#enabling-the-module", 
            "text": "Finally, you can enable your module by adding a reference to your config class\nwithin the arguments of the  ConfigManager  constructor in the  config/config.php \nfile:  $configManager = new ConfigManager([\n    MyModule\\ModuleConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n]);", 
            "title": "Enabling the module"
        }, 
        {
            "location": "/cookbook/modular-layout/#caching-configuration", 
            "text": "In order to provide configuration caching, two things must occur:   First, you must define a  config_cache_enabled  key in your configuration\n  somewhere.  Second, you must pass a second argument to the  ConfigManager , the location\n  of the cache file to use.   The  config_cache_enabled  key can be defined in any of your configuration\nproviders, including the autoloaded configuration files. We recommend defining\nthem in two locations:   config/autoload/global.php  should define the value to  true , as the\n  production setting.  config/autoload/local.php  should also define the setting, and use a value\n  appropriate to the current environment. In development, for instance, this\n  would be  false .   // config/autoload/global.php\n\nreturn [\n    'config_cache_enabled' =  true,\n    /* ... */\n];\n\n// config/autoload/local.php\n\nreturn [\n    'config_cache_enabled' =  false, //  - development!\n    /* ... */\n];  You would then alter your  config/config.php  file to add the second argument.\nThe following example builds on the previous, and demonstrates having the AppConfig  entry enabled. The configuration will be cached to data/config-cache.php  in the application root:  $configManager = new ConfigManager([\n    App\\AppConfig::class,\n    new PhpFileProvider('config/autoload/{{,*.}global,{,*.}local}.php'),\n], 'data/config-cache.php');  When the configuration cache path is present, if the  config_cache_enabled  flag\nis enabled, then configuration will be read from the cached configuration,\ninstead of parsing and merging the various configuration sources.", 
            "title": "Caching configuration"
        }, 
        {
            "location": "/cookbook/modular-layout/#final-notes", 
            "text": "This approach may look simple, but it is flexible and powerful:   You pass a list of config providers to the  ConfigManager  constructor.  Configuration is merged in the same order as it is passed, with later entries\n  having precedence.  You can override module configuration using  *.global.php  and  *.local.php  files.  If cached config is found,  ConfigManager  does not iterate over provider list.   For more details, please refer to the Config Manager Documentation .", 
            "title": "Final notes"
        }, 
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/", 
            "text": "How can I setup the locale depending on a routing parameter?\n\n\nLocalized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.\n\n\n\n\nRouting parameters\n\n\nUsing the approach in this chapter requires that you add a \n/:locale\n (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non \nsetting the locale without routing parameters\n.\n\n\n\n\nSetting up the route\n\n\nIf you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.\n\n\nIn this example we use the \nlocale\n parameter, which should consist of two\nlowercase alphabetical characters:\n\n\nreturn [\n    'dependencies' =\n [\n        'invokables' =\n [\n            Zend\\Expressive\\Router\\RouterInterface::class =\n\n                Zend\\Expressive\\Router\\ZendRouter::class,\n        ],\n        'factories' =\n [\n            Application\\Action\\HomePageAction::class =\n\n                Application\\Action\\HomePageFactory::class,\n            Application\\Action\\ContactPageAction::class =\n\n                Application\\Action\\ContactPageFactory::class,\n        ],\n    ],\n    'routes' =\n [\n        [\n            'name' =\n 'home',\n            'path' =\n '/:locale',\n            'middleware' =\n Application\\Action\\HomePageAction::class,\n            'allowed_methods' =\n ['GET'],\n            'options'         =\n [\n                'constraints' =\n [\n                    'locale' =\n '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n        [\n            'name' =\n 'contact',\n            'path' =\n '/:locale/contact',\n            'middleware' =\n Application\\Action\\ContactPageAction::class,\n            'allowed_methods' =\n ['GET'],\n            'options'         =\n [\n                'constraints' =\n [\n                    'locale' =\n '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\n\n\n\nNote: Routing may differ based on router\n\n\nThe routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.\n\n\nFor Aura.Router, the 'home' route as listed above would read:\n\n\n[\n    'name' =\n 'home',\n    'path' =\n '/{locale}',\n    'middleware' =\n Application\\Action\\HomePageAction::class,\n    'allowed_methods' =\n ['GET'],\n    'options'         =\n [\n        'constraints' =\n [\n            'tokens' =\n [\n                'locale' =\n '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n            ],\n        ],\n    ],\n]\n\n\n\n\nFor FastRoute:\n\n\n[\n    'name' =\n 'home',\n    'path' =\n '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    'middleware' =\n Application\\Action\\HomePageAction::class,\n    'allowed_methods' =\n ['GET'],\n]\n\n\n\n\nAs such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.\n\n\n\n\nCreate a route result middleware class for localization\n\n\nTo make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.\n\n\nSuch a \nLocalizationMiddleware\n class could look similar to this:\n\n\n?php\n\nnamespace Application\\I18n;\n\nuse Locale;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass LocalizationMiddleware\n{\n    const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next = null)\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request-\ngetAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                isset($request-\ngetServerParams()['HTTP_ACCEPT_LANGUAGE']) ? $request-\ngetServerParams()['HTTP_ACCEPT_LANGUAGE'] : 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $next($request-\nwithAttribute(self::LOCALIZATION_ATTRIBUTE, $locale), $response);\n    }\n}\n\n\n\n\n\n\nLocale::setDefault is unsafe\n\n\nDo not use \nLocale::setDefault($locale)\n to set a global static locale.\nPSR-7 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.\n\n\nUse a request parameter as detailed above instead, as the request is created\nspecific to each process.\n\n\n\n\nIn your \nconfig/autoload/middleware-pipeline.global.php\n, you'd register the\ndependency, and inject the middleware into the pipeline following the routing\nmiddleware:\n\n\nreturn [\n    'dependencies' =\n [\n        'invokables' =\n [\n            LocalizationMiddleware::class =\n LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =\n [\n        /* ... */\n        [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                LocalizationMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n        /* ... */\n    ],\n];", 
            "title": "Setting a locale based on a routing parameter"
        }, 
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#how-can-i-setup-the-locale-depending-on-a-routing-parameter", 
            "text": "Localized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on using a routing parameter.", 
            "title": "How can I setup the locale depending on a routing parameter?"
        }, 
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#routing-parameters", 
            "text": "Using the approach in this chapter requires that you add a  /:locale  (or\nsimilar) segment to each and every route that can be localized, and, depending\non the router used, may also require additional options for specifying\nconstraints. If the majority of your routes are localized, this will become\ntedious quickly. In such a case, you may want to look at the related recipe\non  setting the locale without routing parameters .", 
            "title": "Routing parameters"
        }, 
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#setting-up-the-route", 
            "text": "If you want to set the locale depending on an routing parameter, you first have\nto add a locale parameter to each route that requires localization.  In this example we use the  locale  parameter, which should consist of two\nlowercase alphabetical characters:  return [\n    'dependencies' =  [\n        'invokables' =  [\n            Zend\\Expressive\\Router\\RouterInterface::class = \n                Zend\\Expressive\\Router\\ZendRouter::class,\n        ],\n        'factories' =  [\n            Application\\Action\\HomePageAction::class = \n                Application\\Action\\HomePageFactory::class,\n            Application\\Action\\ContactPageAction::class = \n                Application\\Action\\ContactPageFactory::class,\n        ],\n    ],\n    'routes' =  [\n        [\n            'name' =  'home',\n            'path' =  '/:locale',\n            'middleware' =  Application\\Action\\HomePageAction::class,\n            'allowed_methods' =  ['GET'],\n            'options'         =  [\n                'constraints' =  [\n                    'locale' =  '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n        [\n            'name' =  'contact',\n            'path' =  '/:locale/contact',\n            'middleware' =  Application\\Action\\ContactPageAction::class,\n            'allowed_methods' =  ['GET'],\n            'options'         =  [\n                'constraints' =  [\n                    'locale' =  '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n                ],\n            ],\n        ],\n    ],\n];", 
            "title": "Setting up the route"
        }, 
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#note-routing-may-differ-based-on-router", 
            "text": "The routing examples in this recipe use syntax for the zend-mvc router, and,\nas such, may not work in your application.  For Aura.Router, the 'home' route as listed above would read:  [\n    'name' =  'home',\n    'path' =  '/{locale}',\n    'middleware' =  Application\\Action\\HomePageAction::class,\n    'allowed_methods' =  ['GET'],\n    'options'         =  [\n        'constraints' =  [\n            'tokens' =  [\n                'locale' =  '[a-z]{2,3}([-_][a-zA-Z]{2}|)',\n            ],\n        ],\n    ],\n]  For FastRoute:  [\n    'name' =  'home',\n    'path' =  '/{locale:[a-z]{2,3}([-_][a-zA-Z]{2}|)}',\n    'middleware' =  Application\\Action\\HomePageAction::class,\n    'allowed_methods' =  ['GET'],\n]  As such, be aware as you read the examples that you might not be able to\nsimply cut-and-paste them without modification.", 
            "title": "Note: Routing may differ based on router"
        }, 
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#create-a-route-result-middleware-class-for-localization", 
            "text": "To make sure that you can setup the locale after the routing has been processed,\nyou need to implement localization middleware that acts on the route result, and\nregistered in the pipeline immediately following the routing middleware.  Such a  LocalizationMiddleware  class could look similar to this:  ?php\n\nnamespace Application\\I18n;\n\nuse Locale;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass LocalizationMiddleware\n{\n    const LOCALIZATION_ATTRIBUTE = 'locale';\n\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response, callable $next = null)\n    {\n        // Get locale from route, fallback to the user's browser preference\n        $locale = $request- getAttribute(\n            'locale',\n            Locale::acceptFromHttp(\n                isset($request- getServerParams()['HTTP_ACCEPT_LANGUAGE']) ? $request- getServerParams()['HTTP_ACCEPT_LANGUAGE'] : 'en_US'\n            )\n        );\n\n        // Store the locale as a request attribute\n        return $next($request- withAttribute(self::LOCALIZATION_ATTRIBUTE, $locale), $response);\n    }\n}", 
            "title": "Create a route result middleware class for localization"
        }, 
        {
            "location": "/cookbook/setting-locale-depending-routing-parameter/#localesetdefault-is-unsafe", 
            "text": "Do not use  Locale::setDefault($locale)  to set a global static locale.\nPSR-7 apps may run in async processes, which could lead to another process\noverwriting the value, and thus lead to unexpected results for your users.  Use a request parameter as detailed above instead, as the request is created\nspecific to each process.   In your  config/autoload/middleware-pipeline.global.php , you'd register the\ndependency, and inject the middleware into the pipeline following the routing\nmiddleware:  return [\n    'dependencies' =  [\n        'invokables' =  [\n            LocalizationMiddleware::class =  LocalizationMiddleware::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =  [\n        /* ... */\n        [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                LocalizationMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n        /* ... */\n    ],\n];", 
            "title": "Locale::setDefault is unsafe"
        }, 
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/", 
            "text": "How can I setup the locale without routing parameters?\n\n\nLocalized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.\n\n\n\n\nDistinguishing between routes that require localization\n\n\nIf your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the\n\n\"Setting a locale based on a routing parameter\" recipe\n.\n\n\n\n\nSetup a middleware to extract the locale from the URI\n\n\nFirst, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If if doesn't find one, it sets a default.\n\n\nIf it does find one, it uses the value to setup the locale. It also:\n\n\n\n\namends the request with a truncated path (removing the locale segment).\n\n\nadds the locale segment as the base path of the \nUrlHelper\n.\n\n\n\n\nnamespace Application\\I18n;\n\nuse Locale;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this-\nhelper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $uri = $request-\ngetUri();\n\n        $path = $uri-\ngetPath();\n\n        if (! preg_match('#^/(?P\nlocale\n[a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            Locale::setDefault('de_DE');\n            return $next($request, $response);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this-\nhelper-\nsetBasePath($locale);\n\n        return $next(\n            $request-\nwithUri(\n                $uri-\nwithPath(substr($path, 3))\n            ),\n            $response\n        );\n    }\n}\n\n\n\n\nThen you will need a factory for the \nSetLocaleMiddleware\n to inject the\n\nUrlHelper\n instance.\n\n\nnamespace Application\\I18n;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SetLocaleMiddleware(\n            $container-\nget(UrlHelper::class)\n        );\n    }\n}\n\n\n\n\nAfterwards, you need to configure the \nSetLocaleMiddleware\n in your \n\n/config/autoload/middleware-pipeline.global.php\n file so that it is executed \non every request.\n\n\nreturn [\n    'dependencies' =\n [\n        /* ... */\n        'factories' =\n [\n            Application\\I18n\\SetLocaleMiddleware::class =\n\n                Application\\I18n\\SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ]\n\n    'middleware_pipeline' =\n [\n        [\n            'middleware' =\n [\n                Application\\I18n\\SetLocaleMiddleware::class,\n                /* ... */\n            ],\n            'priority' =\n 1000,\n        ],\n\n        /* ... */\n\n        'routing' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n\n        /* ... */\n    ],\n];\n\n\n\n\nUrl generation in the view\n\n\nSince the \nUrlHelper\n has the locale set as a base path, you don't need \nto worry about generating URLs within your view. Just use the helper to \ngenerate a URL and it will do the rest.\n\n\n?php echo $this-\nurl('your-route') ?\n\n\n\n\n\n\nHelpers differ between template renderers\n\n\nThe above example is specific to zend-view; syntax will differ for\nTwig and Plates.\n\n\n\n\nRedirecting within your middleware\n\n\nIf you want to add the locale parameter when creating URIs within your \naction middleware, you just need to inject the \nUrlHelper\n into your \nmiddleware and use it for URL generation:\n\n\nnamespace Application\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectAction\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this-\nhelper = $helper;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param ResponseInterface      $response\n     * @param callable|null          $next\n     *\n     * @return RedirectResponse\n     */\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this-\nhelper-\ngenerate('your-route', $routeParams)\n        );\n    }\n}\n\n\n\n\nInjecting the \nUrlHelper\n into your middleware will also require that the\nmiddleware have a factory that manages the injection. As an example, the\nfollowing would work for the above middleware:\n\n\nnamespace Application\\Action;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectAction(\n            $container-\nget(UrlHelper::class)\n        );\n    }\n}", 
            "title": "Setting a locale without a routing parameter"
        }, 
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#how-can-i-setup-the-locale-without-routing-parameters", 
            "text": "Localized web applications often set the locale (and therefor the language)\nbased on a routing parameter, the session, or a specialized sub-domain.\nIn this recipe we will concentrate on introspecting the URI path via middleware,\nwhich allows you to have a global mechanism for detecting the locale without\nrequiring any changes to existing routes.", 
            "title": "How can I setup the locale without routing parameters?"
        }, 
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#distinguishing-between-routes-that-require-localization", 
            "text": "If your application has a mixture of routes that require localization, and\nthose that do not, the solution in this recipe may lead to multiple URIs\nthat resolve to the identical action, which may be undesirable. In such\ncases, you may want to prefix the specific routes that require localization\nwith a required routing parameter; this approach is described in the \"Setting a locale based on a routing parameter\" recipe .", 
            "title": "Distinguishing between routes that require localization"
        }, 
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#setup-a-middleware-to-extract-the-locale-from-the-uri", 
            "text": "First, we need to setup middleware that extracts the locale param directly\nfrom the request URI's path. If if doesn't find one, it sets a default.  If it does find one, it uses the value to setup the locale. It also:   amends the request with a truncated path (removing the locale segment).  adds the locale segment as the base path of the  UrlHelper .   namespace Application\\I18n;\n\nuse Locale;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddleware\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this- helper = $helper;\n    }\n\n    public function __invoke($request, $response, callable $next)\n    {\n        $uri = $request- getUri();\n\n        $path = $uri- getPath();\n\n        if (! preg_match('#^/(?P locale [a-z]{2,3}([-_][a-zA-Z]{2}|))/#', $path, $matches)) {\n            Locale::setDefault('de_DE');\n            return $next($request, $response);\n        }\n\n        $locale = $matches['locale'];\n        Locale::setDefault(Locale::canonicalize($locale));\n        $this- helper- setBasePath($locale);\n\n        return $next(\n            $request- withUri(\n                $uri- withPath(substr($path, 3))\n            ),\n            $response\n        );\n    }\n}  Then you will need a factory for the  SetLocaleMiddleware  to inject the UrlHelper  instance.  namespace Application\\I18n;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass SetLocaleMiddlewareFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new SetLocaleMiddleware(\n            $container- get(UrlHelper::class)\n        );\n    }\n}  Afterwards, you need to configure the  SetLocaleMiddleware  in your  /config/autoload/middleware-pipeline.global.php  file so that it is executed \non every request.  return [\n    'dependencies' =  [\n        /* ... */\n        'factories' =  [\n            Application\\I18n\\SetLocaleMiddleware::class = \n                Application\\I18n\\SetLocaleMiddlewareFactory::class,\n            /* ... */\n        ],\n    ]\n\n    'middleware_pipeline' =  [\n        [\n            'middleware' =  [\n                Application\\I18n\\SetLocaleMiddleware::class,\n                /* ... */\n            ],\n            'priority' =  1000,\n        ],\n\n        /* ... */\n\n        'routing' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n\n        /* ... */\n    ],\n];", 
            "title": "Setup a middleware to extract the locale from the URI"
        }, 
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#url-generation-in-the-view", 
            "text": "Since the  UrlHelper  has the locale set as a base path, you don't need \nto worry about generating URLs within your view. Just use the helper to \ngenerate a URL and it will do the rest.  ?php echo $this- url('your-route') ?", 
            "title": "Url generation in the view"
        }, 
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#helpers-differ-between-template-renderers", 
            "text": "The above example is specific to zend-view; syntax will differ for\nTwig and Plates.", 
            "title": "Helpers differ between template renderers"
        }, 
        {
            "location": "/cookbook/setting-locale-without-routing-parameter/#redirecting-within-your-middleware", 
            "text": "If you want to add the locale parameter when creating URIs within your \naction middleware, you just need to inject the  UrlHelper  into your \nmiddleware and use it for URL generation:  namespace Application\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\RedirectResponse;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectAction\n{\n    private $helper;\n\n    public function __construct(UrlHelper $helper)\n    {\n        $this- helper = $helper;\n    }\n\n    /**\n     * @param ServerRequestInterface $request\n     * @param ResponseInterface      $response\n     * @param callable|null          $next\n     *\n     * @return RedirectResponse\n     */\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $routeParams = [ /* ... */ ];\n\n        return new RedirectResponse(\n            $this- helper- generate('your-route', $routeParams)\n        );\n    }\n}  Injecting the  UrlHelper  into your middleware will also require that the\nmiddleware have a factory that manages the injection. As an example, the\nfollowing would work for the above middleware:  namespace Application\\Action;\n\nuse Interop\\Container\\ContainerInterface;\nuse Zend\\Expressive\\Helper\\UrlHelper;\n\nclass RedirectActionFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new RedirectAction(\n            $container- get(UrlHelper::class)\n        );\n    }\n}", 
            "title": "Redirecting within your middleware"
        }, 
        {
            "location": "/cookbook/debug-toolbars/", 
            "text": "How can I get a debug toolbar for my Expressive application?\n\n\nMany modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?\n\n\nZend Server Z-Ray\n\n\nZend Server\n ships with a tool\ncalled \nZ-Ray\n, which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently \navailable as a standalone technology\npreview\n, and can be added\nas an extension to an existing PHP installation.\n\n\nWhen using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the\n\nZ-Ray documentation\n\nfor full usage details.\n\n\nbitExpert/prophiler-psr7-middleware\n\n\nAnother option is bitExpert's \nprophiler-psr7-middleware\n.\nThis package wraps \nfabfuel/prophiler\n,\nwhich provides a PHP-based profiling tool and toolbar; the bitExpert package\nwraps this in PSR-7 middleware to make consumption in those paradigms trivial.\n\n\nTo add the toolbar middleware to your application, use composer:\n\n\n$ composer require bitExpert/prophiler-psr7-middleware\n\n\n\n\nFrom there, you will need to create a factory for the middleware, and add it to\nyour middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written\na \npost detailing these steps\n.\n\n\n\n\nUse locally!\n\n\nOne minor change we recommend over the directions Stephan provides is that you\nconfigure the factory and middleware in the\n\nconfig/autoload/middleware-pipeline.local.php\n file, vs the \n.global\n version.\nDoing so enables the middleware and toolbar only in the local environment\n\n and not in production, where you likely do not want to expose such\ninformation!\n\n\n\n\nphp-middleware/php-debug-bar\n\n\nphp-middleware/php-debug-bar\n\nprovides a PSR-7 middleware wrapper around \nmaximebf/php-debugbar\n,\na popular framework-agnostic debug bar for PHP projects.\n\n\nFirst, install the middleware in your application:\n\n\n$ composer require php-middleware/php-debug-bar\n\n\n\n\nThis package provides a factory for creating the middleware, so we only need to\nwire it into our middleware pipeline.  Create and edit the file\n\nconfig/autoload/middleware-pipeline.local.php\n to read as follows:\n\n\nuse PhpMiddleware\\PhpDebugBar\\PhpDebugBarMiddleware;\nuse PhpMiddleware\\PhpDebugBar\\PhpDebugBarMiddlewareFactory;\n\nreturn [\n    'dependencies' =\n [\n        'factories' =\n [\n            PhpDebugBarMiddleware::class =\n PhpDebugBarMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' =\n [\n        [\n            'middleware' =\n [\n                PhpDebugBarMiddleware::class,\n            ],\n            'priority' =\n 1000,\n        ],\n    ],\n];\n\n\n\n\nThese changes will activate the toolbar in your application.\n\n\n\n\nUse locally!\n\n\nYou'll note that we specified the file \nmiddleware-pipeline.local.php\n, and\nnot \nmiddleware-pipeline.global.php\n. This ensures that the toolbar is only\nenabled in the local environment, and not committed to your production\nsettings.", 
            "title": "Enabling debug toolbars"
        }, 
        {
            "location": "/cookbook/debug-toolbars/#how-can-i-get-a-debug-toolbar-for-my-expressive-application", 
            "text": "Many modern frameworks and applications provide debug toolbars: in-browser\ntoolbars to provide profiling information of the request executed. These can\nprovide invaluable details into application objects, database queries, and more.\nAs an Expressive user, how can you get similar functionality?", 
            "title": "How can I get a debug toolbar for my Expressive application?"
        }, 
        {
            "location": "/cookbook/debug-toolbars/#zend-server-z-ray", 
            "text": "Zend Server  ships with a tool\ncalled  Z-Ray , which provides\nboth a debug toolbar and debug console (for API debugging). Z-Ray is also\ncurrently  available as a standalone technology\npreview , and can be added\nas an extension to an existing PHP installation.  When using Zend Server or the standalone Z-Ray, you do not need to make any\nchanges to your application whatsoever to benefit from it; you simply need to\nmake sure Z-Ray is enabled and/or that you've setup a security token to\nselectively enable it on-demand. See the Z-Ray documentation \nfor full usage details.", 
            "title": "Zend Server Z-Ray"
        }, 
        {
            "location": "/cookbook/debug-toolbars/#bitexpertprophiler-psr7-middleware", 
            "text": "Another option is bitExpert's  prophiler-psr7-middleware .\nThis package wraps  fabfuel/prophiler ,\nwhich provides a PHP-based profiling tool and toolbar; the bitExpert package\nwraps this in PSR-7 middleware to make consumption in those paradigms trivial.  To add the toolbar middleware to your application, use composer:  $ composer require bitExpert/prophiler-psr7-middleware  From there, you will need to create a factory for the middleware, and add it to\nyour middleware pipeline. Stephan Hochd\u00f6rfer, author of the package, has written\na  post detailing these steps .", 
            "title": "bitExpert/prophiler-psr7-middleware"
        }, 
        {
            "location": "/cookbook/debug-toolbars/#use-locally", 
            "text": "One minor change we recommend over the directions Stephan provides is that you\nconfigure the factory and middleware in the config/autoload/middleware-pipeline.local.php  file, vs the  .global  version.\nDoing so enables the middleware and toolbar only in the local environment  and not in production, where you likely do not want to expose such\ninformation!", 
            "title": "Use locally!"
        }, 
        {
            "location": "/cookbook/debug-toolbars/#php-middlewarephp-debug-bar", 
            "text": "php-middleware/php-debug-bar \nprovides a PSR-7 middleware wrapper around  maximebf/php-debugbar ,\na popular framework-agnostic debug bar for PHP projects.  First, install the middleware in your application:  $ composer require php-middleware/php-debug-bar  This package provides a factory for creating the middleware, so we only need to\nwire it into our middleware pipeline.  Create and edit the file config/autoload/middleware-pipeline.local.php  to read as follows:  use PhpMiddleware\\PhpDebugBar\\PhpDebugBarMiddleware;\nuse PhpMiddleware\\PhpDebugBar\\PhpDebugBarMiddlewareFactory;\n\nreturn [\n    'dependencies' =  [\n        'factories' =  [\n            PhpDebugBarMiddleware::class =  PhpDebugBarMiddlewareFactory::class,\n        ],\n    ],\n    'middleware_pipeline' =  [\n        [\n            'middleware' =  [\n                PhpDebugBarMiddleware::class,\n            ],\n            'priority' =  1000,\n        ],\n    ],\n];  These changes will activate the toolbar in your application.", 
            "title": "php-middleware/php-debug-bar"
        }, 
        {
            "location": "/cookbook/debug-toolbars/#use-locally_1", 
            "text": "You'll note that we specified the file  middleware-pipeline.local.php , and\nnot  middleware-pipeline.global.php . This ensures that the toolbar is only\nenabled in the local environment, and not committed to your production\nsettings.", 
            "title": "Use locally!"
        }, 
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/", 
            "text": "Handling multiple routes in a single class\n\n\nTypically, in Expressive, we would define one middleware class per route. For a\nstandard CRUD-style application, however, this leads to multiple related\nclasses:\n\n\n\n\nAlbumPageIndex\n\n\nAlbumPageEdit\n\n\nAlbumPageAdd\n\n\n\n\nIf you are familiar with frameworks that provide controllers capable of handling\nmultiple \"actions\", such as those found in Zend Framework 1 and 2, Symfony,\nCodeIgniter, CakePHP, and other popular frameworks, you may want to apply a\nsimilar pattern when using Expressive.\n\n\nIn other words, what if we want to use only one middleware class to facilitate\nall three of the above?\n\n\nIn the following example, we'll use an \naction\n routing parameter which our\nmiddleware class will use in order to determine which internal method to invoke.\n\n\nConsider the following route configuration:\n\n\nreturn [\n    /* ... */\n    'routes' =\n [\n        /* ... */\n        [\n            'name' =\n 'album',\n            'path' =\n '/album[/{action:add|edit}[/{id}]]',\n            'middleware' =\n Album\\Action\\AlbumPage::class,\n            'allowed_methods' =\n ['GET'],\n        ],\n        /* ... */\n    ],\n];\n\n\nThe above defines a route that will match any of the following:\n\n\n\n\n/album\n\n\n/album/add\n\n\n/album/edit/3\n\n\n\n\nThe \naction\n attribute can thus be one of \nadd\n or \nedit\n, and we can optionally\nalso receive an \nid\n attribute (in the latter example, it would be \n3\n).\n\n\n\n\nRouting definitions may vary\n\n\nDepending on the router you chose when starting your project, your routing\ndefinition may differ. The above example uses the default \nFastRoute\n\nimplementation.\n\n\n\n\nWe might then implement \nAlbum\\Action\\AlbumPage\n as follows:\n\n\nnamespace Album\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this-\ntemplate = $template;\n    }\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        switch ($request-\ngetAttribute('action', 'index')) {\n            case 'index':\n                return $this-\nindexAction($request, $response, $next);\n            case 'add':\n                return $this-\naddAction($request, $response, $next);\n            case 'edit':\n                return $this-\neditAction($request, $response, $next);\n            default:\n                // Invalid; thus, a 404!\n                return $response-\nwithStatus(404);\n        }\n    }\n\n    public function indexAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        return new HtmlResponse($this-\ntemplate-\nrender('album::album-page'));\n    }\n\n    public function addAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        return new HtmlResponse($this-\ntemplate-\nrender('album::album-page-add'));\n    }\n\n    public function editAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $id = $request-\ngetAttribute('id', false);\n        if (! $id) {\n            throw new \\InvalidArgumentException('id parameter must be provided');\n        }\n\n        return new HtmlResponse(\n            $this-\ntemplate-\nrender('album::album-page-edit', ['id' =\n $id])\n        );\n    }\n}\n\n\n\n\nThis allows us to have the same dependencies for a set of related actions, and,\nif desired, even have common internal methods each can utilize.\n\n\nThis approach is reasonable, but requires that I create a similar \n__invoke()\n\nimplementation every time I want to accomplish a similar workflow. Let's create\na generic implementation, via an \nAbstractPage\n class:\n\n\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nabstract class AbstractPage\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $action = $request-\ngetAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return $response-\nwithStatus(404);\n        }\n\n        return $this-\n$action($request, $response, $next);\n    }\n}\n\n\n\n\nThe above abstract class pulls the \naction\n attribute on invocation, and\nconcatenates it with the word \nAction\n. It then uses this value to determine if\na corresponding method exists in the current class, and, if so, calls it with\nthe arguments it received; otherwise, it returns a 404 response.\n\n\n\n\nInvoking the error stack\n\n\nInstead of returning a 404 response, you could also invoke \n$next()\n with an\nerror:\n\n\nreturn $next($request, $response, new NotFoundError());\n\n\n\n\nThis will then invoke the first error handler middleware capable of handling\nthe error.\n\n\n\n\nOur original \nAlbumPage\n implementation could then be modified to extend\n\nAbstractPage\n:\n\n\nnamespace Album\\Action;\n\nuse App\\Action\\AbstractPage;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage extends AbstractPage\n{\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this-\ntemplate = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}\n\n\n\n\n\n\nOr use a trait\n\n\nAs an alternative to an abstract class, you could define the \n__invoke()\n\nlogic in a trait, which you then compose into your middleware:\n\n\nnamespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ntrait ActionBasedInvocation\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $action = $request-\ngetAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return $response-\nwithStatus(404);\n        }\n\n        return $this-\n$action($request, $response, $next);\n    }\n}\n\n\n\n\nYou would then compose it into a class as follows:\n\n\nnamespace Album\\Action;\n\nuse App\\Action\\ActionBasedInvocation;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    use ActionBasedInvocation;\n\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this-\ntemplate = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}", 
            "title": "Handling multiple routes in a single class"
        }, 
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/#handling-multiple-routes-in-a-single-class", 
            "text": "Typically, in Expressive, we would define one middleware class per route. For a\nstandard CRUD-style application, however, this leads to multiple related\nclasses:   AlbumPageIndex  AlbumPageEdit  AlbumPageAdd   If you are familiar with frameworks that provide controllers capable of handling\nmultiple \"actions\", such as those found in Zend Framework 1 and 2, Symfony,\nCodeIgniter, CakePHP, and other popular frameworks, you may want to apply a\nsimilar pattern when using Expressive.  In other words, what if we want to use only one middleware class to facilitate\nall three of the above?  In the following example, we'll use an  action  routing parameter which our\nmiddleware class will use in order to determine which internal method to invoke.  Consider the following route configuration:  return [\n    /* ... */\n    'routes' =  [\n        /* ... */\n        [\n            'name' =  'album',\n            'path' =  '/album[/{action:add|edit}[/{id}]]',\n            'middleware' =  Album\\Action\\AlbumPage::class,\n            'allowed_methods' =  ['GET'],\n        ],\n        /* ... */\n    ],\n]; \n\nThe above defines a route that will match any of the following:   /album  /album/add  /album/edit/3   The  action  attribute can thus be one of  add  or  edit , and we can optionally\nalso receive an  id  attribute (in the latter example, it would be  3 ).", 
            "title": "Handling multiple routes in a single class"
        }, 
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/#routing-definitions-may-vary", 
            "text": "Depending on the router you chose when starting your project, your routing\ndefinition may differ. The above example uses the default  FastRoute \nimplementation.   We might then implement  Album\\Action\\AlbumPage  as follows:  namespace Album\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this- template = $template;\n    }\n\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        switch ($request- getAttribute('action', 'index')) {\n            case 'index':\n                return $this- indexAction($request, $response, $next);\n            case 'add':\n                return $this- addAction($request, $response, $next);\n            case 'edit':\n                return $this- editAction($request, $response, $next);\n            default:\n                // Invalid; thus, a 404!\n                return $response- withStatus(404);\n        }\n    }\n\n    public function indexAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        return new HtmlResponse($this- template- render('album::album-page'));\n    }\n\n    public function addAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        return new HtmlResponse($this- template- render('album::album-page-add'));\n    }\n\n    public function editAction(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $id = $request- getAttribute('id', false);\n        if (! $id) {\n            throw new \\InvalidArgumentException('id parameter must be provided');\n        }\n\n        return new HtmlResponse(\n            $this- template- render('album::album-page-edit', ['id' =  $id])\n        );\n    }\n}  This allows us to have the same dependencies for a set of related actions, and,\nif desired, even have common internal methods each can utilize.  This approach is reasonable, but requires that I create a similar  __invoke() \nimplementation every time I want to accomplish a similar workflow. Let's create\na generic implementation, via an  AbstractPage  class:  namespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nabstract class AbstractPage\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $action = $request- getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return $response- withStatus(404);\n        }\n\n        return $this- $action($request, $response, $next);\n    }\n}  The above abstract class pulls the  action  attribute on invocation, and\nconcatenates it with the word  Action . It then uses this value to determine if\na corresponding method exists in the current class, and, if so, calls it with\nthe arguments it received; otherwise, it returns a 404 response.", 
            "title": "Routing definitions may vary"
        }, 
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/#invoking-the-error-stack", 
            "text": "Instead of returning a 404 response, you could also invoke  $next()  with an\nerror:  return $next($request, $response, new NotFoundError());  This will then invoke the first error handler middleware capable of handling\nthe error.   Our original  AlbumPage  implementation could then be modified to extend AbstractPage :  namespace Album\\Action;\n\nuse App\\Action\\AbstractPage;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage extends AbstractPage\n{\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this- template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}", 
            "title": "Invoking the error stack"
        }, 
        {
            "location": "/cookbook/using-routed-middleware-class-as-controller/#or-use-a-trait", 
            "text": "As an alternative to an abstract class, you could define the  __invoke() \nlogic in a trait, which you then compose into your middleware:  namespace App\\Action;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\ntrait ActionBasedInvocation\n{\n    public function __invoke(\n        ServerRequestInterface $request,\n        ResponseInterface $response,\n        callable $next = null\n    ) {\n        $action = $request- getAttribute('action', 'index') . 'Action';\n\n        if (! method_exists($this, $action)) {\n            return $response- withStatus(404);\n        }\n\n        return $this- $action($request, $response, $next);\n    }\n}  You would then compose it into a class as follows:  namespace Album\\Action;\n\nuse App\\Action\\ActionBasedInvocation;\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\nuse Zend\\Diactoros\\Response\\HtmlResponse;\nuse Zend\\Expressive\\Template\\TemplateRendererInterface;\n\nclass AlbumPage\n{\n    use ActionBasedInvocation;\n\n    private $template;    \n\n    public function __construct(TemplateRendererInterface $template)\n    {\n        $this- template = $template;\n    }\n\n    public function indexAction( /* ... */ ) { /* ... */ }\n    public function addAction( /* ... */ ) { /* ... */ }\n    public function editAction( /* ... */ ) { /* ... */ }\n}", 
            "title": "Or use a trait"
        }, 
        {
            "location": "/cookbook/flash-messengers/", 
            "text": "How Can I Implement Flash Messages?\n\n\nFlash messages\n are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a\n\nPost/Redirect/Get (PRG)\n\nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.\n\n\nExpressive does not provide native session facilities out-of-the-box, which\nmeans you will need:\n\n\n\n\nSession functionality.\n\n\nFlash message functionality, for handling message expiry from the session\n  after first access.\n\n\n\n\nA number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are slim/flash and\ndamess/expressive-session-middleware.\n\n\nslim/flash\n\n\nSlim's \nFlash messages service provider\n can be \nused in Expressive. It uses PHP's native session support.\n\n\nFirst, you'll need to add it to your application:\n\n\n$ composer require slim/flash\n\n\n\n\nOnce you have, you'll need to create a factory to return middleware that will\nadd the flash message provider to the request:\n\n\nnamespace App;\n\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return function ($request, $response, $next) {\n            // Start the session whenever we use this!\n            session_start();\n\n            return $next(\n                $request-\nwithAttribute('flash', new Messages()),\n                $response\n            );\n        };\n    }\n}\n\n\n\n\nNow, let's register it with our middleware pipeline. In\n\nconfig/autoload/middleware-pipeline.global.php\n, make the following additions:\n\n\nreturn [\n    'dependencies' =\n [\n        'factories' =\n [\n            'App\\SlimFlashMiddleware' =\n App\\SlimFlashMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =\n [\n        'always' =\n [\n            'middleware' =\n [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' =\n 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\n\n\nWhere to register the flash middleware\n\n\nSessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead.\n\n\n\n\nFrom here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:\n\n\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\npublic function __invoke($request, $response, $next)\n{\n    $flash = $request-\ngetAttribute('flash');\n    $flash-\naddMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}\n\n\n\n\nAnd middleware consuming the message might read:\n\n\npublic function __invoke($request, $response, $next)\n{\n    $flash = $request-\ngetAttribute('flash');\n    $messages = $flash-\ngetMessages();\n    // ...\n}\n\n\n\n\nFrom there, it's a matter of providing the flash messages to your template.\n\n\ndamess/expressive-session-middleware and Aura.Session\n\n\ndamess/expressive-session-middleware\n\nprovides middleware for initializing an\n\nAura.Session\n instance; Aura.Session\nprovides flash messaging capabilities as part of its featureset.\n\n\nInstall it via Composer:\n\n\n$ composer require damess/expressive-session-middleware\n\n\n\n\nIn \nconfig/autoload/dependencies.global.php\n, add an entry for Aura.Session:\n\n\nreturn [\n    'dependencies' =\n [\n        'factories' =\n [\n            Aura\\Session\\Session::class =\n DaMess\\Factory\\AuraSessionFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\nIn \nconfig/autoload/middleware-pipeline.global.php\n, add a factory entry for the\n\ndamess/expressive-session-middleware\n, and add it to the middleware pipeline:\n\n\nreturn [\n    'dependencies' =\n [\n        'factories' =\n [\n            DaMess\\Http\\SessionMiddleware::class =\n DaMess\\Factory\\SessionMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =\n [\n        'always' =\n [\n            'middleware' =\n [\n                DaMess\\Http\\SessionMiddleware::class,\n                /* ... */\n            ],\n            'priority' =\n 10000,\n        ],\n        /* ... */\n    ],\n];\n\n\n\n\n\n\nWhere to register the session middleware\n\n\nSessions can sometimes be expensive. As such, you may not want the session\nmiddleware enabled for every request. If this is the case, add the session\nmiddleware as part of a route-specific pipeline instead.\n\n\n\n\nOnce enabled, the \nSessionMiddleware\n will inject the Aura.Session instance into\nthe request as the \nsession\n attribute; you can thus retrieve it within\nmiddleware using the following:\n\n\n$session = $request-\ngetAttribute('session');\n\n\n\n\nTo create and consume flash messages, use Aura.Session's\n\nflash values\n. As\nan example, the middleware that is processing a POST request might set a flash\nmessage:\n\n\nuse Zend\\Diactoros\\Response\\RedirectResponse;\n\npublic function __invoke($request, $response, $next)\n{\n    $session = $request-\ngetAttribute('session');\n    $session-\ngetSegment(__NAMESPACE__)\n            -\nsetFlash('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}\n\n\n\n\nAnother middleware, to which the original middleware redirects, might look like\nthis:\n\n\npublic function __invoke($request, $response, $next)\n{\n    $session = $request-\ngetAttribute('session');\n    $message = $session-\ngetSegment(__NAMESPACE__)\n                       -\ngetFlash('message');\n    // ...\n}\n\n\n\n\nFrom there, it's a matter of providing the flash messages to your template.", 
            "title": "Flash Messengers"
        }, 
        {
            "location": "/cookbook/flash-messengers/#how-can-i-implement-flash-messages", 
            "text": "Flash messages  are used to display one-time messages to a user. A typical use\ncase is for setting and later displaying a successful submission via a Post/Redirect/Get (PRG) \nworkflow, where the flash message would be set during the POST request, but\ndisplayed during the GET request. (PRG is used to prevent double-submission of\nforms.) As such, flash messages usually are session-based; the message is set in\none request, and accessed and cleared in another.  Expressive does not provide native session facilities out-of-the-box, which\nmeans you will need:   Session functionality.  Flash message functionality, for handling message expiry from the session\n  after first access.   A number of flash message libraries already exist that can be integrated via\nmiddleware, and these typically either use PHP's ext/session functionality or\nhave a dependency on a session library. Two such libraries are slim/flash and\ndamess/expressive-session-middleware.", 
            "title": "How Can I Implement Flash Messages?"
        }, 
        {
            "location": "/cookbook/flash-messengers/#slimflash", 
            "text": "Slim's  Flash messages service provider  can be \nused in Expressive. It uses PHP's native session support.  First, you'll need to add it to your application:  $ composer require slim/flash  Once you have, you'll need to create a factory to return middleware that will\nadd the flash message provider to the request:  namespace App;\n\nuse Slim\\Flash\\Messages;\n\nclass SlimFlashMiddlewareFactory\n{\n    public function __invoke($container)\n    {\n        return function ($request, $response, $next) {\n            // Start the session whenever we use this!\n            session_start();\n\n            return $next(\n                $request- withAttribute('flash', new Messages()),\n                $response\n            );\n        };\n    }\n}  Now, let's register it with our middleware pipeline. In config/autoload/middleware-pipeline.global.php , make the following additions:  return [\n    'dependencies' =  [\n        'factories' =  [\n            'App\\SlimFlashMiddleware' =  App\\SlimFlashMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =  [\n        'always' =  [\n            'middleware' =  [\n                'App\\SlimFlashMiddleware',\n                /* ... */\n            ],\n            'priority' =  10000,\n        ],\n        /* ... */\n    ],\n];", 
            "title": "slim/flash"
        }, 
        {
            "location": "/cookbook/flash-messengers/#where-to-register-the-flash-middleware", 
            "text": "Sessions can sometimes be expensive. As such, you may not want the flash\nmiddleware enabled for every request. If this is the case, add the flash\nmiddleware as part of a route-specific pipeline instead.   From here, you can add and read messages by accessing the request's flash\nattribute. As an example, middleware generating messages might read as follows:  use Zend\\Diactoros\\Response\\RedirectResponse;\n\npublic function __invoke($request, $response, $next)\n{\n    $flash = $request- getAttribute('flash');\n    $flash- addMessage('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}  And middleware consuming the message might read:  public function __invoke($request, $response, $next)\n{\n    $flash = $request- getAttribute('flash');\n    $messages = $flash- getMessages();\n    // ...\n}  From there, it's a matter of providing the flash messages to your template.", 
            "title": "Where to register the flash middleware"
        }, 
        {
            "location": "/cookbook/flash-messengers/#damessexpressive-session-middleware-and-aurasession", 
            "text": "damess/expressive-session-middleware \nprovides middleware for initializing an Aura.Session  instance; Aura.Session\nprovides flash messaging capabilities as part of its featureset.  Install it via Composer:  $ composer require damess/expressive-session-middleware  In  config/autoload/dependencies.global.php , add an entry for Aura.Session:  return [\n    'dependencies' =  [\n        'factories' =  [\n            Aura\\Session\\Session::class =  DaMess\\Factory\\AuraSessionFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n];  In  config/autoload/middleware-pipeline.global.php , add a factory entry for the damess/expressive-session-middleware , and add it to the middleware pipeline:  return [\n    'dependencies' =  [\n        'factories' =  [\n            DaMess\\Http\\SessionMiddleware::class =  DaMess\\Factory\\SessionMiddlewareFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    'middleware_pipeline' =  [\n        'always' =  [\n            'middleware' =  [\n                DaMess\\Http\\SessionMiddleware::class,\n                /* ... */\n            ],\n            'priority' =  10000,\n        ],\n        /* ... */\n    ],\n];", 
            "title": "damess/expressive-session-middleware and Aura.Session"
        }, 
        {
            "location": "/cookbook/flash-messengers/#where-to-register-the-session-middleware", 
            "text": "Sessions can sometimes be expensive. As such, you may not want the session\nmiddleware enabled for every request. If this is the case, add the session\nmiddleware as part of a route-specific pipeline instead.   Once enabled, the  SessionMiddleware  will inject the Aura.Session instance into\nthe request as the  session  attribute; you can thus retrieve it within\nmiddleware using the following:  $session = $request- getAttribute('session');  To create and consume flash messages, use Aura.Session's flash values . As\nan example, the middleware that is processing a POST request might set a flash\nmessage:  use Zend\\Diactoros\\Response\\RedirectResponse;\n\npublic function __invoke($request, $response, $next)\n{\n    $session = $request- getAttribute('session');\n    $session- getSegment(__NAMESPACE__)\n            - setFlash('message', 'Hello World!');\n\n    return new RedirectResponse('/other-middleware');\n}  Another middleware, to which the original middleware redirects, might look like\nthis:  public function __invoke($request, $response, $next)\n{\n    $session = $request- getAttribute('session');\n    $message = $session- getSegment(__NAMESPACE__)\n                       - getFlash('message');\n    // ...\n}  From there, it's a matter of providing the flash messages to your template.", 
            "title": "Where to register the session middleware"
        }, 
        {
            "location": "/reference/usage-examples/", 
            "text": "Usage Examples\n\n\nBelow are several usage examples, covering a variety of ways of creating and\nmanaging an application.\n\n\nIn all examples, the assumption is the following directory structure:\n\n\n.\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 public\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 vendor\n\n\n\n\nWe assume also that:\n\n\n\n\nYou have installed zend-expressive per the \ninstallation instructions\n.\n\n\npublic/\n will be the document root of your application.\n\n\nYour own classes are under \nsrc/\n with the top-level namespace \nApplication\n,\n  and you have configured \nautoloading\n in your \ncomposer.json\n for those classes.\n\n\n\n\n\n\nUsing the built-in web server\n\n\nYou can use the built-in web server to run the examples. Run:\n\n\n$ php -S 0.0.0.0:8080 -t public\n\n\n\n\nfrom the application root to start up a web server running on port 8080, and\nthen browse to http://localhost:8080/. If you used the Expressive installer,\nthe following is equivalent:\n\n\n$ composer serve\n\n\n\n\nSetting up autoloading for the Application namespace\n\n\nIn your \ncomposer.json\n file, place the following:\n\n\nautoload\n: {\n    \npsr-4\n: {\n        \nApplication\\\\\n: \nsrc/\n\n    }\n},\n\n\n\n\nOnce done, run:\n\n\n$ composer dump-autoload\n\n\n\n\n\n\nRouting\n\n\nAs noted in the \nApplication documentation\n,\nrouting is abstracted and can be accomplished by calling any of the following\nmethods:\n\n\n\n\nroute($path, $middleware, array $methods = null, $name = null)\n to route to a\n  path and match any HTTP method, multiple HTTP methods, or custom HTTP methods.\n\n\nget($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the GET HTTP method.\n\n\npost($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the POST HTTP method.\n\n\nput($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the PUT HTTP method.\n\n\npatch($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the PATCH HTTP method.\n\n\ndelete($path, $middleware, $name = null)\n to route to a path that will only\n  respond to the DELETE HTTP method.\n\n\n\n\nAll methods return a \nZend\\Expressive\\Router\\Route\n method, which allows you to\nspecify additional options to associate with the route (e.g., for specifying\ncriteria, default values to match, etc.).\n\n\nAs examples:\n\n\n// GET\n// This demonstrates passing a callable middleware (assuming $helloWorld is\n// callable).\n$app-\nget('/', $helloWorld);\n\n// POST\n// This example specifies the middleware as a service name instead of as a\n// callable.\n$app-\npost('/trackback', 'TrackBack');\n\n// PUT\n// This example shows operating on the returned route. In this case, it's adding\n// regex tokens to restrict what values for {id} will match. (The tokens feature\n// is specific to Aura.Router.)\n$app-\nput('/post/{id}', 'ReplacePost')\n    -\nsetOptions([\n        'tokens' =\n [ 'id' =\n '\\d+' ],\n    ]);\n\n// PATCH\n// This example builds on the one above. Expressive allows you to specify\n// the same path for a route matching on a different HTTP method, and\n// corresponding to different middleware.\n$app-\npatch('/post/{id}', 'UpdatePost')\n    -\nsetOptions([\n        'tokens' =\n [ 'id' =\n '\\d+' ],\n    ]);\n\n// DELETE\n$app-\ndelete('/post/{id}', 'DeletePost')\n    -\nsetOptions([\n        'tokens' =\n [ 'id' =\n '\\d+' ],\n    ]);\n\n// Matching ALL HTTP methods\n// If the underlying router supports matching any HTTP method, the following\n// will do so. Note: FastRoute *requires* you to specify the HTTP methods\n// allowed explicitly, and does not support wildcard routes. As such, the\n// following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH,\n// PUT, TRACE, and DELETE.\n// Just like the previous examples, it returns a Route instance that you can\n// further manipulate.\n$app-\nroute('/post/{id}', 'HandlePost')\n    -\nsetOptions([\n        'tokens' =\n [ 'id' =\n '\\d+' ],\n    ]);\n\n// Matching multiple HTTP methods\n// You can pass an array of HTTP methods as a third argument to route(); in such\n// cases, routing will match if any of the specified HTTP methods are provided.\n$app-\nroute('/post', 'HandlePostCollection', ['GET', 'POST']);\n\n// Matching NO HTTP methods\n// Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be\n// honored. (In FastRoute, GET is also honored.)\n$app-\nroute('/post', 'WillThisHandlePost', []);\n\n\n\n\nFinally, if desired, you can create a \nZend\\Expressive\\Router\\Route\n instance\nmanually and pass it to \nroute()\n as the sole argument:\n\n\n$route = new Route('/post', 'HandlePost', ['GET', 'POST']);\n$route-\nsetOptions($options);\n\n$app-\nroute($route);\n\n\n\n\nHello World using a Container\n\n\nExpressive works with \ncontainer-interop\n,\nthough it's an optional feature. By default, if you use the \nAppFactory\n, it\nwill use \nzend-servicemanager\n.\n\n\nIn the following example, we'll populate the container with our middleware, and\nthe application will pull it from there when matched.\n\n\nEdit your \npublic/index.php\n to read as follows:\n\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$container = new ServiceManager();\n\n$container-\nsetFactory('HelloWorld', function ($container) {\n    return function ($req, $res, $next) {\n        $res-\nwrite('Hello, world!');\n        return $res;\n    };\n});\n\n$container-\nsetFactory('Ping', function ($container) {\n    return function ($req, $res, $next) {\n        return new JsonResponse(['ack' =\n time()]);\n    };\n});\n\n$app = AppFactory::create($container);\n$app-\nget('/', 'HelloWorld');\n$app-\nget('/ping', 'Ping');\n\n$app-\npipeRoutingMiddleware();\n$app-\npipeDispatchMiddleware();\n\n$app-\nrun();\n\n\n\n\nIn the example above, we pass our container to \nAppFactory\n. We could have also\ndone this instead:\n\n\n$app = AppFactory::create();\n$container = $app-\ngetContainer();\n\n\n\n\nand then added our service definitions. We recommend passing the container to\nthe factory instead; if we ever change which container we use by default, your\ncode might not work!\n\n\nThe following two lines are the ones of interest:\n\n\n$app-\nget('/', 'HelloWorld');\n$app-\nget('/ping', 'Ping');\n\n\n\n\nThese map the two paths to \nservice names\n instead of callables. When routing\nmatches a path, it does the following:\n\n\n\n\nIf the middleware provided when defining the route is callable, it uses it\n  directly.\n\n\nIf the middleware is a valid service name in the container, it pulls it from\n  the container. \nThis is what happens in this example.\n\n\nFinally, if no container is available, or the service name is not found in the\n  container, it checks to see if it's a valid class name; if so, it instantiates\n  and returns the class instance.\n\n\n\n\nIf you fire up your web server, you'll find that the \n/\n and \n/ping\n paths\ncontinue to work.\n\n\nOne other approach you could take would be to define the application itself in\nthe container, and then pull it from there:\n\n\n$container-\nsetFactory('Zend\\Expressive\\Application', function ($container) {\n    $app = AppFactory::create($container);\n    $app-\nget('/', 'HelloWorld');\n    $app-\nget('/ping', 'Ping');\n    return $app;\n});\n\n$app = $container-\nget('Zend\\Expressive\\Application');\n$app-\nrun();\n\n\n\n\nThis is a nice way to encapsulate the application creation. You could then\npotentially move all service configuration to another file! (We already\n\ndocument an ApplicationFactory for exactly this scenario.\n)\n\n\nHello World using a Configuration-Driven Container\n\n\nIn the above example, we configured our middleware as services, and then passed\nour service container to the application. At the end, we hinted that you could\npotentially define the application itself as a service.\n\n\nExpressive already provides a service factory for the application instance\nto provide fine-grained control over your application. In this example, we'll\nleverage it, defining our routes via configuration.\n\n\nFirst, we're going to leverage zend-config to merge configuration files. This is\nimportant, as it allows us to define local, environment-specific configuration\nin files that we then can exclude from our repository. This practice ensures\nthat things like credentials are not accidentally published in a public\nrepository, and also provides a mechanism for slip-streaming in\nconfiguration based on our environment (you might use different settings in\ndevelopment than in production, after all!).\n\n\nFirst, install zend-config and zend-stdlib:\n\n\n$ composer require zendframework/zend-config zendframework/zend-stdlib\n\n\n\n\nNow we can start creating our configuration files and container factories.\n\n\nIn \nconfig/config.php\n, place the following:\n\n\n?php\n\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Stdlib\\Glob;\n\n$config = [];\n// Load configuration from autoload path\nforeach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) {\n    $config = ArrayUtils::merge($config, include $file);\n}\n\n// Return an ArrayObject so we can inject the config as a service in Aura.Di\n// and still use array checks like ``is_array``.\nreturn new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS);\n\n\n\n\nIn \nconfig/container.php\n, place the following:\n\n\n?php\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// Load configuration\n$config = require __DIR__.'/config.php';\n\n// Build container\n$container = new ServiceManager();\n(new Config($config['dependencies']))-\nconfigureServiceManager($container);\n\n// Inject config\n$container-\nsetService('config', $config);\n\nreturn $container;\n\n\n\n\nIn \nconfig/autoload/dependencies.global.php\n, place the following:\n\n\n?php\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'dependencies' =\n [\n        'invokables' =\n [\n            \\Application\\HelloWorldAction::class =\n InvokableFactory::class,\n            \\Application\\PingAction::class =\n InvokableFactory::class,\n        ],\n        'factories' =\n [\n            \\Zend\\Expressive\\Application::class =\n \\Zend\\Expressive\\Container\\ApplicationFactory::class,\n        ],\n    ]\n];\n\n\n\n\nIn \nconfig/autoload/routes.global.php\n, place the following:\n\n\n?php\n\nreturn [\n    'routes' =\n [\n        [\n            'path' =\n '/',\n            'middleware' =\n \\Application\\HelloWorldAction::class,\n            'allowed_methods' =\n [ 'GET' ],\n        ],\n        [\n            'path' =\n '/ping',\n            'middleware' =\n \\Application\\PingAction::class,\n            'allowed_methods' =\n [ 'GET' ],\n        ],\n    ],\n];\n\n\n\n\nIn \nsrc/Application/HelloWorld.php\n, place the following:\n\n\n?php\nnamespace Application;\n\nclass HelloWorld\n{\n    public function __invoke($req, $res, $next)\n    {\n        $res-\nwrite('Hello, world!');\n        return $res;\n    }\n}\n\n\n\n\nIn \nsrc/Application/Ping.php\n, place the following:\n\n\n?php\nnamespace Application;\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass Ping\n{\n    public function __invoke($req, $res, $next)\n    {\n        return new JsonResponse(['ack' =\n time()]);\n    }\n}\n\n\n\n\nAfter that\u2019s done run:\n\n\ncomposer dump-autoload\n\n\n\n\nFinally, in \npublic/index.php\n, place the following:\n\n\n?php\n// Change to the project root, to simplify resolving paths\nchdir(dirname(__DIR__));\n\n// Setup autoloading\nrequire 'vendor/autoload.php';\n\n$container = include 'config/services.php';\n$app       = $container-\nget(Zend\\Expressive\\Application::class);\n$app-\nrun();\n\n\n\n\nNotice that our index file now doesn't have any code related to setting up the\napplication any longer! All it does is setup autoloading, retrieve our service\ncontainer, pull the application from it, and run it. Our choices for container,\nrouter, etc. are all abstracted, and if we change our mind later, this code will\ncontinue to work.\n\n\nFiring up the web server, you'll see the same responses as the previous\nexamples.\n\n\nHybrid Container and Programmatic Creation\n\n\nThe above example may look a little daunting at first. By making everything\nconfiguration-driven, you sometimes lose a sense for how the code all fits\ntogether.\n\n\nFortunately, you can mix the two. Building on the example above, we'll add a new\nroute and middleware. Between pulling the application from the container and\ncalling \n$app-\nrun()\n, add the following in your \npublic/index.php\n:\n\n\n$app-\npost('/post', function ($req, $res, $next) {\n    $res-\nwrite('IN POST!');\n    return $res;\n});\n\n\n\n\nNote that we're using \npost()\n here; that means you'll have to use cURL, HTTPie,\nPostman, or some other tool to test making a POST request to the path:\n\n\n$ curl -X POST http://localhost:8080/post\n\n\n\n\nYou should see \nIN POST!\n for the response!\n\n\nUsing this approach, you can build re-usable applications that are\ncontainer-driven, and add one-off routes and middleware as needed.\n\n\nUsing the container to register middleware\n\n\nIf you use a container to fetch your application instance, you have an\nadditional option for specifying middleware for the pipeline: configuration:\n\n\n?php\nreturn [\n    'routes' =\n [\n        [\n            'path' =\n '/path/to/match',\n            'middleware' =\n 'Middleware Service Name or Callable',\n            'allowed_methods' =\n [ 'GET', 'POST', 'PATCH' ],\n            'options' =\n [\n                'stuff' =\n 'to',\n                'pass'  =\n 'to',\n                'the'   =\n 'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n    'middleware_pipeline' =\n [\n        // See specification below\n    ],\n];\n\n\n\n\nThe key to note is \nmiddleware_pipeline\n, which is an array of middlewares to\nregister in the pipeline; each will each be \npipe()\n'd to the Application in the\norder specified.\n\n\nEach middleware specified must be in the following form:\n\n\n[\n    // required:\n    'middleware' =\n 'Name of middleware service, or a callable',\n    // optional:\n    'path'  =\n '/path/to/match',\n    'error' =\n true,\n    'priority' =\n 1, // Integer\n]\n\n\n\n\nPriority should be an integer, and follows the semantics of\n\nSplPriorityQueue\n: higher numbers indicate\nhigher priority (top of the queue; executed earliest), while lower numbers\nindicated lower priority (bottom of the queue, executed last); \nnegative values\nare low priority\n. Items of the same priority are executed in the order in which\nthey are attached.\n\n\nThe default priority is 1, and this priority is used by the routing and dispatch\nmiddleware. To indicate that middleware should execute \nbefore\n these, use a\npriority higher than 1. For error middleware, use a priority less than 1.\n\n\nThe above specification can be used for all middleware, with one exception:\nregistration of the \nrouting\n and/or \ndispatch\n middleware that Expressive\nprovides. In these cases, use the following constants, which will be caught by\nthe factory and expanded:\n\n\n\n\nZend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE\n for the\n  routing middleware; this should always come before the dispatch middleware.\n\n\nZend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE\n for the\n  dispatch middleware.\n\n\n\n\nAs an example:\n\n\nreturn [\n    'middleware_pipeline' =\n [\n        [ /* ... */ ],\n        Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n        Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        [ /* ... */ ],\n    ],\n];\n\n\n\n\n\n\nPlace routing middleware correctly\n\n\nIf you are defining routes \nand\n defining other middleware for the pipeline,\nyou \nmust\n add the routing middleware. When you do so, make sure you put\nit at the appropriate location in the pipeline.\n\n\nTypically, you will place any middleware you want to execute on all requests\nprior to the routing middleware. This includes utilities for bootstrapping\nthe application (such as injection of the \nServerUrlHelper\n),\nutilities for injecting common response headers (such as CORS support), etc.\nMake sure these middleware specifications include the \npriority\n key, and that\nthe value of this key is greater than 1.\n\n\nPlace \nerror\n middleware \nafter\n the routing middleware. This is middleware\nthat should only execute if routing fails or routed middleware cannot complete\nthe response. These specifications should also include the \npriority\n key, and\nthe value of that key for such middleware should be less than 1 or negative.\n\n\nUse priority to shape the specific workflow you want for your middleware.\n\n\n\n\nMiddleware items may be any callable, \nZend\\Stratigility\\MiddlewareInterface\n\nimplementation, or a service name that resolves to one of the two. Additionally,\nyou can specify an array of such values; these will be composed in a single\n\nZend\\Stratigility\\MiddlewarePipe\n instance, allowing layering of middleware.\nIn fact, you can specify the various \nApplicationFactory::*_MIDDLEWARE\n\nconstants in such arrays as well:\n\n\nreturn [\n    'middleware_pipeline' =\n [\n        [ /* ... */ ],\n        'routing' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                /* ... middleware that introspects routing results ... */\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n        [ /* ... */ ],\n    ],\n];\n\n\n\n\n\n\nPipeline keys are ignored\n\n\nKeys in a \nmiddleware_pipeline\n specification are ignored. However, they can\nbe useful when merging several configurations; if multiple configuration files\nspecify the same key, then those entries will be merged. Be aware, however,\nthat the \nmiddleware\n entry for each, since it is an indexed array, will\nmerge arrays by appending; in other words, order will not be guaranteed within\nthat array after merging. If order is critical, define a middleware spec with\n\npriority\n keys.\n\n\n\n\nThe path, if specified, can only be a literal path to match, and is typically\nused for segregating middleware applications or applying rules to subsets of an\napplication that match a common path root.\n\n\nerror\n indicates whether or not the middleware represents error middleware;\nthis is done to ensure that lazy-loading of error middleware works as expected.\n\n\n\n\nLazy-loaded Middleware\n\n\nOne feature of the \nmiddleware_pipeline\n is that any middleware service pulled\nfrom the container is actually wrapped in a closure:\n\n\nfunction ($request, $response, $next = null) use ($container, $middleware) {\n    $invokable = $container-\nget($middleware);\n    if (! is_callable($invokable)) {\n        throw new Exception\\InvalidMiddlewareException(sprintf(\n            'Lazy-loaded middleware \n%s\n is not invokable',\n            $middleware\n        ));\n    }\n    return $invokable($request, $response, $next);\n};\n\n\n\n\nIf the \nerror\n flag is specified and is truthy, the closure looks like this\ninstead, to ensure the middleware is treated by Stratigility as error\nmiddleware:\n\n\nfunction ($error, $request, $response, $next) use ($container, $middleware) {\n    $invokable = $container-\nget($middleware);\n    if (! is_callable($invokable)) {\n        throw new Exception\\InvalidMiddlewareException(sprintf(\n            'Lazy-loaded middleware \n%s\n is not invokable',\n            $middleware\n        ));\n    }\n    return $invokable($error, $request, $response, $next);\n};\n\n\n\n\nThis implements \nlazy-loading\n for middleware pipeline services, delaying\nretrieval from the container until the middleware is actually invoked.\n\n\nThis also means that if the service specified is not valid middleware, you\nwill not find out until the application attempts to invoke it.\n\n\n\n\nSegregating your application to a subpath\n\n\nOne benefit of a middleware-based application is the ability to compose\nmiddleware and segregate them by paths. \nZend\\Expressive\\Application\n is itself\nmiddleware, allowing you to do exactly that if desired.\n\n\nIn the following example, we'll assume that \n$api\n and \n$blog\n are\n\nZend\\Expressive\\Application\n instances, and compose them into a\n\nZend\\Stratigility\\MiddlewarePipe\n.\n\n\nuse Zend\\Diactoros\\Server;\nuse Zend\\Diactoros\\ServerRequestFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app-\npipe('/blog', $blog);\n$app-\npipe('/api', $api);\n\n$server = Server::createServerFromRequest(\n    $app,\n    ServerRequestFactory::fromGlobals()\n);\n$server-\nlisten();\n\n\n\n\nYou could also compose them in an \nApplication\n instance, and utilize \nrun()\n:\n\n\n$app = AppFactory::create();\n$app-\npipe('/blog', $blog);\n$app-\npipe('/api', $api);\n\n$app-\nrun();\n\n\n\n\nThis approach allows you to develop discrete applications and compose them\ntogether to create a website.", 
            "title": "Examples"
        }, 
        {
            "location": "/reference/usage-examples/#usage-examples", 
            "text": "Below are several usage examples, covering a variety of ways of creating and\nmanaging an application.  In all examples, the assumption is the following directory structure:  .\n\u251c\u2500\u2500 config\n\u251c\u2500\u2500 data\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 public\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 index.php\n\u251c\u2500\u2500 src\n\u2514\u2500\u2500 vendor  We assume also that:   You have installed zend-expressive per the  installation instructions .  public/  will be the document root of your application.  Your own classes are under  src/  with the top-level namespace  Application ,\n  and you have configured  autoloading  in your  composer.json  for those classes.", 
            "title": "Usage Examples"
        }, 
        {
            "location": "/reference/usage-examples/#using-the-built-in-web-server", 
            "text": "You can use the built-in web server to run the examples. Run:  $ php -S 0.0.0.0:8080 -t public  from the application root to start up a web server running on port 8080, and\nthen browse to http://localhost:8080/. If you used the Expressive installer,\nthe following is equivalent:  $ composer serve", 
            "title": "Using the built-in web server"
        }, 
        {
            "location": "/reference/usage-examples/#setting-up-autoloading-for-the-application-namespace", 
            "text": "In your  composer.json  file, place the following:  autoload : {\n     psr-4 : {\n         Application\\\\ :  src/ \n    }\n},  Once done, run:  $ composer dump-autoload", 
            "title": "Setting up autoloading for the Application namespace"
        }, 
        {
            "location": "/reference/usage-examples/#routing", 
            "text": "As noted in the  Application documentation ,\nrouting is abstracted and can be accomplished by calling any of the following\nmethods:   route($path, $middleware, array $methods = null, $name = null)  to route to a\n  path and match any HTTP method, multiple HTTP methods, or custom HTTP methods.  get($path, $middleware, $name = null)  to route to a path that will only\n  respond to the GET HTTP method.  post($path, $middleware, $name = null)  to route to a path that will only\n  respond to the POST HTTP method.  put($path, $middleware, $name = null)  to route to a path that will only\n  respond to the PUT HTTP method.  patch($path, $middleware, $name = null)  to route to a path that will only\n  respond to the PATCH HTTP method.  delete($path, $middleware, $name = null)  to route to a path that will only\n  respond to the DELETE HTTP method.   All methods return a  Zend\\Expressive\\Router\\Route  method, which allows you to\nspecify additional options to associate with the route (e.g., for specifying\ncriteria, default values to match, etc.).  As examples:  // GET\n// This demonstrates passing a callable middleware (assuming $helloWorld is\n// callable).\n$app- get('/', $helloWorld);\n\n// POST\n// This example specifies the middleware as a service name instead of as a\n// callable.\n$app- post('/trackback', 'TrackBack');\n\n// PUT\n// This example shows operating on the returned route. In this case, it's adding\n// regex tokens to restrict what values for {id} will match. (The tokens feature\n// is specific to Aura.Router.)\n$app- put('/post/{id}', 'ReplacePost')\n    - setOptions([\n        'tokens' =  [ 'id' =  '\\d+' ],\n    ]);\n\n// PATCH\n// This example builds on the one above. Expressive allows you to specify\n// the same path for a route matching on a different HTTP method, and\n// corresponding to different middleware.\n$app- patch('/post/{id}', 'UpdatePost')\n    - setOptions([\n        'tokens' =  [ 'id' =  '\\d+' ],\n    ]);\n\n// DELETE\n$app- delete('/post/{id}', 'DeletePost')\n    - setOptions([\n        'tokens' =  [ 'id' =  '\\d+' ],\n    ]);\n\n// Matching ALL HTTP methods\n// If the underlying router supports matching any HTTP method, the following\n// will do so. Note: FastRoute *requires* you to specify the HTTP methods\n// allowed explicitly, and does not support wildcard routes. As such, the\n// following example maps to the combination of HEAD, OPTIONS, GET, POST, PATCH,\n// PUT, TRACE, and DELETE.\n// Just like the previous examples, it returns a Route instance that you can\n// further manipulate.\n$app- route('/post/{id}', 'HandlePost')\n    - setOptions([\n        'tokens' =  [ 'id' =  '\\d+' ],\n    ]);\n\n// Matching multiple HTTP methods\n// You can pass an array of HTTP methods as a third argument to route(); in such\n// cases, routing will match if any of the specified HTTP methods are provided.\n$app- route('/post', 'HandlePostCollection', ['GET', 'POST']);\n\n// Matching NO HTTP methods\n// Pass an empty array to the HTTP methods. HEAD and OPTIONS will still be\n// honored. (In FastRoute, GET is also honored.)\n$app- route('/post', 'WillThisHandlePost', []);  Finally, if desired, you can create a  Zend\\Expressive\\Router\\Route  instance\nmanually and pass it to  route()  as the sole argument:  $route = new Route('/post', 'HandlePost', ['GET', 'POST']);\n$route- setOptions($options);\n\n$app- route($route);", 
            "title": "Routing"
        }, 
        {
            "location": "/reference/usage-examples/#hello-world-using-a-container", 
            "text": "Expressive works with  container-interop ,\nthough it's an optional feature. By default, if you use the  AppFactory , it\nwill use  zend-servicemanager .  In the following example, we'll populate the container with our middleware, and\nthe application will pull it from there when matched.  Edit your  public/index.php  to read as follows:  use Zend\\Diactoros\\Response\\JsonResponse;\nuse Zend\\Expressive\\AppFactory;\nuse Zend\\ServiceManager\\ServiceManager;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$container = new ServiceManager();\n\n$container- setFactory('HelloWorld', function ($container) {\n    return function ($req, $res, $next) {\n        $res- write('Hello, world!');\n        return $res;\n    };\n});\n\n$container- setFactory('Ping', function ($container) {\n    return function ($req, $res, $next) {\n        return new JsonResponse(['ack' =  time()]);\n    };\n});\n\n$app = AppFactory::create($container);\n$app- get('/', 'HelloWorld');\n$app- get('/ping', 'Ping');\n\n$app- pipeRoutingMiddleware();\n$app- pipeDispatchMiddleware();\n\n$app- run();  In the example above, we pass our container to  AppFactory . We could have also\ndone this instead:  $app = AppFactory::create();\n$container = $app- getContainer();  and then added our service definitions. We recommend passing the container to\nthe factory instead; if we ever change which container we use by default, your\ncode might not work!  The following two lines are the ones of interest:  $app- get('/', 'HelloWorld');\n$app- get('/ping', 'Ping');  These map the two paths to  service names  instead of callables. When routing\nmatches a path, it does the following:   If the middleware provided when defining the route is callable, it uses it\n  directly.  If the middleware is a valid service name in the container, it pulls it from\n  the container.  This is what happens in this example.  Finally, if no container is available, or the service name is not found in the\n  container, it checks to see if it's a valid class name; if so, it instantiates\n  and returns the class instance.   If you fire up your web server, you'll find that the  /  and  /ping  paths\ncontinue to work.  One other approach you could take would be to define the application itself in\nthe container, and then pull it from there:  $container- setFactory('Zend\\Expressive\\Application', function ($container) {\n    $app = AppFactory::create($container);\n    $app- get('/', 'HelloWorld');\n    $app- get('/ping', 'Ping');\n    return $app;\n});\n\n$app = $container- get('Zend\\Expressive\\Application');\n$app- run();  This is a nice way to encapsulate the application creation. You could then\npotentially move all service configuration to another file! (We already document an ApplicationFactory for exactly this scenario. )", 
            "title": "Hello World using a Container"
        }, 
        {
            "location": "/reference/usage-examples/#hello-world-using-a-configuration-driven-container", 
            "text": "In the above example, we configured our middleware as services, and then passed\nour service container to the application. At the end, we hinted that you could\npotentially define the application itself as a service.  Expressive already provides a service factory for the application instance\nto provide fine-grained control over your application. In this example, we'll\nleverage it, defining our routes via configuration.  First, we're going to leverage zend-config to merge configuration files. This is\nimportant, as it allows us to define local, environment-specific configuration\nin files that we then can exclude from our repository. This practice ensures\nthat things like credentials are not accidentally published in a public\nrepository, and also provides a mechanism for slip-streaming in\nconfiguration based on our environment (you might use different settings in\ndevelopment than in production, after all!).  First, install zend-config and zend-stdlib:  $ composer require zendframework/zend-config zendframework/zend-stdlib  Now we can start creating our configuration files and container factories.  In  config/config.php , place the following:  ?php\n\nuse Zend\\Stdlib\\ArrayUtils;\nuse Zend\\Stdlib\\Glob;\n\n$config = [];\n// Load configuration from autoload path\nforeach (Glob::glob('config/autoload/{{,*.}global,{,*.}local}.php', Glob::GLOB_BRACE) as $file) {\n    $config = ArrayUtils::merge($config, include $file);\n}\n\n// Return an ArrayObject so we can inject the config as a service in Aura.Di\n// and still use array checks like ``is_array``.\nreturn new ArrayObject($config, ArrayObject::ARRAY_AS_PROPS);  In  config/container.php , place the following:  ?php\n\nuse Zend\\ServiceManager\\Config;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// Load configuration\n$config = require __DIR__.'/config.php';\n\n// Build container\n$container = new ServiceManager();\n(new Config($config['dependencies']))- configureServiceManager($container);\n\n// Inject config\n$container- setService('config', $config);\n\nreturn $container;  In  config/autoload/dependencies.global.php , place the following:  ?php\n\nuse Zend\\ServiceManager\\Factory\\InvokableFactory;\n\nreturn [\n    'dependencies' =  [\n        'invokables' =  [\n            \\Application\\HelloWorldAction::class =  InvokableFactory::class,\n            \\Application\\PingAction::class =  InvokableFactory::class,\n        ],\n        'factories' =  [\n            \\Zend\\Expressive\\Application::class =  \\Zend\\Expressive\\Container\\ApplicationFactory::class,\n        ],\n    ]\n];  In  config/autoload/routes.global.php , place the following:  ?php\n\nreturn [\n    'routes' =  [\n        [\n            'path' =  '/',\n            'middleware' =  \\Application\\HelloWorldAction::class,\n            'allowed_methods' =  [ 'GET' ],\n        ],\n        [\n            'path' =  '/ping',\n            'middleware' =  \\Application\\PingAction::class,\n            'allowed_methods' =  [ 'GET' ],\n        ],\n    ],\n];  In  src/Application/HelloWorld.php , place the following:  ?php\nnamespace Application;\n\nclass HelloWorld\n{\n    public function __invoke($req, $res, $next)\n    {\n        $res- write('Hello, world!');\n        return $res;\n    }\n}  In  src/Application/Ping.php , place the following:  ?php\nnamespace Application;\n\nuse Zend\\Diactoros\\Response\\JsonResponse;\n\nclass Ping\n{\n    public function __invoke($req, $res, $next)\n    {\n        return new JsonResponse(['ack' =  time()]);\n    }\n}  After that\u2019s done run:  composer dump-autoload  Finally, in  public/index.php , place the following:  ?php\n// Change to the project root, to simplify resolving paths\nchdir(dirname(__DIR__));\n\n// Setup autoloading\nrequire 'vendor/autoload.php';\n\n$container = include 'config/services.php';\n$app       = $container- get(Zend\\Expressive\\Application::class);\n$app- run();  Notice that our index file now doesn't have any code related to setting up the\napplication any longer! All it does is setup autoloading, retrieve our service\ncontainer, pull the application from it, and run it. Our choices for container,\nrouter, etc. are all abstracted, and if we change our mind later, this code will\ncontinue to work.  Firing up the web server, you'll see the same responses as the previous\nexamples.", 
            "title": "Hello World using a Configuration-Driven Container"
        }, 
        {
            "location": "/reference/usage-examples/#hybrid-container-and-programmatic-creation", 
            "text": "The above example may look a little daunting at first. By making everything\nconfiguration-driven, you sometimes lose a sense for how the code all fits\ntogether.  Fortunately, you can mix the two. Building on the example above, we'll add a new\nroute and middleware. Between pulling the application from the container and\ncalling  $app- run() , add the following in your  public/index.php :  $app- post('/post', function ($req, $res, $next) {\n    $res- write('IN POST!');\n    return $res;\n});  Note that we're using  post()  here; that means you'll have to use cURL, HTTPie,\nPostman, or some other tool to test making a POST request to the path:  $ curl -X POST http://localhost:8080/post  You should see  IN POST!  for the response!  Using this approach, you can build re-usable applications that are\ncontainer-driven, and add one-off routes and middleware as needed.", 
            "title": "Hybrid Container and Programmatic Creation"
        }, 
        {
            "location": "/reference/usage-examples/#using-the-container-to-register-middleware", 
            "text": "If you use a container to fetch your application instance, you have an\nadditional option for specifying middleware for the pipeline: configuration:  ?php\nreturn [\n    'routes' =  [\n        [\n            'path' =  '/path/to/match',\n            'middleware' =  'Middleware Service Name or Callable',\n            'allowed_methods' =  [ 'GET', 'POST', 'PATCH' ],\n            'options' =  [\n                'stuff' =  'to',\n                'pass'  =  'to',\n                'the'   =  'underlying router',\n            ],\n        ],\n        // etc.\n    ],\n    'middleware_pipeline' =  [\n        // See specification below\n    ],\n];  The key to note is  middleware_pipeline , which is an array of middlewares to\nregister in the pipeline; each will each be  pipe() 'd to the Application in the\norder specified.  Each middleware specified must be in the following form:  [\n    // required:\n    'middleware' =  'Name of middleware service, or a callable',\n    // optional:\n    'path'  =  '/path/to/match',\n    'error' =  true,\n    'priority' =  1, // Integer\n]  Priority should be an integer, and follows the semantics of SplPriorityQueue : higher numbers indicate\nhigher priority (top of the queue; executed earliest), while lower numbers\nindicated lower priority (bottom of the queue, executed last);  negative values\nare low priority . Items of the same priority are executed in the order in which\nthey are attached.  The default priority is 1, and this priority is used by the routing and dispatch\nmiddleware. To indicate that middleware should execute  before  these, use a\npriority higher than 1. For error middleware, use a priority less than 1.  The above specification can be used for all middleware, with one exception:\nregistration of the  routing  and/or  dispatch  middleware that Expressive\nprovides. In these cases, use the following constants, which will be caught by\nthe factory and expanded:   Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE  for the\n  routing middleware; this should always come before the dispatch middleware.  Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE  for the\n  dispatch middleware.   As an example:  return [\n    'middleware_pipeline' =  [\n        [ /* ... */ ],\n        Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n        Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n        [ /* ... */ ],\n    ],\n];", 
            "title": "Using the container to register middleware"
        }, 
        {
            "location": "/reference/usage-examples/#place-routing-middleware-correctly", 
            "text": "If you are defining routes  and  defining other middleware for the pipeline,\nyou  must  add the routing middleware. When you do so, make sure you put\nit at the appropriate location in the pipeline.  Typically, you will place any middleware you want to execute on all requests\nprior to the routing middleware. This includes utilities for bootstrapping\nthe application (such as injection of the  ServerUrlHelper ),\nutilities for injecting common response headers (such as CORS support), etc.\nMake sure these middleware specifications include the  priority  key, and that\nthe value of this key is greater than 1.  Place  error  middleware  after  the routing middleware. This is middleware\nthat should only execute if routing fails or routed middleware cannot complete\nthe response. These specifications should also include the  priority  key, and\nthe value of that key for such middleware should be less than 1 or negative.  Use priority to shape the specific workflow you want for your middleware.   Middleware items may be any callable,  Zend\\Stratigility\\MiddlewareInterface \nimplementation, or a service name that resolves to one of the two. Additionally,\nyou can specify an array of such values; these will be composed in a single Zend\\Stratigility\\MiddlewarePipe  instance, allowing layering of middleware.\nIn fact, you can specify the various  ApplicationFactory::*_MIDDLEWARE \nconstants in such arrays as well:  return [\n    'middleware_pipeline' =  [\n        [ /* ... */ ],\n        'routing' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                /* ... middleware that introspects routing results ... */\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n        [ /* ... */ ],\n    ],\n];", 
            "title": "Place routing middleware correctly"
        }, 
        {
            "location": "/reference/usage-examples/#pipeline-keys-are-ignored", 
            "text": "Keys in a  middleware_pipeline  specification are ignored. However, they can\nbe useful when merging several configurations; if multiple configuration files\nspecify the same key, then those entries will be merged. Be aware, however,\nthat the  middleware  entry for each, since it is an indexed array, will\nmerge arrays by appending; in other words, order will not be guaranteed within\nthat array after merging. If order is critical, define a middleware spec with priority  keys.   The path, if specified, can only be a literal path to match, and is typically\nused for segregating middleware applications or applying rules to subsets of an\napplication that match a common path root.  error  indicates whether or not the middleware represents error middleware;\nthis is done to ensure that lazy-loading of error middleware works as expected.", 
            "title": "Pipeline keys are ignored"
        }, 
        {
            "location": "/reference/usage-examples/#lazy-loaded-middleware", 
            "text": "One feature of the  middleware_pipeline  is that any middleware service pulled\nfrom the container is actually wrapped in a closure:  function ($request, $response, $next = null) use ($container, $middleware) {\n    $invokable = $container- get($middleware);\n    if (! is_callable($invokable)) {\n        throw new Exception\\InvalidMiddlewareException(sprintf(\n            'Lazy-loaded middleware  %s  is not invokable',\n            $middleware\n        ));\n    }\n    return $invokable($request, $response, $next);\n};  If the  error  flag is specified and is truthy, the closure looks like this\ninstead, to ensure the middleware is treated by Stratigility as error\nmiddleware:  function ($error, $request, $response, $next) use ($container, $middleware) {\n    $invokable = $container- get($middleware);\n    if (! is_callable($invokable)) {\n        throw new Exception\\InvalidMiddlewareException(sprintf(\n            'Lazy-loaded middleware  %s  is not invokable',\n            $middleware\n        ));\n    }\n    return $invokable($error, $request, $response, $next);\n};  This implements  lazy-loading  for middleware pipeline services, delaying\nretrieval from the container until the middleware is actually invoked.  This also means that if the service specified is not valid middleware, you\nwill not find out until the application attempts to invoke it.", 
            "title": "Lazy-loaded Middleware"
        }, 
        {
            "location": "/reference/usage-examples/#segregating-your-application-to-a-subpath", 
            "text": "One benefit of a middleware-based application is the ability to compose\nmiddleware and segregate them by paths.  Zend\\Expressive\\Application  is itself\nmiddleware, allowing you to do exactly that if desired.  In the following example, we'll assume that  $api  and  $blog  are Zend\\Expressive\\Application  instances, and compose them into a Zend\\Stratigility\\MiddlewarePipe .  use Zend\\Diactoros\\Server;\nuse Zend\\Diactoros\\ServerRequestFactory;\nuse Zend\\Stratigility\\MiddlewarePipe;\n\nrequire __DIR__ . '/../vendor/autoload.php';\n\n$app = new MiddlewarePipe();\n$app- pipe('/blog', $blog);\n$app- pipe('/api', $api);\n\n$server = Server::createServerFromRequest(\n    $app,\n    ServerRequestFactory::fromGlobals()\n);\n$server- listen();  You could also compose them in an  Application  instance, and utilize  run() :  $app = AppFactory::create();\n$app- pipe('/blog', $blog);\n$app- pipe('/api', $api);\n\n$app- run();  This approach allows you to develop discrete applications and compose them\ntogether to create a website.", 
            "title": "Segregating your application to a subpath"
        }, 
        {
            "location": "/reference/expressive-projects/", 
            "text": "Projects powered by zend-expressive\n\n\nzend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.\n\n\nSample Code \n Tutorials\n\n\n\n\nExpressive Tutorial (WIP) - \nsource\n\n\nAstroSplash\n - \nsource\n\n  (Also, read the \nrelated article on sitepoint\n)\n\n\nphp-ddd-cargo-sample\n - \nsource\n\n\n\n\nPersonal Sites\n\n\n\n\nmwop.net\n - \nsource\n\n\nxtreamwayz.com\n - \nsource\n\n\nalejandrocelaya.com\n - \nsource", 
            "title": "Expressive Projects"
        }, 
        {
            "location": "/reference/expressive-projects/#projects-powered-by-zend-expressive", 
            "text": "zend-expressive can be used for anything. Here are some projects, tutorials and\nthe related source code. Have a look around and see how others have used\nzend-expressive.", 
            "title": "Projects powered by zend-expressive"
        }, 
        {
            "location": "/reference/expressive-projects/#sample-code-tutorials", 
            "text": "Expressive Tutorial (WIP) -  source  AstroSplash  -  source \n  (Also, read the  related article on sitepoint )  php-ddd-cargo-sample  -  source", 
            "title": "Sample Code &amp; Tutorials"
        }, 
        {
            "location": "/reference/expressive-projects/#personal-sites", 
            "text": "mwop.net  -  source  xtreamwayz.com  -  source  alejandrocelaya.com  -  source", 
            "title": "Personal Sites"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/", 
            "text": "Migration from RC5 or earlier\n\n\nRC6 introduced changes to the following:\n\n\n\n\nThe routing middleware was split into separate middleware, one for routing,\n  and one for dispatching.\n\n\nDue to the above change, we decided to remove auto-registration of routing\n  middleware.\n\n\nThe above change also suggested an alternative to the middleware pipeline\n  configuration that simplifies it.\n\n\nRoute result observers are deprecated, and no longer triggered for routing\n  failures.\n\n\nMiddleware configuration specifications now accept a \npriority\n key to\n  guarantee the order of items. If you have defined your middleware pipeline in\n  multiple files that are then merged, you will need to defined these keys to\n  ensure order.\n\n\n\n\nRouting and Dispatch middleware\n\n\nPrior to RC6, the routing middleware:\n\n\n\n\nperformed routing\n\n\nnotified route result observers\n\n\ncreated a new request that composed the matched routing parameters as request\n  attributes, and composed the route result instance itself as a request\n  attribute.\n\n\nmarshaled the middleware matched by routing\n\n\ndispatched the marshaled middleware\n\n\n\n\nTo provide a better separation of concerns, we split the routing middleware into\ntwo distinct methods: \nroutingMiddleware()\n and \ndispatchMiddleware()\n.\n\n\nroutingMiddleware()\n performs the following duties:\n\n\n\n\nrouting; and\n\n\ncreating a new request that composes the matched routing parameters as request\n  attributes, and composes the route result instance itself as a request\n  attribute.\n\n\n\n\ndispatchMiddleware()\n performs the following duties:\n\n\n\n\nmarshaling the middleware specified in the route result; and\n\n\ndispatching the marshaled middleware.\n\n\n\n\nOne reason for this split is to allow injecting middleware to operate between\nrouting and dispatch. As an example, you could have middleware that determines\nif a matched route requires an authenticated identity:\n\n\npublic function __invoke($request, $response, $next)\n{\n    $result = $request-\ngetAttribute(RouteResult::class);\n    if (! in_array($result-\ngetMatchedRouteName(), $this-\nauthRequired)) {\n        return $next($request, $response);\n    }\n\n    if (! $this-\nauthenticated) {\n        return $next($request, $response-\nwithStatus(401), 'authentication\n        required');\n    }\n}\n\n\n\n\nThe above could then be piped between the routing and dispatch middleware:\n\n\n$app-\npipeRoutingMiddleware();\n$app-\npipe(AuthenticationMiddleware::class);\n$app-\npipeDispatchMiddleware();\n\n\n\n\nSince the routing middleware has been split, we determined we could no longer\nautomatically pipe the routing middleware; detection would require detecting\nboth sets of middleware, and ensuring they are in the correct order.\nAdditionally, since one goal of splitting the middleware is to allow\n\nsubstitutions\n for these responsibilities, auto-injection could in some cases\nbe undesired. As a result, we now require you to inject each manually.\n\n\nImpact\n\n\nThis change will require changes in your application.\n\n\n\n\nIf you are using Expressive programmatically (i.e., you are not using\n   a container and the \nZend\\Expressive\\Container\\ApplicationFactory\n),\n   you are now \nrequired\n to call \nApplication::pipeRoutingMiddleware()\n.\n   Additionally, a new method, \nApplication::pipeDispatchMiddleware()\n exists\n   for injecting the application with the dispatch middleware, this, too, must\n   be called.\n\n\n\n\nThis has a fortunate side effect: registering routed middleware no longer\n   affects the middleware pipeline order. As such, you can register your\n   pipeline first or last prior to running the application. The only stipulation\n   is that \nunless you register the routing \nand\n dispatch middleware, your routed\n   middleware will not be executed!\n As such, the following two lines \nmust\n\n   be added to your application prior to calling \nApplication::run()\n:\n\n\n$app-\npipeRoutingMiddleware();\n$app-\npipeDispatchMiddleware();\n\n\n\n\n\n\nIf you are creating your \nApplication\n instance using a container and the\n   \nZend\\Expressive\\Container\\ApplicationFactory\n, you will need to update your\n   configuration to list the routing and dispatch middleware. The next section\n   details the configuration changes necessary.\n\n\n\n\nApplicationFactory configuration changes\n\n\nAs noted in the document summary, the middleware pipeline configuration was\nchanged starting in RC6.  The changes are done in such a way as to honor\nconfiguration from RC5 and earlier, but using such configuration will now prompt\nyou to update your application.\n\n\nRC5 and earlier defined the default \nmiddleware_pipeline\n configuration as follows:\n\n\nreturn [\n    'middleware_pipeline' =\n [\n        // An array of middleware to register prior to registration of the\n        // routing middleware\n        'pre_routing' =\n [\n            //[\n            // Required:\n            //    'middleware' =\n 'Name or array of names of middleware services and/or callables',\n            // Optional:\n            //    'path'  =\n '/path/to/match',\n            //    'error' =\n true,\n            //],\n            [\n                'middleware' =\n [\n                    Helper\\ServerUrlMiddleware::class,\n                    Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n        ],\n\n        // An array of middleware to register after registration of the\n        // routing middleware\n        'post_routing' =\n [\n            //[\n            // Required:\n            //    'middleware' =\n 'Name of middleware service, or a callable',\n            // Optional:\n            //    'path'  =\n '/path/to/match',\n            //    'error' =\n true,\n            //],\n        ],\n    ],\n];\n\n\n\n\nThe following changes have been made:\n\n\n\n\nThe concept of \npre_routing\n and \npost_routing\n have been deprecated, and will\n  be removed starting with the 1.1 version. A single middleware pipeline is now\n  provided, though \nany individual specification can also specify an array of\n  middleware\n.\n\n\nThe routing and dispatch middleware must now be added to your configuration\n  for them to be added to your application.\n\n\nMiddleware specifications can now optionally provide a \npriority\n key, with 1\n  being the default. High integer priority indicates earlier execution, while\n  low/negative integer priority indicates later execution. Items with the same\n  priority are executed in the order they are registered. Priority is now how\n  you can indicate the order in which middleware should execute.\n\n\n\n\nImpact\n\n\nWhile the configuration from RC5 and earlier will continue to work, it will\nraise deprecation notices. As such, you will need to update your configuration\nto follow the guidelines created with RC6.\n\n\nRC6 and later change the configuration to remove the \npre_routing\n and\n\npost_routing\n keys. However, individual items within the array retain the same\nformat as middleware inside those keys, with the addition of a new key,\n\npriority\n:\n\n\n[\n    // Required:\n    'middleware' =\n 'Name of middleware service, or a callable',\n    // Optional:\n    //    'path'  =\n '/path/to/match',\n    //    'error' =\n true,\n    //    'priority' =\n 1, // integer\n]\n\n\n\n\nThe \npriority\n key is used to determine the order in which middleware is piped\nto the application. Higher integer values are piped earlier, while\nlower/negative integer values are piped later; middleware with the same priority\nare piped in the order in which they are discovered in the pipeline. The default\npriority used is 1.\n\n\nAdditionally, the routing and dispatch middleware now become items in the array;\nthey (or equivalent entries for your own implementations) must be present in\nyour configuration if you want your routed middleware to dispatch!  This change\ngives you full control over the flow of the pipeline.\n\n\nTo specify the routing middleware, use the constant\n\nZend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE\n in place of\na middleware array; this has the value \nEXPRESSIVE_ROUTING_MIDDLEWARE\n, if you\ndo not want to import the class. Similarly, for the dispatch middleware, use the\nconstant \nZend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE\n\n(value \nEXPRESSIVE_DISPATCH_MIDDLEWARE\n) to specify the dispatch middleware.\n\n\nAs such, the default configuration now becomes:\n\n\nreturn [\n    'middleware_pipeline' =\n [\n        // An array of middleware to pipe to the application.\n        // Each item is of the following structure:\n        // [\n        //     // Required:\n        //     'middleware' =\n 'Name or array of names of middleware services and/or callables',\n        //     // Optional:\n        //     'path'  =\n '/path/to/match',\n        //     'error' =\n true,\n        // ],\n        [\n            'middleware' =\n [\n                Helper\\ServerUrlMiddleware::class,\n            ],\n            'priority' =\n PHP_INT_MAX,\n        ],\n\n        // The following is an entry for:\n        // - routing middleware\n        // - middleware that reacts to the routing results\n        // - dispatch middleware\n        [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ]\n\n        // The following is an entry for the dispatch middleware:\n\n        // Place error handling middleware after the routing and dispatch\n        // middleware, with negative priority.\n        // [\n        //     'middleware' =\n [\n        //     ],\n        //     'priority' =\n -1000,\n        // ],\n    ],\n];\n\n\n\n\nTo update an existing application:\n\n\n\n\nPromote all \npre_routing\n middleware up a level, and remove the \npre_routing\n\n  key. Provide a \npriority\n value greater than 1. We recommend having a single\n  middleware specification with an array of middleware that represents the \"pre\n  routing\" middleware.\n\n\nAdd the entries for \nZend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE\n\n  and \nZend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE\n\n  immediately following any \npre_routing\n middleware, and before any\n  \npost_routing\n middleware; we recommend grouping it per the above example.\n\n\nPromote all \npost_routing\n middleware up a level, and remove the\n  \npost_routing\n key. Provide a \npriority\n value less than 1 or negative.\n\n\nIf you have \nmiddleware_pipeline\n specifications in multiple files\n, you\n  will need to specify \npriority\n keys for all middleware in order to guarantee\n  order after merging. We recommend having a single middleware specification\n  with an array of middleware that represents the \"post routing\" middleware.\n\n\n\n\nAs an example, consider the following application configuration:\n\n\nreturn [\n    'middleware_pipeline' =\n [\n        'pre_routing' =\n [\n            [\n                'middleware' =\n [\n                    Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                    Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n            [ 'middleware' =\n DebugToolbarMiddleware::class ],\n            [\n                'middleware' =\n ApiMiddleware::class,\n                'path' =\n '/api',\n            ],\n        ],\n\n        'post_routing' =\n [\n            ['middleware' =\n NotFoundMiddleware::class, 'error' =\n true],\n        ],\n    ],\n];\n\n\n\n\nThis would be rewritten to the following to work with RC6 and later:\n\n\nreturn [\n    'middleware_pipeline' =\n [\n        'always' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                DebugToolbarMiddleware::class,\n            ],\n            'priority' =\n PHP_INT_MAX,\n        ],\n        'api' =\n [\n            'middleware' =\n ApiMiddleware::class,\n            'path' =\n '/api',\n            'priority' =\n 100,\n        ],\n\n        'routing' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n\n        'error' =\n [\n            'middleware' =\n [\n                NotFoundMiddleware::class,\n            ],\n            'error' =\n true,\n            'priority' =\n -1000,\n        ],\n    ],\n]\n\n\n\n\nNote in the above example the various groupings. By grouping middleware by\npriority, you can simplify adding new middleware, particularly if you know it\nshould execute before routing, or as error middleware, or between routing and\ndispatch.\n\n\n\n\nKeys are ignored\n\n\nThe above example provides keys for each middleware specification. The factory\nwill ignore these, but they can be useful for cases when you might want to\nspecify configuration in multiple files, and merge specific entries together.\nBe aware, however, that the \nmiddleware\n key itself is an indexed array;\nitems will be appended based on the order in which configuration files are\nmerged. If order of these is important, create separate specifications with\nrelevant \npriority\n values.\n\n\n\n\nRoute result observer deprecation\n\n\nAs of RC6, the following changes have occurred with regards to route result\nobservers:\n\n\n\n\nThey are deprecated for usage with \nZend\\Expressive\\Application\n, and that\n  class will not be a route result subject starting in 1.1. You will need to\n  start migrating to alternative solutions.\n\n\nThe functionality for notifying observers has been moved from the routing\n  middleware into a dedicated \nApplication::routeResultObserverMiddleware()\n\n  method. This middleware must be piped separately to the middleware pipeline\n  for it to trigger.\n\n\n\n\nImpact\n\n\nIf you are using any route result observers, you will need to ensure your\napplication notifies them, and you will want to migrate to alternative solutions\nto ensure your functionality continues to work.\n\n\nTo ensure your observers are triggered, you will need to adapt your application,\nbased on how you create your instance.\n\n\nIf you are \nnot\n using the \nApplicationFactory\n, you will need to pipe the\n\nrouteResultObserverMiddleware\n to your application, between the routing and\ndispatch middleware:\n\n\n$app-\npipeRoutingMiddleware();\n$app-\npipeRouteResultObserverMiddleware();\n$app-\npipeDispatchMiddleware();\n\n\n\n\nIf you are using the \nApplicationFactory\n, you may need to update your\nconfiguration to allow injecting the route result observer middleware. If you\nhave \nnot\n updated your configuration to remove the \npre_routing\n and/or\n\npost_routing\n keys, the middleware \nwill\n be registered for you. If you have,\nhowever, you will need to register it following the routing middleware:\n\n\n[\n    'middleware_pipeline' =\n [\n        /* ... */\n        'routing' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTE_RESULT_OBSERVER_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n        /* ... */\n    ],\n]\n\n\n\n\nTo make your observers forwards-compatible requires two changes:\n\n\n\n\nRewriting your observer as middleware.\n\n\nRegistering your observer as middleware following the routing middleware.\n\n\n\n\nIf your observer looked like the following:\n\n\nuse Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Router\\RouteResultObserverInterface;\n\nclass MyObserver implements RouteResultObserverInterface\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this-\nlogger = $logger;\n    }\n\n    public function update(RouteResult $result)\n    {\n        $this-\nlogger-\nlog($result);\n    }\n}\n\n\n\n\nYou could rewrite it as follows:\n\n\nuse Zend\\Expressive\\Router\\RouteResult;\n\nclass MyObserver\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this-\nlogger = $logger;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $result = $request-\ngetAttribute(RouteResult::class, false);\n        if (! $result) {\n            return $next($request, $response);\n        }\n\n        $this-\nlogger-\nlog($result);\n        return $next($request, $response);\n    }\n}\n\n\n\n\nYou would then register it following the routing middleware. If you are building\nyour application programmatically, you would do this as follows:\n\n\n$app-\npipeRoutingMiddleware();\n$app-\npipe(MyObserver::class);\n$app-\npipeDispatchMiddleware();\n\n\n\n\nIf you are using the \nApplicationFactory\n, alter your configuration:\n\n\n[\n    'middleware_pipeline' =\n [\n        /* ... */\n        'routing' =\n [\n            'middleware' =\n [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                MyObserver::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =\n 1,\n        ],\n        /* ... */\n    ],\n]\n\n\n\n\nTimeline for migration\n\n\nThe following features will be removed in version 1.1.0:\n\n\n\n\nSupport for the \npre_routing\n and \npost_routing\n configuration.\n\n\nSupport for route result observers.", 
            "title": "From RC5 and Earlier"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/#migration-from-rc5-or-earlier", 
            "text": "RC6 introduced changes to the following:   The routing middleware was split into separate middleware, one for routing,\n  and one for dispatching.  Due to the above change, we decided to remove auto-registration of routing\n  middleware.  The above change also suggested an alternative to the middleware pipeline\n  configuration that simplifies it.  Route result observers are deprecated, and no longer triggered for routing\n  failures.  Middleware configuration specifications now accept a  priority  key to\n  guarantee the order of items. If you have defined your middleware pipeline in\n  multiple files that are then merged, you will need to defined these keys to\n  ensure order.", 
            "title": "Migration from RC5 or earlier"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/#routing-and-dispatch-middleware", 
            "text": "Prior to RC6, the routing middleware:   performed routing  notified route result observers  created a new request that composed the matched routing parameters as request\n  attributes, and composed the route result instance itself as a request\n  attribute.  marshaled the middleware matched by routing  dispatched the marshaled middleware   To provide a better separation of concerns, we split the routing middleware into\ntwo distinct methods:  routingMiddleware()  and  dispatchMiddleware() .  routingMiddleware()  performs the following duties:   routing; and  creating a new request that composes the matched routing parameters as request\n  attributes, and composes the route result instance itself as a request\n  attribute.   dispatchMiddleware()  performs the following duties:   marshaling the middleware specified in the route result; and  dispatching the marshaled middleware.   One reason for this split is to allow injecting middleware to operate between\nrouting and dispatch. As an example, you could have middleware that determines\nif a matched route requires an authenticated identity:  public function __invoke($request, $response, $next)\n{\n    $result = $request- getAttribute(RouteResult::class);\n    if (! in_array($result- getMatchedRouteName(), $this- authRequired)) {\n        return $next($request, $response);\n    }\n\n    if (! $this- authenticated) {\n        return $next($request, $response- withStatus(401), 'authentication\n        required');\n    }\n}  The above could then be piped between the routing and dispatch middleware:  $app- pipeRoutingMiddleware();\n$app- pipe(AuthenticationMiddleware::class);\n$app- pipeDispatchMiddleware();  Since the routing middleware has been split, we determined we could no longer\nautomatically pipe the routing middleware; detection would require detecting\nboth sets of middleware, and ensuring they are in the correct order.\nAdditionally, since one goal of splitting the middleware is to allow substitutions  for these responsibilities, auto-injection could in some cases\nbe undesired. As a result, we now require you to inject each manually.", 
            "title": "Routing and Dispatch middleware"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/#impact", 
            "text": "This change will require changes in your application.   If you are using Expressive programmatically (i.e., you are not using\n   a container and the  Zend\\Expressive\\Container\\ApplicationFactory ),\n   you are now  required  to call  Application::pipeRoutingMiddleware() .\n   Additionally, a new method,  Application::pipeDispatchMiddleware()  exists\n   for injecting the application with the dispatch middleware, this, too, must\n   be called.   This has a fortunate side effect: registering routed middleware no longer\n   affects the middleware pipeline order. As such, you can register your\n   pipeline first or last prior to running the application. The only stipulation\n   is that  unless you register the routing  and  dispatch middleware, your routed\n   middleware will not be executed!  As such, the following two lines  must \n   be added to your application prior to calling  Application::run() :  $app- pipeRoutingMiddleware();\n$app- pipeDispatchMiddleware();   If you are creating your  Application  instance using a container and the\n    Zend\\Expressive\\Container\\ApplicationFactory , you will need to update your\n   configuration to list the routing and dispatch middleware. The next section\n   details the configuration changes necessary.", 
            "title": "Impact"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/#applicationfactory-configuration-changes", 
            "text": "As noted in the document summary, the middleware pipeline configuration was\nchanged starting in RC6.  The changes are done in such a way as to honor\nconfiguration from RC5 and earlier, but using such configuration will now prompt\nyou to update your application.  RC5 and earlier defined the default  middleware_pipeline  configuration as follows:  return [\n    'middleware_pipeline' =  [\n        // An array of middleware to register prior to registration of the\n        // routing middleware\n        'pre_routing' =  [\n            //[\n            // Required:\n            //    'middleware' =  'Name or array of names of middleware services and/or callables',\n            // Optional:\n            //    'path'  =  '/path/to/match',\n            //    'error' =  true,\n            //],\n            [\n                'middleware' =  [\n                    Helper\\ServerUrlMiddleware::class,\n                    Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n        ],\n\n        // An array of middleware to register after registration of the\n        // routing middleware\n        'post_routing' =  [\n            //[\n            // Required:\n            //    'middleware' =  'Name of middleware service, or a callable',\n            // Optional:\n            //    'path'  =  '/path/to/match',\n            //    'error' =  true,\n            //],\n        ],\n    ],\n];  The following changes have been made:   The concept of  pre_routing  and  post_routing  have been deprecated, and will\n  be removed starting with the 1.1 version. A single middleware pipeline is now\n  provided, though  any individual specification can also specify an array of\n  middleware .  The routing and dispatch middleware must now be added to your configuration\n  for them to be added to your application.  Middleware specifications can now optionally provide a  priority  key, with 1\n  being the default. High integer priority indicates earlier execution, while\n  low/negative integer priority indicates later execution. Items with the same\n  priority are executed in the order they are registered. Priority is now how\n  you can indicate the order in which middleware should execute.", 
            "title": "ApplicationFactory configuration changes"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/#impact_1", 
            "text": "While the configuration from RC5 and earlier will continue to work, it will\nraise deprecation notices. As such, you will need to update your configuration\nto follow the guidelines created with RC6.  RC6 and later change the configuration to remove the  pre_routing  and post_routing  keys. However, individual items within the array retain the same\nformat as middleware inside those keys, with the addition of a new key, priority :  [\n    // Required:\n    'middleware' =  'Name of middleware service, or a callable',\n    // Optional:\n    //    'path'  =  '/path/to/match',\n    //    'error' =  true,\n    //    'priority' =  1, // integer\n]  The  priority  key is used to determine the order in which middleware is piped\nto the application. Higher integer values are piped earlier, while\nlower/negative integer values are piped later; middleware with the same priority\nare piped in the order in which they are discovered in the pipeline. The default\npriority used is 1.  Additionally, the routing and dispatch middleware now become items in the array;\nthey (or equivalent entries for your own implementations) must be present in\nyour configuration if you want your routed middleware to dispatch!  This change\ngives you full control over the flow of the pipeline.  To specify the routing middleware, use the constant Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE  in place of\na middleware array; this has the value  EXPRESSIVE_ROUTING_MIDDLEWARE , if you\ndo not want to import the class. Similarly, for the dispatch middleware, use the\nconstant  Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE \n(value  EXPRESSIVE_DISPATCH_MIDDLEWARE ) to specify the dispatch middleware.  As such, the default configuration now becomes:  return [\n    'middleware_pipeline' =  [\n        // An array of middleware to pipe to the application.\n        // Each item is of the following structure:\n        // [\n        //     // Required:\n        //     'middleware' =  'Name or array of names of middleware services and/or callables',\n        //     // Optional:\n        //     'path'  =  '/path/to/match',\n        //     'error' =  true,\n        // ],\n        [\n            'middleware' =  [\n                Helper\\ServerUrlMiddleware::class,\n            ],\n            'priority' =  PHP_INT_MAX,\n        ],\n\n        // The following is an entry for:\n        // - routing middleware\n        // - middleware that reacts to the routing results\n        // - dispatch middleware\n        [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ]\n\n        // The following is an entry for the dispatch middleware:\n\n        // Place error handling middleware after the routing and dispatch\n        // middleware, with negative priority.\n        // [\n        //     'middleware' =  [\n        //     ],\n        //     'priority' =  -1000,\n        // ],\n    ],\n];  To update an existing application:   Promote all  pre_routing  middleware up a level, and remove the  pre_routing \n  key. Provide a  priority  value greater than 1. We recommend having a single\n  middleware specification with an array of middleware that represents the \"pre\n  routing\" middleware.  Add the entries for  Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE \n  and  Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE \n  immediately following any  pre_routing  middleware, and before any\n   post_routing  middleware; we recommend grouping it per the above example.  Promote all  post_routing  middleware up a level, and remove the\n   post_routing  key. Provide a  priority  value less than 1 or negative.  If you have  middleware_pipeline  specifications in multiple files , you\n  will need to specify  priority  keys for all middleware in order to guarantee\n  order after merging. We recommend having a single middleware specification\n  with an array of middleware that represents the \"post routing\" middleware.   As an example, consider the following application configuration:  return [\n    'middleware_pipeline' =  [\n        'pre_routing' =  [\n            [\n                'middleware' =  [\n                    Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                    Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                ],\n            ],\n            [ 'middleware' =  DebugToolbarMiddleware::class ],\n            [\n                'middleware' =  ApiMiddleware::class,\n                'path' =  '/api',\n            ],\n        ],\n\n        'post_routing' =  [\n            ['middleware' =  NotFoundMiddleware::class, 'error' =  true],\n        ],\n    ],\n];  This would be rewritten to the following to work with RC6 and later:  return [\n    'middleware_pipeline' =  [\n        'always' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Helper\\ServerUrlMiddleware::class,\n                DebugToolbarMiddleware::class,\n            ],\n            'priority' =  PHP_INT_MAX,\n        ],\n        'api' =  [\n            'middleware' =  ApiMiddleware::class,\n            'path' =  '/api',\n            'priority' =  100,\n        ],\n\n        'routing' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Helper\\UrlHelperMiddleware::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n\n        'error' =  [\n            'middleware' =  [\n                NotFoundMiddleware::class,\n            ],\n            'error' =  true,\n            'priority' =  -1000,\n        ],\n    ],\n]  Note in the above example the various groupings. By grouping middleware by\npriority, you can simplify adding new middleware, particularly if you know it\nshould execute before routing, or as error middleware, or between routing and\ndispatch.", 
            "title": "Impact"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/#keys-are-ignored", 
            "text": "The above example provides keys for each middleware specification. The factory\nwill ignore these, but they can be useful for cases when you might want to\nspecify configuration in multiple files, and merge specific entries together.\nBe aware, however, that the  middleware  key itself is an indexed array;\nitems will be appended based on the order in which configuration files are\nmerged. If order of these is important, create separate specifications with\nrelevant  priority  values.", 
            "title": "Keys are ignored"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/#route-result-observer-deprecation", 
            "text": "As of RC6, the following changes have occurred with regards to route result\nobservers:   They are deprecated for usage with  Zend\\Expressive\\Application , and that\n  class will not be a route result subject starting in 1.1. You will need to\n  start migrating to alternative solutions.  The functionality for notifying observers has been moved from the routing\n  middleware into a dedicated  Application::routeResultObserverMiddleware() \n  method. This middleware must be piped separately to the middleware pipeline\n  for it to trigger.", 
            "title": "Route result observer deprecation"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/#impact_2", 
            "text": "If you are using any route result observers, you will need to ensure your\napplication notifies them, and you will want to migrate to alternative solutions\nto ensure your functionality continues to work.  To ensure your observers are triggered, you will need to adapt your application,\nbased on how you create your instance.  If you are  not  using the  ApplicationFactory , you will need to pipe the routeResultObserverMiddleware  to your application, between the routing and\ndispatch middleware:  $app- pipeRoutingMiddleware();\n$app- pipeRouteResultObserverMiddleware();\n$app- pipeDispatchMiddleware();  If you are using the  ApplicationFactory , you may need to update your\nconfiguration to allow injecting the route result observer middleware. If you\nhave  not  updated your configuration to remove the  pre_routing  and/or post_routing  keys, the middleware  will  be registered for you. If you have,\nhowever, you will need to register it following the routing middleware:  [\n    'middleware_pipeline' =  [\n        /* ... */\n        'routing' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTE_RESULT_OBSERVER_MIDDLEWARE,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n        /* ... */\n    ],\n]  To make your observers forwards-compatible requires two changes:   Rewriting your observer as middleware.  Registering your observer as middleware following the routing middleware.   If your observer looked like the following:  use Zend\\Expressive\\Router\\RouteResult;\nuse Zend\\Expressive\\Router\\RouteResultObserverInterface;\n\nclass MyObserver implements RouteResultObserverInterface\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this- logger = $logger;\n    }\n\n    public function update(RouteResult $result)\n    {\n        $this- logger- log($result);\n    }\n}  You could rewrite it as follows:  use Zend\\Expressive\\Router\\RouteResult;\n\nclass MyObserver\n{\n    private $logger;\n\n    public function __construct(Logger $logger)\n    {\n        $this- logger = $logger;\n    }\n\n    public function __invoke($request, $response, $next)\n    {\n        $result = $request- getAttribute(RouteResult::class, false);\n        if (! $result) {\n            return $next($request, $response);\n        }\n\n        $this- logger- log($result);\n        return $next($request, $response);\n    }\n}  You would then register it following the routing middleware. If you are building\nyour application programmatically, you would do this as follows:  $app- pipeRoutingMiddleware();\n$app- pipe(MyObserver::class);\n$app- pipeDispatchMiddleware();  If you are using the  ApplicationFactory , alter your configuration:  [\n    'middleware_pipeline' =  [\n        /* ... */\n        'routing' =  [\n            'middleware' =  [\n                Zend\\Expressive\\Container\\ApplicationFactory::ROUTING_MIDDLEWARE,\n                MyObserver::class,\n                Zend\\Expressive\\Container\\ApplicationFactory::DISPATCH_MIDDLEWARE,\n            ],\n            'priority' =  1,\n        ],\n        /* ... */\n    ],\n]", 
            "title": "Impact"
        }, 
        {
            "location": "/reference/migration/rc-to-v1/#timeline-for-migration", 
            "text": "The following features will be removed in version 1.1.0:   Support for the  pre_routing  and  post_routing  configuration.  Support for route result observers.", 
            "title": "Timeline for migration"
        }
    ]
}